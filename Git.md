скопировать файл из одной ветки или из другого коммита. обновили конфиг и надо у себя в ветке тоже его использовать без слияний и прочих лишних действий.

git checkout <from-branch-name> <path-to-file-or-dir>

репозиторий с двумя ветками и в ветке second  будет файл в директории.

git init -b master&& \
echo "this is txt file" > main.txt && \
git add main.txt && \
git commit -m "Initial commit" && \
git checkout -b second && \
mkdir myDir && \
echo "must be copied" > myDir/second.txt && \
git add myDir/second.txt && \
git commit -m "added second.txt"

скопировать и выполнить все команды за один раз.

Допустим, нам требуется скопировать файл myDir/second.txt из ветки second в master. Для копирования файла, перейдите в ветку, в которую хотите скопировать файл или директорию из другой ветки.

git checkout master

После можно выполнить команду копирования:

git checkout second ./myDir/second.txt

После этого из ветки second будет скопирован файл, при этом сохранится путь до файла. То есть в master будет лежать файл в папке mydDir.

Если файл уже есть в текущей ветке - он будет перезаписан!

файл у нас скопировался:

git status

On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	new file:   myDir/second.txt

файл уже подготовлен к коммиту.

из коммита скопировать файл, просто замените название ветки на хэш коммита.

скопировать файл по другому пути? Так тоже можно, для этого можно использовать другую команду git show.

повторить действия - удалите директорию и снова создайте репозиторий с двумя ветками, использую код выше.

перейдем в master и создадим папку config и в нее позже скопируем файл second.txt.

git checkout master
mkdir config

git show <branch-name-or-hash>:<path-to-copy> > <path-to-paste>

указываем ветку или хэш коммита, далее источник файла для копирования и путь до нового файла в текущей ветке.

show “показывает” файл из другой ветки. А мы этот вывод пишем в новый файл у себя, для этого и указываем вывод через >

git show second:myDir/second.txt > config/config.txt

файл скопирован:

git status -uall

On branch master
Untracked files:
  (use "git add <file>..." to include in what will be committed)
	config/config.txt

nothing added to commit but untracked files present (use "git add" to track)

-uall покажет файлы в новых директориях, без этого параметра не увидим содержимое config

Файл на месте. он скопирован в рабочую директорию и к коммиту не подготовлен и не отслеживается гитом.



git branch newImage
The branch newImage now refers to the actual commit


Choose the branch for commiting
git checkout newImage
(git switch)


Create a new branch and check it out at the same time
git checkout -b name


Merging branch into main* (staying on main branch) - creates new merge commit on main*
git merge bugFix


current branch - git merge branch that you want merge with

Placed on bugFix aand merge with main

git checkout bufFix; git merge main


For combining commits with linear sequence. With bugFix selected
git rebase main

Now bugFix copies of commits move at the top of main branch (rebased onto main), so history is linear

Checked out on the main and rebase onto bugFix
Move the main branch reference forward on history


HEAD points to the current branch on the recent (last) commit

Detaching HEAD - attaching it to a commit instead of a branch.

Was:
HEAD -> main -> Commit1

Git checkout Commit1

Now:
HEAD -> Commit1

Changes are not effect of any branches


Relative refs
allow us use HEAD or branch name to moving on history

git checkout main^.  Find the parent of the specified commit. Now HEAD points on commits parent. This detach HEAD
Git cheackout commit2;
git checkout HEAD~3.   Num times moves HEAD to parents

-f option (not allowed for current branch) reasign a branch to a commit
git branch -f main HEAD~3
Moves by force the main branch to three parents behind HEAD


Rrvering changes

Revers changes by moving a branch reference backwars in time to an older commit.
git reset HEAD~1

Reverse last commit changes and share those with others - create commit with reversed changes:
git revert HEAD


git cherry-pick C1 C2 ...
Copy commits below HEAD (after - make them lasts)



Git Interactive Rebase
Git cherry-pick is great when you know which commits you want (and their hashes).

you don't know what commits you want? interactive rebasing -- review a series of commits you're about to rebase.

All interactive rebase - Git using rebase command with -i.
open up a UI to show you which commits are about to be copied below the target of the rebase.

reorder commits.
choose to keep all commits or drop specific ones. When the dialog opens, each commit is set to be included.
squashing (combining) commits, amending commit messages, editing the commits themselves.

git rebase -i HEAD~4

Git copied down commits in the same way you specified through the UI.


Locally stacked commits
track down a bug but it is quite elusive. In order to aid in my detective work, I put in a few debug commands and a few print statements.

All of these debugging / print statements are in their own commits. Finally I track down the bug, fix it, and rejoice!

need to get my bugFix back into the main branch. If I fast-forwarded main, then main get all my debug statements which is undesirable.

copy only one of the commits over.

git rebase -i
git cherry-pick



Juggling Commits
changes (newImage) and another set of changes (caption) that are related, so they are stacked on top of each other in your repository (aka one after another).

make a small modification to an earlier commit. change newImage, even though that commit is way back in history!

re-order the commits so the one we want to change is on top with git rebase -i
git commit --amend to make modification
Then re-order the commits back to how they were previously with git rebase -i
Finally move main to this updated part of the tree

Once the commit we wanted to change was on top, we could --amend it and re-order back to our preferred order.

git cherry-pick will plop down a commit from anywhere in the tree onto HEAD (as long as that commit isn't an ancestor of HEAD).


Git Tags
branches are easy to move around and often refer to different commits as work is completed on them.

permanently mark historical points in your project's history. For things like major releases and big merges, mark these commits with something more permanent than a branch?

Git tags permanently mark certain commits as "milestones" that you can then reference like a branch.

You can't "check out" a tag and then complete work on that tag -- tags exist as anchors in the commit tree that designate certain spots.

git tag v1 C1
(version 1)


Git Describe
tags serve as such great "anchors" in the codebase, git has a command to describe where you are relative to the closest "anchor" (tag).

get your bearings after you've moved many commits backwards or forwards in history; after you've completed a git bisect (a debugging search).


git describe <ref>

<ref> ('main' for example) is anything git can resolve into a commit. If you don't specify a ref, git uses where you're checked out right now (HEAD).

The output of the command:

<tag>-<numCommits>-g<hash>

tag is the closest ancestor tag in history, numCommits is how many commits away that tag is, and <hash> is the hash of the commit being described.


Rebasing Multiple Branches
rebase all the work from these branches onto main.

git rebase main bugFix
bugFix встанет за main
git rebase c2
ветка станет на коммит c2

Specifying Parents
Like the ~ modifier, the ^ modifier also accepts an optional number after it.

Rather than specifying the number of generations to go back (what ~ takes), the modifier on ^ specifies which parent reference to follow from a merge commit. merge commits have multiple parents, so the path to choose is ambiguous.

Git will follow the "first" parent upwards from a merge commit, but specifying a number with ^ changes this default behavior.

have a merge commit. If we checkout main^ without the modifier, we will follow the first parent after the merge commit.

git checkout main^ первый родитель (обычно ветка, в которую вливали изменения)
git checkout main^2 второй родитель (обычно ветка, которую влили)

HEAD or main эквивалентно можно использовать в командах

git branch -f three C2
ветку три переместить на коммит


git fetch удалённый репозиторий, содержит два коммита, отсутствующих в локальном.
Коммиты C2 и C3 скачаны в локальный репозиторий, удалённая ветка o/main отобразила эти изменения.

связывается с удалённым репозиторием и забирает данные проекта, которых ещё нет
должны появиться ссылки на все ветки из удалённого репозитория (o/main)
git fetch синхронизирует локальное представление удалённых репозиториев с тем, что является актуальным на текущий момент.

удалённые ветки отображают состояние удалённых репозиториев на тот момент когда вы 'общались' с ними в последний раз.
git fetch 'общается' с удалёнными репозиториями посредством Интернета (через протоколы http:// или git://).

git fetch забирает данные в локальный репозиторий, но не сливает их.

обновим работу, отобразить изменения!
локальный коммит, соединить с другой веткой.
git cherry-pick o/main
git rebase o/main
git merge o/main

Процедура скачивания (fetching) изменений с удалённой ветки и объединения (merging) - git pull.

git fetch; и git merge origin/main; - скачали C3 с fetch и объединяем наработки с git merge o/main. ветка main отображает изменения с удалённого репозитория. git pull делает тоже самое.





история версий «Revision history». зафиксированное изменение в системе контроля версий ревизией.

Фиксация изменений создаёт ревизию, ревизия может содержать внутри либо дельту изменений, либо снимок.

процесс переключения между ревизиями. загружаем ревизию, переключаемся на неё (checkout).

Между ревизиями выявлять различия в случае, если СКВ использует снимки, демонстрирует Word.

diff index.js index2.js > index.patch

patch index.js -i index.patch -o index2.js


повелительного наклонения в заголовке: «Fix scrolling» (Исправить прокрутку), а не «Fixed scrolling» (Исправлена прокрутка) или «Fixes scrolling» (Исправляет прокрутку).
Атомарность. Коммит решать одну задачу от начала до конца.  откатить изменение или перенести его в другую версию программы.


перед началом работы всегда git pull --rebase, скачивает из репозитория коммиты и добавляет в локальный.
git pull, к созданию ненужных коммитов, сложнее следить за историей.
работа с git pull знания ветвление и git rebase.


git diff показывает разницу между тем, что было и что стало. запускает пейджер искать (/слово) внутри него нужные данные.
git diff не были добавлены в индекс.
git diff --staged # были добавлены в индекс

git diff обязательно запускать перед каждым коммитом. случайно добавляют в коммит что не должно.

коммиты имеют понятное описание, и каждый из них делает одну законченную вещь — история инструментом для анализа кода.

git log список всех выполненных коммитов через пейджер
git log -p # диф для каждого коммита
git log -- file - в каких комитах менялся

У коммита — идентификатор («хеш»). посмотреть все изменения, сделанные в коммите:
git show 5120bea # диф между этим коммитом и предыдущим


не знаем коммита, кто последним менял строчку в файле? выводит файл и рядом с строчкой показывает кто ее менял и в каком коммите:

git blame INFO.md
e6f625cf (tirion 2020-09-17 16:14:09 -0400 1) git is awesome!
5120bea3 (tirion 2020-09-17 18:04:19 -0400 2) new line

git grep ищет совпадение с строкой во всех файлах проекта. знает про игнорирование и не смотрит в .git, искать по истории:

git grep -i hexlet # без учета регистра
git grep Hexlet 5120bea # Поиск в коммите

git grep Hexlet $(git rev-list --all) # Поиск по истории. список хешей `rev-list`

откат изменений, в рабочей директории, но еще не попали в коммит. откат незакоммиченных изменений безвозвратен.

добавили новые файлы в репозиторий, что они вам не нужны.
# удалит все неотслеживаемые файлы -f – force, -d – directory
git clean -fd

# Отменяем Измененные файлы в рабочей директории
git restore INFO.md

С файлами, подготовленными к коммиту — отменить изменения совсем, второй — отменить индексацию, не изменяя файлы в рабочей директории. изменения нужны, не хотим их коммитить сейчас:

git restore --staged INFO.md

git restore - окончательно отменить изменения


В Git есть способ восстановить или изменить коммиты.
Git движется «только вперед». создавать новое, а не изменять старое.
новым коммитом, изменяющим код в нужном направлении. Изменение истории коммитов — опасная операция, чревата проблемами при синхронизации с удаленными репозиториями.

отмена изменений. к созданию коммита, выполняет изменения, противоположные тому коммиту, который отменяется:

<img width="723" height="343" alt="image" src="https://github.com/user-attachments/assets/ab0049b5-acad-4f5e-8f50-974f7dbc577f" />

автоматизирующую откат git revert:

git revert aa600a4
# сообщение revert не меняют
[main 65a8ef7] Revert "remove PEOPLE.md"
 1 file changed, 1 insertion(+)
 create mode 100644 PEOPLE.md
# В проект вернулся файл PEOPLE.md

git log -p

commit 65a8ef7fd56c7356dcee35c2d05b4400f4467ca8
Author: tirion <tirion@got.com>
Date:   Sat Sep 26 15:32:46 2020 -0400

    Revert "remove PEOPLE.md"

    This reverts commit aa600a43cb164408e4ad87d216bc679d097f1a6c.

diff --git a/PEOPLE.md b/PEOPLE.md
new file mode 100644
index 0000000..4b34ba8
--- /dev/null
+++ b/PEOPLE.md
@@ -0,0 +1 @@
+Haskell Curry

Команда revert может отменять не только последний коммит, но и любой другой коммит из истории проекта. Согласитесь, это очень круто. Без системы контроля версий о таком нельзя было и мечтать.

git reset
удалить только что сделанный по ошибке коммит. git revert, но история менее читаемой. коммит сделан только сейчас и еще не отправлялся на GitHub, сделать будто коммита не существовало.
удалять коммиты если речь про коммиты, которых нет ни у кого, кроме вас.
Если коммит был отправлен во внешний репозиторий,  менять историю нельзя. сломает работу у тех, кто работает с вами над проектом.

Для удаления коммита git reset:

# Добавляем новый коммит, сразу же удалим
echo 'test' >> INFO.md
git add INFO.md
git commit -m 'update INFO.md'

[main 17a77cb] update INFO.md
 1 file changed, 1 insertion(+)
 # не делаем git push

git reset --hard HEAD~

HEAD is now at 65a8ef7 Revert "remove PEOPLE.md"

# `git log`, последнего коммита там больше нет
git reset удалять коммиты, отменять их без удаления, восстанавливать файлы из истории и так далее.
--hard полное удаление. Без него git reset отменит коммит, но не удалит его, а поместит все изменения этого коммита в рабочую директорию, с ними можно будет продолжить работать.
HEAD~ «один коммит от последнего коммита». удалить два последних коммита, HEAD~2:

<img width="745" height="343" alt="image" src="https://github.com/user-attachments/assets/15921e44-e427-42c1-8235-82af2e621073" />

HEAD — последний сделанный коммит.
Без --hard команда git reset по умолчанию работает в режиме --mixed, изменения остаются в рабочей директории, но исключаются из индекса (unstage). исправить или отменить и выполнить новый коммит:

echo 'no code no pain' >> README.md
git add README.md
git commit -m 'update README.md'

[main f85e3a6] update README.md
 1 file changed, 1 insertion(+)

# откатываем последний коммит
git reset HEAD~

Unstaged changes after reset:
M   README.md

git status

On branch main
Your branch is up to date with 'origin/main'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
    modified:   README.md

--soft сохранить изменения в индексе:

git reset --soft HEAD~1

git status

On branch main
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
    modified:   README.md

git reset --soft отменяет коммит, но оставляет изменения в индексе (staging area). Следующий коммит включит в себя те же изменения, если их не модифицировать.

Последнего коммита больше не существует. сделанные в нем изменения не пропали. Они находятся в рабочей директории для дальнейшей доработки.

<img width="749" height="575" alt="image" src="https://github.com/user-attachments/assets/6feac47d-c455-465b-a163-7646ceaa7c4a" />

отменять, даже если допущена ошибка.
git revert — безопасный способ отмены коммитов. Он создаёт новый коммит, отменяет изменения предыдущего. не меняет историю коммитов.
git reset — опасный инструмент. отменять коммиты, но при этом может изменить или удалить изменения:

git reset --soft оставляет изменения в индексе.
git reset --mixed (по умолчанию) снимает индексацию, но оставляет изменения в рабочей директории.
git reset --hard полностью удаляет изменения, и их нельзя восстановить без специальных команд.
Изменять историю коммитов с осторожностью. Если коммиты уже отправлены в удалённый репозиторий - git revert. git reset к проблемам при синхронизации с другими разработчиками.

подход в Git — двигаться вперёд. Если в коммите ошибка, проще сделать новый исправляющий коммит, чем менять историю.

Перед использованием git reset --hard убедиться, изменения не будут потеряны.


git add README.md
git commit --amend --no-edit

--amend не добавляет изменения в сущ коммит. откату коммита через git reset и выполнению нового коммита с новыми данными. один коммит, git commit выполнялась два раза (первый раз — когда сделали ошибочный коммит).


Индекс — промежуточная область, в которой хранятся изменения файлов на пути от рабочей директории до репозитория. При выполнении коммита в него только те изменения, которые были добавлены в индекс.



коммит, в который включили и основную задачу, и доп исправления. сложнее смотреть историю. Коммит содержать несвязанные изменения, отвлекают во время проверки чужого кода:

# условие И в описании
git commit -m 'add new feature and fix something'

откат коммита - откатятся правки, которые все равно нужно делать.

# Не нужно явно вызывать `git add`
git commit INFO.md -m 'update INFO.md'

перед коммитом смотреть git diff --staged.

коммит с одновременным добавлением всего в индекс:

# -a добавляет все изменения в индекс
git commit -am 'do something'
разные изменения делаются в одних и тех же файлах. изменения в этих файлах в разных коммитах.

git add -i, показывает измененные куски файлов и спрашивает, что с ними сделать

# сокращенный вывод
git log --oneline

fc74e2d update README.md
65a8ef7 Revert "remove PEOPLE.md"

Переключимся на момент, когда был выполнен коммит с сообщением add INFO.md. git checkout <хеш коммита>:

git checkout e6f625c

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by switching back to a branch.

Or undo this operation with:

  git switch -
  
пропала часть изменений из-за возврата в прошлое. вернуться на последний коммит:
git checkout main

забрать изменения, которые были удалены, но понадобились. их скопировать, переключиться на последний коммит и вставить в нужный файл.

git branch
Переключение по коммитам отражается только на содержимом рабочей директории. 
узнать место нахождения — вызвать команду git branch. находимся на последнем коммите, Git покажет вывод:

git branch

* main

загружен коммит из прошлого:

* (HEAD detached at e6f625c)
  main

# Если на последнем коммите
hexlet-git git:(main)

# Если на коммите из прошлого
hexlet-git git:(e6f625c)

В Bash вывод местоположения редактированию переменной окружения $PS1
https://ru.hexlet.io/blog/posts/kak-prisoedinitsya-k-rabote-nad-opensorsom-chto-takoe-ps1-i-drugie-voprosy-otvechaet-razrabotchik-heksleta-andrey-moshkov#chto-takoe-ps1-i-dlya-chego-ispolzuetsya

наибольший эффект при работе с Git в команде. ситуаций, возникающих при совместной работе над кодом.

выведем коммиты проекта

git log --graph

* commit e7bb5e51f96e572084f6c04ba3312e32ce6b8c0f (HEAD -> main, origin/main, origin/HEAD)
|
|     update README.md
|
* commit 65a8ef7fd56c7356dcee35c2d05b4400f4467ca8
|
|     Revert "remove PEOPLE.md"
|
|     This reverts commit aa600a43cb164408e4ad87d216bc679d097f1a6c.

полоску слева отражает связи между коммитами. новый коммит базируется на коде предыдущего. коммиты выстраиваются в односвязный список. каждый элемент ссылается на предыдущий. Последний элемент головой списка (head).

В Git элементы списка — коммиты. Как и в односвязном списке, новый коммит — элемент, имеет ссылку на предыдущий коммит. Предыдущий коммит ссылается на свой предыдущий, и так далее до первого коммита, который никуда не ссылается.

«голова списка» (HEAD). удаление последнего коммита:

# HEAD~1: взять голову и удалить один коммит, начиная от нее
# удаляем только последний коммит
git reset --hard HEAD~1
список коммитов называется main. список - веткой (branch). команда для показа текущего местоположения в истории git branch

git branch

* main

ветка в Git — подвижный указатель на один из коммитов. При новом коммите указатель сдвигается вперед автоматически.

работа Git — формировать односвязный список из коммитов. большинство команд Git — небольшие программы, умеют ходить по этому списку и извлекать нужную информацию. блуждаем по этому списку, меняем его и добавляем новые коммиты.

Ветки
цепочка коммитов в Git это не просто односвязный список. направленный ациклический граф — множество односвязных списков, переплетенных вместе.

в один момент два разных человека должны делать какие-то длинные задачи, требующие нескольких дней разработки или даже больше. main-ветка должна оставаться рабочей: коммитить промежуточные изменения в нее нельзя, изменения могут сломать код.

отпочковаться от основного списка — сформировать ветку. создается отдельный список коммитов, идет мимо главной ветки. В конце разработки все коммиты из такой ветки вливаются обратно в main-ветку:

<img width="1280" height="720" alt="image" src="https://github.com/user-attachments/assets/fef9fefa-bbf4-45b7-a0d2-adb86c8ee613" />

# Игнорируем файл в любой директории проекта
access.log

# Игнорируем директорию в любой директории проекта
node_modules/

# Игнорируем каталог в корне рабочей директории
/coverage/

# Игнорируем все файлы с расширением sqlite3 в директории db
# При этом не игнорируются такие же файлы внутри любого вложенного каталога в db
# Например, /db/something/lala.sqlite3
/db/*.sqlite3

# Игнорировать все .txt файлы в каталоге doc/ на всех уровнях вложенности
doc/**/*.txt

добавил в репозиторий файл, который нужно проигнорировать. недостаточно обновить правила игнорирования. удалить файл или директорию из Git с помощью git rm и закоммитить.
git rm file -- cached - удалить фалй из репозитория(гит перестанет его отслеживать), файл останется в рабочей директории.


работаете над задачей и исправили довольно много файлов. появляется срочная задача — сделать изменение в исходном коде, не связанное с тем, над чем вы сейчас работаете. изменения еще не готовы, и они не должны попасть в репозиторий.

изменения не пересекаются с изменениями по срочной задаче. внести исправления, добавить их в индекс, закоммитить и запушить. изменения в тех файлах, с которыми вы работаете сейчас?

# пропадут все измененные файлы независимо, добавлены они в индекс или нет
git stash

попадают в специальное место внутри директории .git на временное хранение. Эта команда не трогает новые файлы, не являются частью репозитория:

<img width="1280" height="720" alt="image" src="https://github.com/user-attachments/assets/f7bc1d73-4a89-4984-ae77-1fb8130b0fb5" />

После выполнения всех изменений в чистой рабочей директории вернуть спрятанные изменения:

git stash pop

Стэш в Git работает по принципу стека. сохранить внутрь любое количество изменений и восстановить их в обратном порядке:

git stash

# Изменяем файлы
git stash

# Возвращаем последние изменения
git stash pop

# Возвращаем предпоследние изменения
git stash pop

Проекты с открытым исходным кодом или OpenSource (Open Source Software, OSS) — по с общедоступным кодом. пользователь может увидеть код.

К такому ПО относятся:

Прикладное ПО и сервисы, как VSCode или Git
Огромное число библиотек в нашем коде
Практически все современные языки программирования


запрос на включение изменений - pull request.
создаем копию репозитория Fork на странице репозитория
клонируем репозиторий на компьютер и производим изменения в отдельной ветке, созданной от main.

залили изменения на GitHub. На странице склонированного репозитория кнопка Pull request
После отправки пулреквеста в оригинальном репозитории на странице Pull requests отобразится ваш запрос.




склонировали репозиторий в понедельник и начали разрабатывать какую-то новую и уникальную часть приложения (на сленге разработчиков - фича). В пятницу вечером вы наконец-то готовы опубликовать вашу фичу. Но, о нет! Ваш коллега в течение недели написал кучу кода, который делает все ваши наработки устарелыми. Этот код был также закоммичен и опубликован на общедоступном удалённом репозитории, поэтому теперь ваш код базируется на устаревшей версии проекта и более не уместен.

В этом случае использование команды git push является сомнительным. Как поведёт себя команда git push, если вы её выполните? Может быть, она изменит удалённый репозиторий и вернёт всё к тому состоянию, которое было в понедельник? А может, команда попробует добавить ваш код, не удаляя при этом новый? Или же она проигнорирует ваши изменения, так как они уже устарели?

По причине того, что в данной ситуации (когда история расходится) слишком много двусмысленностей и неопределённостей, git не даст вам закачать (push) ваши изменения. Он будет принуждать вас включить в состав своей работы все те последние наработки и изменения, которые находятся на удалённом репозитории.

git push не выполнилась успешно. Дело в том, что ваш последний коммит C3 основан на удалённом коммите C1. В свою очередь, удалённый репозиторий уже изменился под воздействием C2. Вот почему git отклонил ваш push.

перебазировать свою работу на самую последнюю версию удалённой ветки.

Существует множество способов сделать это, но наиболее простой способ 'сдвинуть' свои наработки - через перебазировку или rebasing. Давайте посмотрим, как это выглядит.


сперва перебазируемся прежде чем публиковать изменения
git fetch; git rebase o/main; git push

обновили наш локальный образ удалённого репозитория средствами git fetch. Ещё мы перебазировали наши наработки, чтобы они отражали все изменения с удалённого репозитория, и опубликовали их с помощью git push.


обновить мои наработки к тому моменту, как удалённый репозиторий был обновлён? Конечно есть! Давайте ознакомимся с парочкой новых штучек, но в этот раз с помощью команды merge.

Несмотря на то, что git merge не передвигает ваши наработки (а всего лишь создаёт новый коммит, в котором Ваши и удалённые изменения объединены), этот способ помогает указать git-у на то, что вы собираетесь включить в состав ваших наработок все изменения с удалённого репозитория. Это значит, что ваш коммит отразится на всех коммитах удалённой ветки, поскольку удалённая ветка является предком вашей собственной локальной ветки.


объединим (merge) вместо перебазирования (rebase)
git fetch; git merge o/main; git push

обновили наше локальное представление удалённого репозитория с помощью git fetch, объединили ваши новые наработки с нашими наработками (чтобы отразить изменения в удалённом репозитории) и затем опубликовали их с помощью git push.


git pull, которая является аналогом и более кратким аналогом для совместных fetch и merge. А команда git pull --rebase - аналог для совместно вызванных fetch и rebase!

git pull --rebase; git push
git pull; git push

Рабочий процесс получения изменений (fetching), перебазирования/объединения (rebase/merging) и публикации изменений (pushing) используется довольно часто.




Когда вы работаете в составе большой команды разработчиков над проектом, то, вероятнее всего, ветвь main будет заблокирована. Для внесения изменений в неё в git существует понятие запроса на слияние Pull Request. В такой ситуации если вы закоммитите свои наработки непосредственно в main ветвь, а после выполните git push, то будет сгенерировано сообщение об ошибке:

! [remote rejected] main -> main (TF402455: Pushes to this branch are not permitted; you must use a pull request to update this branch.)
! [удалённо отклонено] main -> main (TF402455: Изменение этой ветви запрещены; вы можете использовать pull request для обновления этой ветви.)
отклонение моих изменений?
Удалённый репозиторий отклонил загруженные коммиты непосредственно в main ветку потому, что на main настроена политика, которая требует использование Pull request вместо обычного git push.

Эта политика подразумевает процесс создания новой ветви разработки, внесение в неё всех необходимых коммитов, загрузка изменений в удалённый репозиторий и открытие нового Pull request. Однако вы забыли про это и закоммитили наработки непосредственно в main ветвь. Теперь вы застряли и не можете запушить свои изменения :(.

Создайте ещё одну ветвь под названием feature и отправьте изменения на удалённый репозиторий. Также не забудьте вернуть вашу локальную main ветвь в исходное состояние (чтобы она была синхронизирована с удалённой). В противном случае у вас могут возникнуть проблемы при следующем выполнении git pull.



Слияние фича-бранчей (веток)
Теперь, когда вы умело владеете командами fetch, pull и push, давайте применим эти навыки в сочетании с новым рабочим процессом (он же workflow).

Среди разработчиков, вовлечённых в большой проект, довольно распространённ приём — выполнять всю свою работу в так называемых фича-бранчах (вне main). А затем, как только работа выполнена, разработчик интегрирует всё, что было им сделано. Всё это, за исключением одного шага, похоже на предыдущий урок (там, где мы закачивали ветки на удалённый репозиторий)

Ряд разработчиков делают push и pull лишь на локальную ветку main - таким образом ветка main всегда синхронизирована с тем, что находится на удалённом репозитории (o/main).

Для этого рабочего процесса мы совместили две вещи:

интеграцию фича-бранчей в main
закачку (push) и скачку (pull) с удалённого репозитория

обновить main и закачать выполненную работу.
git pull --rebase; git push
перебазировали нашу работу на новенький коммит, пришедший с удалённого репозитория, и
закачали свои наработки в удалённый репозиторий

Текущая задача является достаточно обильной - здесь представлена общая схема выполнения:

Есть три фича-бранчи (фича-ветки) - side1 side2 и side3
Нам необходимо закачать каждую из них по очереди на удалённый репозиторий
При этом удалённый репозиторий хранит в себе какие-то наработки, которые также следует скачать к себе
:O Сложно! Желаю вам удачи в выполнении этой непростой задачи.


Чтобы закачать (push) новые изменения в удалённый репозиторий, всё, что вам нужно сделать - это смешать последние изменения из удалённого репозитория. Это значит, что вы можете выполнить rebase или merge на удалённом репозитории (например, o/main).

Если мы можем воспользоваться одним из двух методов, то почему же эти упражнения сфокусированы в основном на rebase? К чему такая нелюбовь к merge, когда речь идёт о работе с удалёнными репозиториями?

В среде разработчиков существует огромное количество дебатов около merging и rebasing. Ниже приведены основные за / против метода rebasing:

За:

Rebasing делает дерево коммитов более чистым и читабельным, потому что всё представляется единой прямой линией.
Против:

Метод rebasing явно изменяет историю коммитов в дереве.
Например, коммит C1 может быть перебазирован после C3. Соответственно, в дереве работа над C1' будет отображаться как идущая после C3, хотя на самом деле она была выполнена раньше.

Некоторые разработчики любят сохранять историю и предпочитают слияние (merging). Другие (такие как я) предпочитают иметь чистое дерево коммитов, и пользуются перебазировкой (rebasing). Всё зависит от ваших предпочтений и вкусов :D

Чтобы пройти этот уровень, решите предыдущие задачи, но с помощью слияния (merging). Может быть, получится слегка неказисто, однако такое упражнение хорошо отразит суть различий.



Удалённые-отслеживаемые ветки
Единственное, что могло бы показаться вам "магией" в нескольких предыдущих уроках - это то, как git знает, что ветка main соответствует o/main. Конечно, эти ветки имеют схожие имена и связь между локальной и удалённой ветками main выглядит вполне логично, однако, эта связь наглядно продемонстрирована в двух сценариях:

Во время операции pull коммиты скачиваются в ветку o/main и затем соединяются в ветку main. Подразумеваемая цель слияния определяется исходя из этой связи.
Во время операции push наработки из ветки main закачиваются на удалённую ветку main (которая в локальном представлении выглядит как o/main). Пункт назначения операции push определяется исходя из связи между main и o/main.

Удалённые-отслеживаемые ветки
Короче, связь между main и o/main объясняется не иначе как свойство "удалённое отслеживание" веток. Ветка main настроена так, чтобы следить за o/main -- это подразумевает наличие источника для merge и пункта назначения для push в контексте ветки main.

Вы, должно быть, удивлены, как это отслеживание появилось на ветке main, если мы не запускали ни одной специфической команды. На самом деле, когда вы клонируете репозиторий, это слежение включается автоматически.

В процессе клонирования git локально создаёт удалённые ветки для каждой ветки с удалённого репозитория (такие как o/main). Затем он - git - создаёт локальные ветки, которые отслеживают текущую, активную ветку на удалённом репозитории. В большинстве случаев - это main.

К тому моменту как git clone завершит своё выполнение, у вас будет лишь одна локальная ветка (так что вы ещё не сильно перегружены), но, если вам будет интересно, вы сможете увидеть все удалённые ветки (при желании).

Именно это объясняет, почему сразу после клонирования вы видите в консоли надпись:

local branch "main" set to track remote branch "o/main" (локальная ветка "main" теперь следит за удалённой веткой "o/main")

А могу ли я сделать это самостоятельно?
Само собой! Вы можете сказать любой из веток, чтобы она отслеживала o/main, и если вы так сделаете, эта ветка будет иметь такой же пункт назначения для push и merge как и локальная ветка main. Это значит, что вы можете выполнить git push, находясь на ветке totallyNotMain, и все ваши наработки с ветки totallyNotMain будут закачены на ветку main удалённого репозитория!

Есть два способа сделать это. Первый - это выполнить checkout для новой ветки, указав удалённую ветку в качестве ссылки. Для этого необходимо выполнить команду

git checkout -b totallyNotMain o/main

, которая создаст новую ветку с именем totallyNotMain и укажет ей следить за o/main.

checkout для новой ветки foo и укажем ей, чтобы она отслеживала main с удалённого репозитория.

git checkout -b foo o/main; git pull


o/main, чтобы обновить ветку foo. Обратите внимание, как обновился main!!

git checkout -b foo o/main; git commit; git push

Мы закачали наши наработки на ветку main нашего удалённого репозитория. При том, что наша локальная ветка называется абсолютно по-другому.

Способ №2
Другой способ указать ветке отслеживать удалённую ветку — это просто использовать команду git branch -u. Выполнив команду

git branch -u o/main foo

вы укажете ветке foo следить за o/main. А если вы ещё при этом находитесь на ветке foo, то её можно не указывать:

git branch -u o/main

второй способ указать слежение за веткой намного быстрее...

git branch -u o/main foo; git commit; git push

Для выполнения этого уровня давайте выполним push наших наработок в ветку main на удалённом репозитории, при этом не скачивая и не создавая ветку main локально. Вместо этого вам следует создать ветку с именем side, которая будет показана на визуализации цели уровня.



Аргументы команды Push
Отлично! Теперь, когда вы знаете, как следить за удалёнными ветками, мы можем начать изучение того, что скрыто под занавесом работы команд git push, fetch и pull. Мы будем рассматривать одну команду за другой, однако принципы у них очень схожи.

Сперва взглянем на git push. В уроке, посвящённом слежению за удалённым репозиторием, вы узнали о том, что git находит удалённый репозиторий и ветку, в которую необходимо push-ить, благодаря свойствам текущей ветки, на которой мы находимся. Это так называемое поведение без аргументов, однако команда git push может быть также использована и с аргументами. Вид команды в данном случае:

git push <удалённый_репозиторий> <целевая_ветка>

Что за такой параметр <целевая_ветка>? Мы узнаем об этом через секунду, а пока что рассмотрим пример. Допустим, что мы выполняем такую команду:

git push origin main

дословный перевод с английского будет таким:

Перейди в ветку с именем "main" в моём локальном репозитории, возьми все коммиты и затем перейди на ветку "main" на удалённом репозитории "origin.". На эту удалённую ветку скопируй все отсутствующие коммиты, которые есть у меня, и скажи, когда ты закончишь.

Указывая main в качестве аргумента "целевая_ветка", мы тем самым говорим git-у, откуда будут приходить и куда будут уходить наши коммиты. Аргумент "целевая_ветка" или "местонахождение" - это синхронизация между двумя репозиториями.

Имейте в виду, что с тех пор, как мы сказали git-у всё, что ему необходимо (указав оба аргумента), ему - git-у - абсолютно всё равно, что вы зачекаутили до этого!

git checkout c0; git push origin main

обновили main на удалённом репозитории, принудительно указав аргументы в push.

А что бы было, если бы мы не указывали эти аргументы, при этом используя тот же алгоритм?

git checkout c0; git push

команда не выполнилась, так как HEAD потерялся и не находится на удалённо-отслеживаемой ветке.

Хорошо, для выполнения этого уровня давайте обновим обе ветки foo и main на удалённом репозитории. Фишка в том, что команда git checkout не доступна на этом уровне!

Замечание: Удалённые ветки помечены как o/, а не origin/. Дело в том, что полная метка не помещается на экране. Не волнуйтесь по этому поводу... просто используйте знакомый нам origin для обращения к удалённому репозиторию.



Подробности аргумента <пункт назначения>
Помните, когда в прошлом занятии мы указали в качестве аргумента ветку main для команды git push, мы указали совместно источник, откуда будут приходить коммиты, и пункт назначения (получатель), куда коммиты будут уходить.

Однако, вы, наверное, задаётесь вопросом - а что, если я хочу, чтобы мои источник и получатель коммитов были различными? Что, если мы хотим запушить коммиты из локальной ветки foo в ветку bar на удалённом репозитории?

К огромному сожалению, это невозможно сделать средствами git... Да ладно! Я пошутил! Конечно, это возможно :)... git сам по себе достаточно гибок (даже слишком).


разделить источник и получатель аргумента <пункт назначения>, соедините их вместе, используя двоеточие:

git push origin <источник>:<получатель>

Обычно это называется refspec. Refspec — это всего лишь модное имя для определения местоположения, которое git может распознать (например, ветка foo или просто HEAD~1)

Как только вы указали источник и получатель независимо друг от друга, вы можете довольно причудливо и точно использовать команды для работы с удалёнными ветками и репозиториями. Давайте взглянем на демонстрацию!

Помните, источник - всего лишь местоположение, которое git должен понять:

git push origin foo^: main

git видит в foo^ не что иное, как местоположение, закачивает все коммиты, которые не присутствуют на удалённом репозитории, и затем обновляет получателя

А что если пункт назначения, в который вы хотите запушить, не существует? Без проблем! Укажите имя ветки, и git сам создаст ветку на удалённом репозитории для вас.

git push origin main:newBranch


 Выбери уровень
Основы
Удаленные репозитории
Push & Pull - удалённые репозитории в Git!
Настало время поделиться своими единичками и нулями. Время коллективного программирования

8: Заблокированная ветвь main

1
2
3
4
5
6
7
8
Через origin – к звёздам. Продвинутое использование Git Remotes
Весело было быть всесильным мудрым правителем...

5: Аргументы для push -- расширенная версия!

1
2
3
4
5
6
7
8
Подробности аргумента <пункт назначения>
Помните, когда в прошлом занятии мы указали в качестве аргумента ветку main для команды git push, мы указали совместно источник, откуда будут приходить коммиты, и пункт назначения (получатель), куда коммиты будут уходить.

Однако, вы, наверное, задаётесь вопросом - а что, если я хочу, чтобы мои источник и получатель коммитов были различными? Что, если мы хотим запушить коммиты из локальной ветки foo в ветку bar на удалённом репозитории?

К огромному сожалению, это невозможно сделать средствами git... Да ладно! Я пошутил! Конечно, это возможно :)... git сам по себе достаточно гибок (даже слишком).

Мы увидим, как именно, на следующем слайде...

Close
Next
В том случае, когда вам необходимо разделить источник и получатель аргумента <пункт назначения>, соедините их вместе, используя двоеточие:

git push origin <источник>:<получатель>

Обычно это называется refspec. Refspec — это всего лишь модное имя для определения местоположения, которое git может распознать (например, ветка foo или просто HEAD~1)

Как только вы указали источник и получатель независимо друг от друга, вы можете довольно причудливо и точно использовать команды для работы с удалёнными ветками и репозиториями. Давайте взглянем на демонстрацию!

Previous
Next
 Git демо

Помните, источник - всего лишь местоположение, которое git должен понять:



Вау! Это довольно нетривиальная команда, однако она имеет смысл - git видит в foo^ не что иное, как местоположение, закачивает все коммиты, которые не присутствуют на удалённом репозитории, и затем обновляет получателя.

Previous
Next
 Git демо

А что если пункт назначения, в который вы хотите запушить, не существует? Без проблем! Укажите имя ветки, и git сам создаст ветку на удалённом репозитории для вас.

Для выполнения данного уровня попытайтесь привести своё дерево к такому же виду, как на визуализации. И не забудьте о формате:

<источник>:<получатель>



Аргументы git fetch
Итак, мы только что изучили всё, что касается аргументов git push, мы узнали о параметре <пункт назначения>, и даже об аргументе, задающем отдельно источник и получатель коммитов (<источник>:<получатель>). Можем ли мы применить все эти полученные знания для команды git fetch ?

Ещё бы! Аргументы для команды git fetch на самом деле очень, очень похожи на те, что мы использовали в git push. В данном случае применяется тот же подход, только в противоположном направлении (так как теперь вы скачиваете коммиты, а не закачиваете их).

Параметр <пункт назначения>
Если вы указываете пункт назначения в команде git fetch, например так, как в следующем примере:

git fetch origin foo

Git отправится в ветку foo на удалённом репозитории, соберёт с собой все коммиты, которые не присутствуют локально, и затем поместит их в локальную ветку под названием o/foo.

Указывая пункт назначения...

git fetch origin foo

мы скачиваем только коммиты с ветки foo и помещаем их в o/foo.

зачем git поместил эти коммиты в ветку o/foo вместо того, чтобы разместить их в локальной ветке foo ? Ведь я думал о параметре <пункт назначения>, как о месте, ветке, которая существует в обоих - локальном и удалённом репозитории. Верно?

На самом деле, в данном случае git делает исключение, потому что вы, возможно, работаете над веткой foo, которую не хотите привести в беспорядок!! Об этом упоминалось в ранних уроках по git fetch - эта команда не обновляет ваши локальные 'не удалённые', она лишь скачивает коммиты (соответственно, вы можете инспектировать / объединять их позже).

"Что же тогда произойдёт, если я явно укажу оба параметра: и источник и получатель, пользуясь синтаксисом <источник>:<получатель> ?"

Если вы уверены в том, что хотите закачать коммиты прямиком в вашу локальную ветку, тогда да, вы можете явно указать источник и получатель через двоеточние. Вы можете воспользоваться таким приёмом лишь для ветки, на которой вы не находитесь в настоящий момент checkout.

Теперь у нас <источник> - это место на удалённом репозитории, а <получатель> - место в локальном репозитории, в который следует помещать коммиты. Аргументы в точности до наоборот повторяют git push, и немудрено, ведь теперь мы переносим данные в обратном направлении!

Как уже было сказано, разработчики редко используют такой подход на практике. Целью демонстрации этой возможности было показать, насколько схожи концептуально fetch и push. Их отличие лишь в направлении переноса данных.

git fetch origin C2:bar

git распознал C2 как место в origin и затем скачал эти коммиты в bar, которая является локальной веткой.

ветка-получатель не существует на момент запуска команды? Давайте ещё раз взглянем на предыдущий слайд, но на этот раз ветки bar ещё не существует.

git fetch origin C2:bar

поведение совсем такое же, как и у git push. Git создал ветку-получатель локально прежде чем скачивать данные. Всё как и в случае, когда git создаёт получателя в удалённом репозитории, когда мы закачиваем изменения (если получатель не существует).

А если вообще без аргументов ?

Если команда git fetch выполняется без аргументов, она скачивает все-все коммиты с удалённого репозитория и помещает их в соответствующие удалённо-локальные ветки в локальном репозитории...

git fetch

Ладно, достаточно болтовни! Чтобы выполнить этот уровень, скачайте лишь определённые коммиты так, как представлено в визуализации цели. Пофантазируйте с этими командами!

Вам следует явно указывать источник и получателя для обеих команд fetch. Обратите внимание на визуализацию цели, так как ID-шники могут меняться!


Странный <источник>
Git использует параметр <источник> странным образом. Странность заключается в том, что Вы можете оставить пустым параметр <источник> для команд git push и git fetch:

git push origin :side
git fetch origin :bugFix
Посмотрим, что же из этого выйдет...

Что же будет с веткой, на которую мы делаем git push с пустым аргументом <источник>? Она будет удалена!

git push origin :foo

удалили ветку foo в удаленном репозитории, попытавшить протолкнуть(git push) в неё "ничего".

притянуть изменения(git fetch) из "ничего" к нам в локальный репозиторий, то это создаст у нас новую ветку

git fetch origin :bar

Это легкое упражнение - нужно всего лишь удалить одну ветку в удаленном репозитории и создать новую ветку в локальном, с помощью команд git push и git fetch соответственно!


Аргументы для pull
Аргументы для git pull не покажутся вам чем-то новым, учитывая, что вы уже знакомы с аргументами для git fetch и git push :)

Как мы помним, git pull сначала выполняет git fetch, а следом сразу git merge с той веткой, в которую притянулись обновления командой fetch. Другими словами, это все равно, что выполнить git fetch с теми же аргументами, которые вы указали для pull, а затем выполнить git merge с веткой, указанной в аргументе <приемник> команды pull.

Вот примеры абсолютно эквивалентных команд в git:

git pull origin foo это то же самое, что сделать:

git fetch origin foo; git merge o/foo

И еще...

git pull origin bar:bugFix то же, что:

git fetch origin bar:bugFix; git merge bugFix

Как видно, git pull используется, чтобы за одну команду выполнить fetch + merge.

сначала выполнится fetch с аргументом указанным к pull, а merge выполняется с теми изменениями, которые будут скачаны командой fetch.

git pull origin main

указали main, поэтому как обычно все обновления притянулись на ветку o/main. Затем мы слили (merge) обновленную ветку o/main с веткой, на которой мы находимся.

указать <источник> и <приемник>? 

git pull origin main:foo

Мы создали новую ветку foo в локальном репозитории, скачали на неё изменения с ветки main удаленного репозитория, а затем слили эту ветку с веткой bar, на которой мы находились!

привести дерево к аналогичному в примере. Нужно скачать несколько изменений, создать несколько новых веток, слить одни ветки в другие, но постарайтесь использовать как можно меньше команд.
