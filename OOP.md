Если поле — изменяемый объект (список), не возвращайте его напрямую через геттер. вернуть копию или сделать его неизменяемым.

private String[] phones;
Не стоит возвращать его напрямую через геттер:

public String[] getPhones() {
    return phones; // Плохо!
}
внешнему коду менять список обходя все проверки — нарушая инкапсуляцию!


public String[] getPhones() {
    return Arrays.copyOf(phones, phones.length); // Возвращаем копию
}

public String[] getPhones() {
    return phones.clone();
}


public class Config {
    public static String configPath;

    static {
        // блок выполнится ОДИН раз при загрузке класса
        configPath = System.getenv("APP_CONFIG_PATH");
        if (configPath == null) {
            configPath = "/etc/app/default.conf";
        }
        System.out.println("Config path инициализирован: " + configPath);
    }
}


Статический блок При первом обращении к классу (например, при создании первого объекта или вызове любого статического метода/поля). для инициализации «тяжёлых» или сложных статических полей, чтения конфигурации из файла, создания коллекций, подключения к базе

public class Settings {
    public static final java.util.Map<String, String> DEFAULTS;

    static {
        DEFAULTS = new java.util.HashMap<>();
        DEFAULTS.put("theme", "light");
        DEFAULTS.put("language", "ru");
        System.out.println("Статический блок Settings: настройки по умолчанию");
    }
}

public static final String[] USERS = new String[100]; // плохо!
ссылка USERS не изменится, содержимое массива можно менять - к неожиданным ошибкам, нарушает инкапсуляцию.


static методы вообще не переопределяются (только скрываются).

Наследование — инструмент для отношений «is-a». «Кошка — это Животное», используйте наследование. «Кошка содержит Хвост», используйте композицию (has-a).

Плохо:

class Engine { /* ... */ }
class Car extends Engine { /* Машина — это двигатель? Нет, это композиция! */ }
Хорошо:

class Car {
    Engine engine; // Машина содержит двигатель
}

Если подкласс не может быть использован вместо родителя без сюрпризов — иерархия построена неверно. Возвращаемый тип - Должен совпадать или быть подтипом

Наследование без логики «is-a». Если вы используете наследование только ради доступа к методам или полям, а не потому, что подкласс действительно «является» родителем, ваш код быстро превратится в кашу. Например, «Машина наследует Двигатель» — это не is-a, а has-a.

Игнорирование уникальных особенностей подкласса.

Дублирование кода в подклассах. Если вы копируете одну и ту же реализацию в несколько подклассов, стоит вынести её в родительский класс.

Полиморфизм - один интерфейс — много реализаций. способность объектов разных классов реагировать на одинаковые сообщения (вызовы методов) по-разному.

Исполнительный (динамический) полиморфизм — переопределение методов (overriding)
метод определяется в базовом классе, переопределяется в подклассах. Какой метод вызван — решается во время выполнения программы, в зависимости от фактического типа объекта.
метод makeSound(), вызвать его у любого животного, но кошка замяукает, собака залает, а корова замычит.

Animal animal1 = new Dog();
Animal animal2 = new Cat();

animal1.makeSound(); // Гав!
animal2.makeSound(); // Мяу!

переменные тип Animal, результат вызова зависит от фактического типа объекта.

Компиляторный (статический) полиморфизм — перегрузка методов (overloading)
в одном классе есть несколько методов с одинаковым именем, но разными параметрами. Компилятор сам решает, какой метод вызвать, исходя из переданных аргументов.

class Printer {
    void print(int x) {
        System.out.println("Число: " + x);
    }

    void print(String s) {
        System.out.println("Строка: " + s);
    }
}

строить сложные системы, где отдельные части взаимодействуют друг с другом через абстракции (базовые классы или интерфейсы), не заботясь о конкретных реализациях.

Animal animal = new Dog();, переменная animal имеет ссылочный тип Animal, компилятор «думает», что это животное, и разрешает только те методы, которые объявлены в классе Animal.
в памяти лежит объект типа Dog (Фактический тип). он определяет, какой метод будет вызван при обращении к makeSound().

Позднее (динамическое) связывание
во время выполнения: вызываете метод через ссылку базового типа, JVM смотрит на фактический тип объекта и вызывает «правильную» реализацию - полиморфизм в действии.

через полиморфизм доступны только методы, объявленные в базовом классе.

проектировать базовый класс так, чтобы в нём были только те методы, которые действительно нужны всем наследникам.

принципа открытости/закрытости. Если для добавления нового типа сотрудника приходится менять код, который перебирает массив/список — не используете полиморфизм должным образом.

Абстрактный класс — класс, не может быть создан напрямую, но от которого можно наследоваться. содержать как обычные (реализованные) методы, абстрактные — объявленные, но не реализованные.

процесс выделения общих характеристик и поведения группы объектов, при этом частные детали (например, как именно что-то работает «под капотом») игнорируются.
создание таких классов и интерфейсов, которые отражают только важные для задачи свойства и действия, скрывая ненужные детали.


Абстрактный класс — у объектов есть общее состояние (например, поля), общая логика (методы с реализацией), дать «скелет» поведения с возможностью доработки.
Интерфейс — задать только набор методов (контракт), без реализации и состояния. С Java 8 интерфейсы получили default/static-методы, но всё равно интерфейс — про «что должен уметь объект», а не «как он это делает».
«Птица» — абстрактный класс: у всех птиц есть клюв, крылья, и они могут летать (но по-разному).
«Летающий» — интерфейс: не только птицы умеют летать, но и самолёты, и супергерои! Летают все по-разному, но главное — они это умеют.

делать абстракцию «шире», если это уменьшит дублирование.

принцип «от общего к частному».
Иногда начинающие программисты начинают строить иерархию «от деталей», забывая об общем. В результате появляются странные классы вроде RedCircleWithShadow, которые плохо вписываются в общую структуру. 
Всегда сначала выделяйте абстракцию, а потом детали.
видишь как пользователь твоего кода будет работать с ним вызывать его методы - верхний интерфейс. потом углубляешься в детали.

Абстрактный класс — общее состояние и/или частичная реализация. Интерфейс — когда нужно только «пообещать» наличие методов, но не хранить данные и не реализовывать поведение.
