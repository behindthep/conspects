Инкапсуляция — спрятать внутренности объекта (private) и дать доступ к ним только через публичные методы (интерфейс) — наружу «выставляются» только те данные и методы, которые действительно нужны пользователю объекта.
Легко менять внутренности класса — если понадобится хранить телефон как объект типа PhoneNumber, а не как строку, вы просто меняете реализацию, а внешний код не трогаете.

Если поле — изменяемый объект (список), не возвращайте его напрямую через геттер. Лучше вернуть копию или сделать его неизменяемым.
Не раскрывайте внутренние изменяемые объекты напрямую
Если у вас есть поле — например, список телефонов:

private String[] phones;
Не стоит возвращать его напрямую через геттер:

public String[] getPhones() {
    return phones; // Плохо!
}
Такой код позволяет внешнему коду менять список как угодно, обходя все проверки — нарушая инкапсуляцию!

Правильнее: возвращать копию массива:

public String[] getPhones() {
    return Arrays.copyOf(phones, phones.length); // Возвращаем копию
}

public String[] getPhones() {
    return phones.clone();
}


public class Config {
    public static String configPath;

    static {
        // блок выполнится ОДИН раз при загрузке класса
        configPath = System.getenv("APP_CONFIG_PATH");
        if (configPath == null) {
            configPath = "/etc/app/default.conf";
        }
        System.out.println("Config path инициализирован: " + configPath);
    }
}

В статическом блоке нельзя обращаться к нестатическим полям, потому что они ещё не инициализированы
Когда вызывается статический блок?
При первом обращении к классу (например, при создании первого объекта или вызове любого статического метода/поля).
Выполняется только один раз для каждого класса.


Статический блок для инициализации «тяжёлых» или сложных статических полей, чтения конфигурации из файла, создания коллекций, подключения к базе

public class Settings {
    public static final java.util.Map<String, String> DEFAULTS;

    static {
        DEFAULTS = new java.util.HashMap<>();
        DEFAULTS.put("theme", "light");
        DEFAULTS.put("language", "ru");
        System.out.println("Статический блок Settings: настройки по умолчанию");
    }
}


Если значение может измениться в будущем (список сотрудников), не делайте его final! Константы должны быть по-настоящему неизменяемыми.

public static final int MAX_USERS = 1000; // хорошо
public static final String[] USERS = new String[100]; // плохо!

ссылка USERS не изменится, содержимое массива можно менять - к неожиданным ошибкам, нарушает инкапсуляцию.


Статические поля — глобальные переменные. Их слишком большое количество к трудноуловимым ошибкам и сложной поддержке кода.

статические части (static) выполняются только один раз — при первом обращении к классу. Всё, что не static, — каждый раз при создании объекта


Полиморфизм
Animal animal = new Dog();
animal.makeSound(); // "Woof!", а не "Some generic animal sound"
переменная типа Animal, но в ней лежит объект Dog. вызвать переопределённый метод из Dog.

переопределённый метод возвращал более «узкий» тип (например подтип базового класса) - ковариантность возвращаемого типа.

 final защищает от переопределения, а static методы вообще не переопределяются (только скрываются).

 
Наследование — инструмент для отношений «is-a». Если вы хотите сказать «Кошка — это Животное», используйте наследование. Если же «Кошка содержит Хвост», используйте композицию (has-a).

Плохо:

class Engine { /* ... */ }
class Car extends Engine { /* Машина — это двигатель? Нет, это композиция! */ }
Хорошо:

class Car {
    Engine engine; // Машина содержит двигатель
}


принципа подстановки Лисков. Если подкласс не может быть использован вместо родителя без сюрпризов — иерархия построена неверно. Возвращаемый тип - Должен совпадать или быть подтипом

Дублирование кода. Если вы ловите себя на мысли «ой, а этот метод копируется из класса в класс», возможно, пора вынести его в базовый класс.


Наследование без логики «is-a». Если вы используете наследование только ради доступа к методам или полям, а не потому, что подкласс действительно «является» родителем, ваш код быстро превратится в кашу. Например, «Машина наследует Двигатель» — это не is-a, а has-a.

Игнорирование уникальных особенностей подкласса. Если все ваши подклассы выглядят одинаково и не добавляют ничего нового, возможно, иерархия не нужна — используйте один класс.

Дублирование кода в подклассах. Если вы копируете одну и ту же реализацию в несколько подклассов, стоит вынести её в родительский класс.



Полиморфизм - один интерфейс — много реализаций. способность объектов разных классов реагировать на одинаковые сообщения (вызовы методов) по-разному.

Исполнительный (динамический) полиморфизм — переопределение методов (overriding)
метод определяется в базовом классе, переопределяется в подклассах. Какой метод вызван — решается во время выполнения программы, в зависимости от фактического типа объекта.
метод makeSound(), вызвать его у любого животного, но кошка замяукает, собака залает, а корова замычит.

Animal animal1 = new Dog();
Animal animal2 = new Cat();

animal1.makeSound(); // Гав!
animal2.makeSound(); // Мяу!

переменные тип Animal, результат вызова зависит от фактического типа объекта.


Компиляторный (статический) полиморфизм — перегрузка методов (overloading)
в одном классе есть несколько методов с одинаковым именем, но разными параметрами. Компилятор сам решает, какой метод вызвать, исходя из переданных аргументов.

class Printer {
    void print(int x) {
        System.out.println("Число: " + x);
    }

    void print(String s) {
        System.out.println("Строка: " + s);
    }
}

строить сложные системы, где отдельные части взаимодействуют друг с другом через абстракции (базовые классы или интерфейсы), не заботясь о конкретных реализациях.

Animal animal = new Dog();, переменная animal имеет ссылочный тип Animal, компилятор «думает», что это животное, и разрешает только те методы, которые объявлены в классе Animal.
в памяти лежит объект типа Dog (Фактический тип). он определяет, какой метод будет вызван при обращении к makeSound().

Позднее (динамическое) связывание
во время выполнения: вызываете метод через ссылку базового типа, JVM смотрит на фактический тип объекта и вызывает «правильную» реализацию - полиморфизм в действии.

через полиморфизм доступны только методы, объявленные в базовом классе.

проектировать базовый класс так, чтобы в нём были только те методы, которые действительно нужны всем наследникам.

принципа открытости/закрытости. Если для добавления нового типа сотрудника приходится менять код, который перебирает массив/список — не используете полиморфизм должным образом.



Абстрактный класс — класс, не может быть создан напрямую, но от которого можно наследоваться. содержать как обычные (реализованные) методы, абстрактные — объявленные, но не реализованные.

Абстрактный метод — метод без тела. должен быть реализован в подклассах (если только подкласс сам не абстрактный).


абстракция — это искусство смотреть на сложные вещи просто.
процесс выделения общих характеристик и поведения группы объектов, при этом частные детали (например, как именно что-то работает «под капотом») игнорируются.
создание таких классов и интерфейсов, которые отражают только важные для задачи свойства и действия, скрывая ненужные детали.


