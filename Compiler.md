### JDK
Java Development Kit — швейцарский нож. всё, что нужно для создания, компиляции и запуска программ:
    - JRE и инструменты для разработчиков.
    - JRE содержит JVM и набор стандартных Java-библиотек.
    - JVM.

Использовать актуальную версию JDK (Java 25). Новые версии приносят фишки, повышают безопасность, производительность, совместимость с библиотеками. 

### Проект
- Исходники в src (source) — место для Java-файлов.
- .idea - служебная папка. настройки специфичные для проекта. не изменять вручную и добавить в .gitigonre.
- External Libraries - не реальная папка, а виртуальное представление внешних библиотек, подключенных к проекту. там главная библиотека — JDK.
- out - скомпилированные .class файлы — байт-код, который исполняет JVM.
- resources - для ресурсов (картинки, txt). добавить папку ПКМ по папке: Mark Directory as → Resources Root.

Build system: система сборки — инструмент, автоматизирует процесс компиляции кода, управления зависимостями и создания готового приложения:
- IntelliJ: встроенная система сборки IDEA.
- **Maven/Gradle**: независимые системы сборки.

Add sample code: структура проекта.


Команда запуска - IntelliJ IDEA сформировала и передала ОС для запуска программы. вызов исполняемого файла java.exe из JDK - запускает JVM. 

exit code 0 - программа завершилась без ошибок.
другой код - в процессе выполнения произошла ошибка.

нажимаете Run:
IDEA компилирует код — превращает .java в .class (байт-код для JVM).
Запускается JVM — начинает выполнение программы с метода main.


Импорт статических методы 
import static java.lang.Math.*;
Не указывать имя класса при вызове статического метода 
double result = sqrt(16);

Каждый класс в Java обязательно в пакете.
Папки совпадать с именем пакета.
Каждый public-класс в отдельном файле. Имена файлов и классов совпадать.
ПКМ по src. New → Package. com.javarush.lesson05. 
ПКМ по папке com.javarush.lesson05 и New → Java Class.

import - использовать класс без обращения по полному имени. не загружает классы в память. говорит компилятору, откуда брать класс.


## Classpath Непонятно

Classpath — "маршрут", по которому Java ищет классы при запуске. папки где искать .class-файлы (скомпилированные версии .java).

IDE добавляет src (или папку скомпилированных классов, out/production/ProjectName) в classpath. 
класс в пакете com.javarush.lesson05, Java искать его по пути: out/production/ProjectName/com/javarush/lesson05/Main.class

запускаете программу через IDE, подставляет classpath.
запускаете программу из командной строки, явно указать classpath -cp или -classpath.
классы из проекта и библиотек в папках, которые указаны в classpath.

Java-код может обращаться к файлам через classpath.

файлы текстовые вне папки resources и не пометили папку как Resources Root, программа не сможет их найти через classpath.



Процессор — обрабатывает информацию, выполняет команды пользователя и следит за работой всех подключенных устройств. процессор может разобрать только машинный код — набор 0 и 1, записаны в определённом порядке.

В процессор поступают электрические сигналы. Сильный сигнал 1, а слабый — 0. Набор таких цифр обозначает какую-то команду. Процессор ее распознает и выполняет.

Программы для первых компьютеров выглядели как огромные наборы 0 и 1.

чтобы процессор понимал, какие команды записаны в программе, программисты создали компилятор — программу, которая преобразует программный код в машинный.

Преобразование программного кода в машинный= компиляцией. Компиляция только преобразует код. не запускает его на исполнение. он "статически" (без запуска) транслируется в машинный код. текст программы разбирается на части и анализируется, а затем генерируется код, понятный процессору.

Разбор -> Анализ -> Генерация

этапы компиляции на примере вычисления периметра прямоугольника:

#include <iostream>

int main()
{
    double a=2.5, b=5, P;
    P = 2 * (a + b);
    printf("Width of the rectangle - %4.1f", a);// => Width of the rectangle - 2.5
    printf("\nLength of the rectangle - %4.1f", b);// => Length of the rectangle - 5.0
    printf("\nPerimeter of the rectangle is %4.1f", P);// => Perimeter of the rectangle is 15.0
    return 0;
}

После запуска программы компилятору определить, какие команды в ней записаны. компилятор разделяет программу на слова и знаки — токены, и записывает их в список. процесс - лексическим анализом. задача — получить токены.
Затем компилятор читает список и ищет токен-операторы. оператор присваивания(=), арифметические операторы(+,-,*,/), оператор вывода(printf()) и другие. операторы работают с числами, текстом и переменными.
Компилятор понять, какие токены в списке связаны с токен-оператором. для каждого оператора строится структура — логическое дерево.

операция P = 2*(a + b) преобразована в логическое дерево:

<img width="673" height="770" alt="image" src="https://github.com/user-attachments/assets/92961687-7c69-4f5c-9dd4-8c2e24920661" />

каждое дерево разобрать на команды, и каждую команду преобразовать в машинный код. Компилятор читать дерево снизу вверх и составляет список команд:
Взять переменную a, взять переменную b, сложить их
Взять результат сложения, взять число 2 и найти их произведение
Результат произведения присвоить (записать) в переменную P
Компилятор еще раз проверяет команды, находит ошибки и старается улучшить код. компилятор переводит команду в набор 0 и 1. Наборы записываются в файл, который сможет прочитать и выполнить процессор.

10111011 00010001 00000001 10111001

программу с набором исполняемых команд, которая могла компилировать другие программы на Fortran, и улучшенную версию себя.

<img width="1103" height="932" alt="image" src="https://github.com/user-attachments/assets/583c5cc0-b92f-473e-a51a-eedb0cb49d82" />

Ни один компилируемый яп не обходится без компилятора. компиляторы работают с несколькими яп.

процессоры отличаются друг от друга устройством, машинный код для одного процессора понятен, а для другого нет. ос: одна и та же программа работать на Windows, но не запустится на Linux или MacOS. пользоваться компилятором, работает с нужным процессором и ос.

Если программа работать на нескольких оc, кросс-компилятор — преобразует универсальный машинный код. GNU Compiler Collection(GCC) поддерживает C++ Java, Go и разную архитектуру процессоров.

Когда компилятор анализирует текст программы, он проверяет, соответствует ли запись оператора стандартам языка. Если найдено несоответствие, то компилятор выводит об этом информацию пользователю в виде ошибки. вся программа разобрана, пользователь видит список ошибок, которые есть в коде, и может их исправить. Пока программист не исправит ошибки, компилятор не перейдет к след этапу — генерации машинного кода для процессора. компилятор показывает пользователю:
ошибки объявления переменных или отсутствие их начальных значений
ошибки несоответствия типов
ошибки неправильной записи операторов и функций

Иногда компилятор определяет код, который при выполнении дает неправильный результат. Но преобразовать такую программу в машинный код все-таки можно. компилятор показывает пользователю предупреждение.
Компилятор — переводчик между программистом и процессором. преобразует текст программы в машинный код, определяет ряд ошибок в программе и оптимизирует ее работу.
Компилятор - программа, выполняет преобразование текста программы в машинный код, без его запуска, статически. затем запускает программу на выполнение. Интерпретатор сразу запускает код и выполняет его в процессе чтения. Промежуточного этапа как в компиляции нет.


преимущество Java над другими языками — мультиплатформенность.
компьютер умеет исполнять только простейшие команды.
У компьютера роль таких команд выполняют числа: команда закодирована некоторым числом (машинным кодом).

Писать программу в виде чисел сложно, придумали яп и компиляторы. язык, понятен человеку, с другой — компилятору. Компилятор —  программа, переводит текст программы, на яп, в набор машинных кодов.
программист пишет программу на яп, а затем запускает компилятор, который на основе написанных программистом файлов с кодом программы делает один файл с машинным кодом — окончательную (скомпилированную) программу.

Программа на C++ -> Компилятор -> Программа, состоящая из машинных кодов
Этапы компиляции для языка C++

Получившаяся программа выполняться на компьютере. код полученной программы зависит от процессора и ос. Программа, скомпилированная под Windows, не работать на телефоне с Android.

Программа на Java -> Java‑компилятор -> Программа из специальных кодов (байт‑код) -> Java VM -> Программа из машинных кодов
Этапы компиляции для языка Java

Компилятор Java не компилирует все классы в одну программу из машинных кодов. Вместо этого он компилирует каждый класс по отдельности, и не в машинные коды, а в специальный промежуточный код (байт-код). Компиляция в машинный код выполняется при запуске программы.

компилирует программу в машинный код при ее запуске?

программа JVM - Сначала запускают ее, а затем — программу, состоящую из байт-кода. JVM перед выполнением нужной программы компилирует ее в машинный код.

Если у вас крутой процессор, поддерживает больший набор машинных команд, во время "второй компиляции" сгенерируется машинный код с учетом вашего процессора и ОС. Java иногда быстрее С++, который сразу компилируется в машинный код и может использовать только самые распространение команды процессора.



набор инструкций, язык который понимает процессор
x86 процессоры используют сложный набор инструкций CISC - Complex Instruction Set Computing.
ARM процессоры используют упрощенный набор инструкций — RISC - Reduced Instruction Set Computing.

на каком языке говорят процессоры, как они проектируются. как для выполнения каждой инструкции на процессоре расположить свой логический блок. разные инструкции — разный дизайн процессора. дизайн — микроархитектура.
программисты работали с машинным кодом, писали нолики и единички. потом Assembler Низкоуровневый яп, писать простые команды типа сложить, скопировать. “за ручку” поэтапно описывать процессору каждое его действие.

Эй процессор, посмотри в центр стола.
Видишь соль? Возьми её.
Теперь посмотри на меня.
Отдай мне соль. — Ага, спасибо!
А теперь снова возьми у меня соль.
Поставь её откуда взял
Спасибо большое! Продолжай свои дела.

не написать инструкцию «Передай мне соль»? Набор комплексных инструкций CISC.
часть мебели, а точнее исполнительных блоков, не использоваться. Но многие из них там остаются. появился RISC…
бонус сокращенного набора RISC: меньше места на чипе занимает блок по декодированию команд.


Компьютеры научились работать с текстом благодаря появлению кодировок. Кодировки прошли путь от таблиц символов, созданных отдельно для каждого компьютера, до единой кодировки, принятой во всём мире.
Unicode — стандарт кодирования символов, включающий знаки всех письменных языков мира. Unicode применяется везде, где есть текст.

Число из десятичной системы счисления переводится в двоичную. Полученный набор нулей и единиц хранится в ячейках памяти компьютера. наличие тока на элементе памяти единицу, отсутствие — ноль.

<img width="2001" height="1125" alt="image" src="https://github.com/user-attachments/assets/ca8b734e-d0af-483a-83e6-d003ead61f6a" />

Компьютеры создавались для работы с числами, они не могут хранить символы. При вводе информации в компьютер символы преобразуются в числа и хранятся в памяти компьютера как числа, а при выводе информации обратное преобразование из чисел в символы.

Правила преобразования символов и чисел хранились в виде таблицы символов (charset). В соответствии с таблицей для каждого компьютера конструировали и своё уникальное устройство ввода/вывода информации (клавиатура и принтер).

<img width="2000" height="1125" alt="image" src="https://github.com/user-attachments/assets/8365db44-1184-45fb-8db0-18b21a9210fe" />

Для каждой задачи формировалась таблица символов, и проектировались устройства ввода/вывода информации.
результаты вычислений одних компьютеров можно было использовать на других компьютерах сети, они должны были обладать одинаковыми таблицами символов.

Модульность систем привела к появлению новой отрасли — производству совместимых с System/360 вычислительных модулей. У компаний не было необходимости производить компьютер целиком, они могли выходить на рынок с отдельными совместимыми модулями.

ASCII как первый стандарт кодирования информации
Телетайп — система передачи текстовой информации на расстоянии. Два принтера и две клавиатуры попарно соединялись друг с другом проводами.

Телетайпы преобразуют текстовую информацию в сигналы, которые передаются по проводам. Для телетайпов таблицы символов, соответствие в которых строится между символами и сигналами в проводах. для каждого телетайпа (пары соединённых телетайпов) таблицы символов могли быть свои, исходя из задач, которые они решали. Отличаться, мог язык, набор символов, который отправлялся с помощью устройства. Для оптимизации работы телетайпа самые популярные символы кодировались наиболее коротким набором сигналов, в рамках одного языка, набор символов мог быть разным.

На основе телетайпов разработали терминалы доступа к компьютерам. телетайп отправлял сообщения не второму пользователю, а информация вводилась на удалённый компьютер, после обработки команд, возвращал результат в виде ответного сообщения. вычислительные мощности компьютеров, не имея физического доступа к компьютеру.

единого стандарта кодирования для передачи и хранения информации. Таблицу из 128 символов ASCII — American standard code for information interchange (Американский стандарт кодов для обмена информацией).

Первые 32 символа в ASCII являются управляющими. управлять печатающим устройством телетайпа и получать некоторые составные символы.

символ Ø можно было получить так: печатаем O, затем с помощью управляющего кода BS (BackSpace) передвигаем печатную головку на один символ назад и печатаем символ /,
символ à получался как a BS `
символ Ç получался как C BS ,
Введение управляющих символов получать новые символы как комбинацию сущ, не вводя доп таблицы символов.

введение стандарта ASCII решило вопрос только в англоговорящих странах.

Переход к Unicode
Развитие интернета, увеличение количества компьютеров и удешевление памяти привели к тому, что проблемы, которые доставляла путаница в кодировках, стали перевешивать некоторую экономию памяти. текст написанный на одном компьютере должен был корректно отображаться на многих других устройствах.

общей таблицы символов, названной Unicode. 7161 различный символ из 24 письменностей мира.

В Unicode добавлялись новые языки и символы.

Кодировки на основе Unicode
Unicode - таблицу символов. В памяти компьютера записываются не символы, а номера из таблицы. на основе Unicode разработаны несколько кодировок, отличаются способом записи номера символа Unicode в виде набора байт. UTF — Unicode Transformation Format. кодировки постоянной длины, UTF-32, номер символа из таблицы Unicode занимает 4 байта. UTF-8 — кодировка с переменным числом байт. кодировать символы распространённые символы занимают 1-2 байта, редко встречающиеся символы по 4 байта. все символы таблицы ASCII занимают по одному байту, текст, на английском с использованием кодировки UTF-8, занимать столько же места, как и текст, написанный с использованием таблицы символов ASCII.

Unicode основной кодировкой, в работе все, кто связан с компьютерами и текстами. Unicode использовать сотни тысяч символов и отображать их одинаково на всех устройствах.

Кодировка — соответствие между визуальными символами и числами.
Кодировки необходимы, так как компьютеры созданы для работы с числами и не понимают текст.
До 1990-х годов не существовало единой кодировки, текст, написанный в одной кодировке, становится совершенно нечитаемым на других.
Unicode — единый стандарт кодирования символов.
UTF-8, UTF-16, UTF-32 и т.п. — варианты кодировок, основанные на Unicode. по-разному хранят информацию.
UTF-8 — самая популярная кодировка. самые популярные символы кодируются 1-2 байтами, а редко встречающиеся занимают 3-4 байта. Это приводит к существенной экономии памяти, при работе с английским текстом.

