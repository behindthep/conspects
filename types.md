программа перед выполнением загружается в оперативную память. В ней находится код программы - исполняется процессором и её данные - в память помещает сама программа.

Программа и её данные во время работы хранятся в памяти. память компьютера представлена в виде ячеек – байт. У ячейки уникальный номер – 0, 1, 2, 3 - адрес. Зная номер ячейки, сохранить в эту ячейку данные. взять их из неё. В ячейках хранится код программы – набор команд для процессора, в других ячейках – данные программы.

Процессор умеет исполнять команды из загруженной в память программы. Почти все команды процессора — взять данные из некоторых ячеек → сделать с ними что-то → результат поместить в другие ячейки.
Объединяя сотни простых команд, получаем сложные и полезные.

выполнение программы доходит до команды создания переменной, ей выделяется область не использованной памяти (несколько байт) размером, в зависимости от типа переменной. При объявлении переменной указать тип. Без знания типа информации не ясно, какого размера блок памяти выделить под переменную.

программы работали с номерами ячеек памяти, но потом ячейкам стали давать имена (имя переменной).

Адрес переменной - адрес первой ячейки выделенного под неё блока памяти.
Java-программа обращается к памяти только через Java-машину.

Данные String помещаются в спец объект, под который выделяется память, адрес объекта помещается в переменную, под которую выделяется память.

<img width="1024" height="564" alt="image" src="https://github.com/user-attachments/assets/bb2131ae-f11a-41b7-af21-78b0de8efdb2" />

str String значение D12 — адрес первой ячейки объекта, содержащего текст.
Объект String (текст) хранится отдельным блоком памяти. Адрес его первой ячейки хранится в переменной str.

String s1 = "Hello";
String s2 = s1;
s2 = s2 + " World";
s1 и s2 ссылаются на ту же строку "Hello" до момента изменения. 
для s2 создаётся новая строка "Hello World", а s1 смотрит на старую строку "Hello".

Группу как "номер первого элемента" + "количество", внутри группы относительные номера. Переменной 100 байт, X – адрес первого, адреса у байтов: X+0, X+1, X+2, X+99.


**Сильная(Java) — слабая**
язык приводят типы - слабой (нестрогой) типизацией. в выражении переменные любых типов и не беспокоиться об их приведении.
print("12" + 13) // 1213
print(12 + "13") // 25

язык требуют определить переведение в другой тип. сильной (строгой) типизацией.
print("12" + 13) // Ошибка!
print("12" + toString(13)) // 1213
print(toNumber("12") + 13) // 25

Компилятор проверяет типы без запуска кода - статическая типизация. Синтаксические ошибки находятся во время компиляции, до запуска программы.
В динамических языках переменная может изменить тип во время выполнения программы.

**Статическая(Java) — динамическая**
В статически типизированном языке тип переменной устанавливается при определении и не может измениться во время выполнения.
присвоить переменной одного типа значение другого - ошибка, найти без запуска программы.
number age = 44
age = "Not so old" // Ошибка

Динамически типизированные язык. тип меняться по ходу исполнения программы.
age = 44 
age = "Not so old"

### Размер в памяти

long 8 байт	−9.22 × 10^18 ... ≈ 9.22 × 10^18 10000000000L

float (floating-point number — число с плавающей точкой) 4 байта 3.14f низкая, одинарная точность (7 знаков после запятой)
double* 8 байт	-1.7E+308 высокая, двойная точность (16 знаков после запятой)

char — 16-битное число (0 - 65535), значению символ. За символом код (стандарт таблица Unicode - символы со всего мира). 

### double

String.format("%.1f%n", 23.56789); // 23.6 и \n

Компьютеры работают с числами в двоичной системе. 1/3 нельзя точно записать десятичной дробью 0.333. 0.1 в двоичной системе — бесконечная дробь, и её "округлять" для хранения.
double хранит лишь близкое приближённое значение.

```java
0.1 + 0.2; // 0.30000000000000004 компьютер многие числа не может точно представить в двоичной системе.

double epsilon = 0.000001;

if (Math.abs((0.1 + 0.2) - (0.3)) < epsilon) { // с допуском
    System.out.println("Почти равно!");
}

double rounded = Math.round(3.14159 * 100.0) / 100.0; // 3.14 Умножаем на 100 (два знака). Округляем до целого Math.round(314.159) = 314. Делим обратно на 100.0

import java.text.DecimalFormat;

DecimalFormat df = new DecimalFormat("#,##0.00"); // разделители тысяч
df.format(1234567.89); // 1,234,567.89

byte small = (byte) 300; // 44 byte от -128 до 127, число не помещается — "обрезание" по модулю 256 (остаток от деления).
```


ссылочные типы, объекты: переменная хранит ссылку на место, где объект расположен в памяти.
Ссылочные типы создаются программистом, за исключением String и Array

Строки **иммутабельны**. метод строки может только вернуть новую строку, не изменить сущ.
Полезно для оптимизации памяти. Строки кэшируются в специальное место в памяти - String Pool.
При использовании конкатенации строк много временных объектов создаётся, это может снизить производительность.
Позволяет Java эффективно управлять памятью и избежать дублирующихся строк. 
JVM проверяет, сущ. ли такая строки в Pool, если да, то возвращяет ссылку на неё, иначе создаёт новую и помещает в Pool.

```java
var name1 = "Java"; // Выделяется память 
var name2 = "Java"; // строка уже есть, подставляется ссылка на уже созданную строку - экономится память
// Сравнение по ссылке. Обе переменные указывают на один участок памяти
name1 == name2; // true

name1.equalsIgnoreCase(name3); // сравниваем строки по значению, чем по ссылке - методы. 

var greet =  new String("Hello";) // Создаётся новый объект строки, даже если такая строка уже есть в Pool. литералы предпочтительнее.
```

если строка возвращается из метода, она помещается в свою область памяти со своим уникальным адресом:
```java
// Выделяется новая память в любом случае
var name1 = "java".toUpperCase(); // "JAVA"
// Выделяется новая память в любом случае
var name2 = "java".toUpperCase(); // "JAVA"
name1 == name2; // false
```


конкатенировать String в цикле через +. Это неэффективно по времени и памяти — используйте StringBuilder

