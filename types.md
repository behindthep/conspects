Данные String помещаются в спец объект, под который выделяется память, адрес объекта помещается в переменную, под которую выделяется память.

<img width="1024" height="564" alt="image" src="https://github.com/user-attachments/assets/bb2131ae-f11a-41b7-af21-78b0de8efdb2" />

str String значение D12 — адрес первой ячейки объекта, содержащего текст.
Объект String (текст) хранится отдельным блоком памяти.

String s1 = "Hello";
String s2 = s1;
s2 = s2 + " World";
s1 и s2 ссылаются на ту же строку "Hello" до момента изменения. 
для s2 создаётся новая строка "Hello World", а s1 смотрит на старую строку "Hello".



long 8 байт	−9.22 × 10^18 ... ≈ 9.22 × 10^18 10000000000L

float (floating-point number — число с плавающей точкой) 4 байта 3.14f низкая, одинарная точность (7 знаков после запятой)
double* 8 байт	-1.7E+308 высокая, двойная точность (16 знаков после запятой)

char — 16-битное число (0 - 65535), значению символ. За символом код (стандарт таблица Unicode - символы со всего мира). 


String.format("%.1f%n", 23.56789); // 23.6 и \n

Компьютеры работают с числами в двоичной системе. 0.1 в двоичной системе — бесконечная дробь, и её "округлять" для хранения.
double хранит лишь близкое приближённое значение.

0.1 + 0.2; // 0.30000000000000004 компьютер многие числа не может точно представить в двоичной системе.

double epsilon = 0.000001;

if (Math.abs((0.1 + 0.2) - (0.3)) < epsilon) { // с допуском
    System.out.println("Почти равно!");
}

double rounded = Math.round(3.14159 * 100.0) / 100.0; // 3.14 Умножаем на 100 (два знака). Округляем до целого Math.round(314.159) = 314. Делим обратно на 100.0

import java.text.DecimalFormat;

DecimalFormat df = new DecimalFormat("#,##0.00"); // разделители тысяч
df.format(1234567.89); // 1,234,567.89

byte small = (byte) 300; // 44 byte от -128 до 127, число не помещается — "обрезание" по модулю 256 (остаток от деления).



Строки **иммутабельны**. метод строки может только вернуть новую строку, не изменить сущ.
Полезно для оптимизации памяти. Строки кэшируются в специальное место в памяти - String Pool.
При использовании конкатенации строк много временных объектов создаётся, это может снизить производительность. конкатенировать String в цикле через +. неэффективно по времени и памяти — используйте StringBuilder
Позволяет Java эффективно управлять памятью и избежать дублирующихся строк. 
JVM проверяет, сущ. ли такая строки в Pool, если да, то возвращяет ссылку на неё, иначе создаёт новую и помещает в Pool.

var name1 = "Java"; // Выделяется память 
var name2 = "Java"; // строка уже есть, подставляется ссылка на уже созданную строку - экономится память
// Сравнение по ссылке. Обе переменные указывают на один участок памяти
name1 == name2; // true

name1.equalsIgnoreCase(name3); // сравниваем строки по значению, чем по ссылке - методы. 

var greet =  new String("Hello";) // Создаётся новый объект строки, даже если такая строка уже есть в Pool. литералы предпочтительнее.

если строка возвращается из метода, она помещается в свою область памяти со своим уникальным адресом:
// Выделяется новая память в любом случае
var name1 = "java".toUpperCase(); // "JAVA"
// Выделяется новая память в любом случае
var name2 = "java".toUpperCase(); // "JAVA"
name1 == name2; // false
