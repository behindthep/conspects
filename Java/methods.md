Для изменения строк без создания новых объектов StringBuilder и StringBuffer.

```java
StringBuild sb = new StringBuilder("Hello");
sb.append(", world!");
```

Вызов нестатических методов у объектов (строка) - логика относительно данных объекта.
```java
var random = new Random();
random.nextInt(10); // 0-10

import java.time.LocalDate;

var currentDate = LocalDate.now(); // дата
currentDate.getDayOfMonth(); // текущий день
```

Вызов статических методов из класса - Отношение ко всем объектам данного типа, не связаны с конкретным объектом.
```java
Math.random();
Files.readString(path); // Чтение данных по пути. Без объекта, статический метод
path.read(); // через объект файла
```


Метод - способ повысить уровень абстракции. Объеденить операции, о которых думать как о целом, не погружаясь в детали работы.
Изменения внутри функции не скажутся на тех, кто пользуется ею, если её интерфейс не поменяется.


**Инкремент и декремент** не только возвращают значение, но и изменяют значение переменной.


Изолируйте побочные эффекты от чистого кода. в начале работы чтение данных на самом верхнем уровне, потом внутри блок чистой логики - поведение зависит только от входных аргументов, нет внешней среды и на выходе запись в файл.


Ответственность функции парсинга HTML. поведение от того, каким образо получен HTML? принимает объект response, имеет прямое отношение к сети и специфичен для библиотеки.

функция специфична. завязана на два файла, в её коде нет, что связывало эти файлы. файлов три, переписать, обработка файла не поменялась. количество файлов любым?
снижает модульность программы.
Одни части приложения опираться на другие, где этого можно избежать. изменение в одном месте к код ломаться в другом.
только сверху вниз, подстраивать модули и функции нижних уровней под верхние уровни, под имеющиеся данные и их структуру. Но внутренний код, независимый от приложения. Функция чтения файла — сама по себе, ей не важно, сколько у нас файлов.

структуры внешнего кода должны быть подстроены под аргументы функции.

Проектируем функцию compareCourses сверху-вниз. определили её внешний интерфейс и затем вглубь. Фокус на клиентах библиотеки, а не на её внутренностях.

Механизм определения чётности и проверка ввода пользователя, угадал ли он.
Модули нижнего уровня не знать про модули верхнего. Верхний подстраиваться под нижний.

Разбиение на уровни код менее связанным. другую библиотеку для запросов код, отвечающий за парсинг, затронут не будет. Не сказать о реализациях, где парсинг смешан с получением данных.

Функции не зависят друг от друга напрямую, а фокусируются на выполнении своих задач.


- сверху-вниз — нисходящее - сначала реализуется высокоуровневая логика, а затем идет погружение в детали.
фокус не на устройстве кода, а на том, как он будет использоваться. способы использования влияют на интерфейсную часть кода — классы, методы, функции, с чем взаимодействуют клиенты кода.
TDD, встает на место пользователей, как лучше его спроектировать.

- снизу-вверх — восходящее - сначала реализуются детали, затем общая логика.
При проектировании в обратном направлении - делали-делали, а когда начали использовать — поняли, что неудобно.

понять, что от кода требуется и как он будет использоваться.

библиотека для построения различий между двумя файлами. интерфейс библиотеки — функция, принимает два пути до файлов (yml, json) и возвращает описание различий между структурами файлов.
описали, как она использоваться, но ещё не знаем как написана.

на уровень ниже, внутрь функции. прочитать файлы. пути до файлов относительными, предварительно их нормализовать, получить полный путь до файла (абсолютный).

**Нормализация данных** - приведении данных к общему виду перед основным алгоритмом обработки этих данных.


Сравнение со строкой – худший из возможных подходов.
Адрес строится как строка. поменяется?
замена строк на вызовы функций. строить ссылки на базе сущ роутинга. несоответствия порождать исключения. менять готовую ссылку без переписывать код везде, где она используется.

Обработку через функции. Вместо ручной сборки - функции, защитить от опечаток

проверок на соответствие создание перечисления (enum). замена строк на обращение к значениям из специального описания, где есть все возможные значения. описание использоваться всеми частями программы, которые на него завязаны. изменение структуры к ошибкам, где есть неверные обращения с точки зрения нового кода.

Примеры: https://ru.hexlet.io/blog/posts/izbavlyaytes-ot-strok


разделять получение данных и их использование
// Неправильно
const { output } = state.fileTabsInfo.tabs.find(tab => tab.id === 'output').result;
// Правильно
const outputTab = state.fileTabsInfo.tabs.find(tab => tab.id === 'output');
const { output } = outputTab.result;


### Перегрузка методов
В Java нельзя задать значение по умолчанию. Выбирается метод по типу и количеству параметров.
Для снижения дублирования метод с большим числов параметров, затем вызывать его из методов из других, где есть значения по умолчанию.

```java
public static int sum(int x, int y) {
    return x + y;
}

public static int sum(int x) {
    return sum(x, 10);
}
```
