In java not allowed create just function, all functions creates only inside classes and called methods.

All not primitive (reference) types are **objects**.

Methods returns values - so we can divide program to pieces and make something complex from it.


вызовы методов разбить на две группы:

**Вызовы методов у объектов, таких как строки**
Нестатические методы строят свою логику относительно данных самого объекта и вызываются у конкретных объектов
```java
var random = new Random();
random.nextInt(10); // Возвращает случайное число в диапазоне от 0 до 10

// Импорт, чтобы использовать классы из других файлов
import java.time.LocalDate;
var currentDate = LocalDate.now(); // Текущая дата
currentDate.getDayOfMonth(); // Извлекает текущий день

var file = new File("file.txt");
file.exists(); // Проверка того, что файл существует
```
Такие методы выполняют действия над объектами, у которых они вызываются, и часто не принимают никаких аргументов. Объекты - данные, которые доступны внутри метода. метод строки toLowerCase() внутри себя берет исходную строку, преобразует ее и возвращает результат наружу.
System.out.println() — метод объекта out, который лежит внутри класса System.

**Вызовы статических методов, которые не связаны с конкретными объектами**
Статические методы не связаны с конкретными объектами и вызываются из класса напрямую
Но не все вызовы методов связаны с объектами: иногда действие есть, а объекта нет.

Математические операции над числами или действия, которые не относятся к конкретному объекту, а имеют отношение ко всем объектам данного типа. В таком случае метод опирается на данные, которые приходят в виде параметров:
```java
Math.random(); // Получение случайного числа, вызов напрямую из класса Math
Files.readString(path); // Чтение данных по указанному пути
```
Классы Math и Files в данном случае нужны только для вызова, методы определены внутри них. Java не позволяет определять методы вне классов.

можно придумать какой-то объект, над которым происходит вычисление.

Files.readString(path); // Без объекта, статический метод
path.read(); // можно через объект файла


static — метод принадлежит самому классу. вызвать метод, используя имя класса, без необходимости создавать объект этого класса



Функция - способ повысить уровень абстракции. функции описывают операции, о которых мы хотим думать, как о едином целом, не погружаясь в детали того, как они работают.

изменения внутри функции не скажутся на тех, кто пользуется ею. Её интерфейс не поменяется.

код, взаимодействующий с внешней средой, Побочные эффекты усложняют код:
Поведение функции менее предсказуемым, порождать ошибки, например связанные с проблемами сети.
Функции с побочными эффектами сложнее переиспользовать и тестировать.
код, вызывающий функцию с побочными эффектами, обладать теми же недостатками. Чем глубже по стеку вызовов помещается побочный эффект, тем хуже.
файловых операций (ввод/вывод, IO): чтение, запись файлов, взаимодействие с базой, отправка писем.
изменение окружения внутри программы, модификация глобальных переменных (общего состояния).
"Изолируйте побочные эффекты от чистого кода". всё, что связано с вводом/выводом, должно быть не внутри, а, на самом верхнем уровне. в начале работы программы чтение необходимых данных, потом большой блок основной логики (чистый код. поведение зависит только от входных аргументов (нет внешней среды, сети)) и на выходе снова побочный эффект, например, запись в файл. к этому стремиться.


После изменений ответственность функции сократилась до парсинга входного HTML и возврата необходимых данных. Может ли её поведение зависеть от того, каким образом получен HTML? нет, ей должно быть без разницы, как он попал в программу. фактически это не так: функция принимает на вход объект response, который имеет прямое отношение к сети и специфичен для конкретной библиотеки axios.
проектируем функцию compareCourses по принципу сверху-вниз. Сначала мы определили её внешний интерфейс и затем пошли вглубь. правильный подход, фокусируется на клиентах библиотеки, а не на её внутренностях.
Проблемы когда разработчик подстраивает поведение и интерфейс нижних модулей под верхние модули. текстовую игру, пользователю выводится число, и он должен указать, чётное оно или нет.  вводом yes или no в консоль. чёткое разделение уровней: есть число и механизм определения его чётности, и есть отдельная задача — проверка ввода пользователя, угадал ли он.
в программу вводятся значения yes и no, разработчик "подстроил" процесс работы с чётным числом под него. "течёт абстракция". Модули нижнего уровня не должны знать про модули верхнего уровня. верхний уровень должен подстраиваться под нижний уровень.
функция isEven(number) выполняет свою задачу как должна. использована в любом контексте.
сеть построена с использованием идеи модель OSI, программисты используют HTTP, не думая про то, как конкретно (по воздуху, по проводам) данные доставляются пользователю.
уровневым проектированием. разбиение на уровни код более устойчивым, простым для анализа и менее связанным. решим использовать другую библиотеку для запросов или откажемся от HTTP в пользу работы с файлами, то код, отвечающий за парсинг, затронут не будет. нельзя сказать о реализациях, в которых парсинг смешан с получением данных.

Композиция вместо вложенности (Пайплайн)
Код как плоская цепочка функций, сквозь которые пропускаются данные. Каждая функция возвращает новые данные, которые затем используются либо в других функциях, либо напрямую.
такой порядок исполнения кода (Pipeline). функции не зависят друг от друга напрямую, а фокусируются на выполнении только своих задач. возможность соединять их и переиспользовать.



К написанию кода можно подходить с двух позиций: сверху-вниз — нисходящее, и снизу-вверх — восходящее. В первом случае сначала реализуется высокоуровневая логика, а затем идет погружение в детали. Во втором – наоборот, сначала реализуются детали, затем общая логика.


фокус находится не на устройстве кода, а на том, как он будет использоваться. способы использования влияют на интерфейсную часть кода — классы, методы, функции, всё то, с чем взаимодействуют клиенты этого кода.
Программист, использующий TDD, встает на место пользователей своего кода, и понимает, как лучше его спроектировать.

При проектировании в обратном направлении возможна ситуация, что делали-делали, а когда начали использовать — поняли, что неудобно.

Сначала нужно понять, что от кода требуется и как он будет использоваться.

библиотека для построения различий между двумя файлами. весь интерфейс библиотеки — одна функция, принимает два пути до файлов (yml, json, ini) и возвращает описание различий между структурами этих файлов.

описали то, как она будет использоваться, но ещё не знаем про то, как она будет написана. реализовать эту функциональность разными способами, и ни один из них не повлияет на то, как библиотека будет использоваться. получили модульность.

попробуем опуститься на уровень ниже, внутрь функции. Одна из первых задач: прочитать эти файлы. пути до файлов могут быть относительными, то предварительно их нужно нормализовать, получить полный путь до файла (абсолютный).

Нормализация данных. приведении данных к общему виду перед основным алгоритмом обработки этих данных.
извлечь из HTML все ссылки и загрузить их содержимое. HTML уже проанализирован, а ссылки собраны в массив. Кроме ссылок понадобится имя домена, на котором был расположен этот HTML. для загрузки относительных ссылок, тех ссылок, у которых не указан домен в HTML, /about.

место, где готовятся данные, а есть место, где выполняется основная логика.
условие, проверяющее относительность ссылки. приводит данные к нужному для обработки виду. ссылки были полными ещё до попадания в эту часть программы.

Использование готовых инструментов — идеальное решение задачи.


функция слишком специфична. завязана ровно на два файла, хотя в её коде нет ничего, что связывало бы эти файлы между собой. Если бы файлов было три, то её пришлось бы переписать, обработка каждого конкретного файла бы не поменялась. А если бы количество файлов могло быть любым?
Подобный код снижает модульность программы. Одни части приложения начинают опираться на другие там, где этого можно было избежать. изменение в одном месте к код ломаться в другом месте — там, где этого не ожидали.
Когда разработчик думает только сверху вниз, он начинает подстраивать модули и функции нижних уровней под верхние уровни, под имеющиеся данные и их структуру. Но внутренний код, независимый от самого приложения. Функция чтения файла — сама по себе, ей не важно, сколько у нас там файлов.

аргументы функции подстроены под структуры внешнего кода, хотя должно быть наоборот.



Сравнение со строкой – худший из возможных подходов.
Адрес строится как строка. Что, если он поменяется? Программист снова не узнает о проблеме в момент ее появления.
замена строк на вызовы функций. писать самим, пользоваться готовыми инструментами. в фреймворках есть механизм, позволяющий строить ссылки на базе сущ роутинга. несоответствия начнут порождать исключения. менять готовую ссылку без необходимости переписывать весь код везде, где она используется.

с адресами вне роутинга (если пользователь вводит адрес сам) Обработку выполнять через спец функции, которые сами проверяют их корректность.
с путями в файловой системе. Вместо ручной сборки готовые функции, защитить от опечаток

проверок на соответствие создание перечисления (enum). замена строк на обращение к значениям из специального описания, где есть все возможные значения. Это описание должно использоваться всеми частями программы, которые на него завязаны. изменение структуры к ошибкам, где есть неверные обращения с точки зрения нового кода.

Примеры кода для понимания: https://ru.hexlet.io/blog/posts/izbavlyaytes-ot-strok


глобальная переменная, к которой может получить доступ любая часть системы (через импорт) и изменить ее любым способом. глобальные переменные избегать всегда, когда это можно.

библиотеку для автокомплита и подключили ее на странице. внутри себя хранит те данные, которые она загрузила с бекенда,  для ускорения доступа. подключить два автокомплита на одной странице. Изменения в одном автокомплите влиять на другой.

для различных автокомплитов разные куски данных, в случае динамического добавления и удаления автокомплитов, проблема все равно вылезет. не сущт способа сделать подобную реализацию такой, чтобы с ней не возникало проблем во всех ситуациях

В тестировании тесты не должны зависеть друг от друга, но с глобальным состоянием это невозможно. изменения состояния в одном тесте отразятся на втором.

способ работы с состоянием – его локализация относительно приложения.
добавлять на страницу любое число автокомплитов не боясь, что они друг на друга повлияют. У каждого автокомплита свое локальное состояние, с которым он работает.
принцип работы с состоянием неизменным – все приложение заворачивается в функцию, которая определяет состояние глобальное для конкретного приложения, но локальное относительно среды запуска этого приложения.
Никогда не используйте глобальное состояние для данных. Если нужно хранить данные – используйте объекты, создаваемые внутри приложения.


всегда стоит сразу разделять получение данных и их использование
// Неправильно
const { output } = state.fileTabsInfo.tabs.find(tab => tab.id === 'output').result;
// Правильно
const outputTab = state.fileTabsInfo.tabs.find(tab => tab.id === 'output');
const { output } = outputTab.result;


в Java нет возможности задать значение по умолчанию, но ее можно имитировать с помощью **перегрузки методов** - несколько методов с одинаковым именем. во время компиляции выбирается та версия метода, которая совпадает по типу и количеству параметров.
```java
class App {
    public static int sum(int x, int y) { // Для снижения дублирования сначала определить общий метод, который принимает больше всего параметров
        return x + y;
    }

    public static int sum(int x) { // Затем вызывать его из тех методов, где есть значения по умолчанию
        // Вызываем уже готовый метод суммирования
        return sum(x, 10);
        // вместо return x + 10;
    }
}

App.sum(2); // 12
App.sum(2, 1); // 3
```



Fluent interface:
obj.method1().method2(); (chain of methods) - method2() gets val that returns by method1().

For string changing use StringBuilder and StringBuffer classes, that allow to change string without creating new objects.

```java
StringBuild sb = new StringBuilder("Hello");
sb.append(", world!");
```


### Pure function

Method is **determined** when for same input parameters (even if it's empty) it returns same result.


Print on screen (~same as write in file~) and returning value is different operations.

Print on screen is **side effect** - actions that touch with external environment (Network, file, printer, DB...).


В отличие от всех остальных операций, инкремент и декремент не только возвращают значение, но и изменяют значение переменной.

Никогда не смешивай операции и методы с побочными эффектами с операц. и методами без побочных эффектов.
