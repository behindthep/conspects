In Java methods creates only within classes.

#### Fluent interface
Methods returns values - so we can divide program to pieces and make something complex from it.
obj.method1().method2(); (chain of methods) - method2() gets val that returns by method1().

For string changing use StringBuilder and StringBuffer classes, that allow to change string without creating new objects.

```java
StringBuild sb = new StringBuilder("Hello");
sb.append(", world!");
```

Объекты - данные, доступны внутри метода. Метод строки toLowerCase() внутри берет строку, преобразует ее и возвращает наружу.

System(класс).out(объект).println()(метод)

### Вызовы методов разбить на две группы:

- Вызов нестатических методов у объектов (строки) - строят логику относительно данных объекта и вызываются у объектов.
```java
var random = new Random();
random.nextInt(10); // случайное число от 0 до 10

import java.time.LocalDate;

var currentDate = LocalDate.now(); // Текущая дата
currentDate.getDayOfMonth(); // Извлекает текущий день
```


- Вызов статических методов, не связаны с объектами. Вызываются из класса. Отношение ко всем объектам данного типа.
```java
Math.random(); // Получение случайного числа, вызов напрямую из класса Math
Files.readString(path); // Чтение данных по указанному пути. Без объекта, статический метод
path.read(); // через объект файла
```


### Architecture

Метод - способ повысить уровень абстракции, описывают операции, о которых думать как о едином целом, не погружаясь в детали как они работают.

Изменения внутри функции не скажутся на тех, кто пользуется ею, если её интерфейс не поменяется.

### Pure function

Method is **determined** when for same input parameters (even if it's empty) it returns same result.
Print on screen (~same as write in file~) and returning value is different operations.
Print on screen is **side effect** - actions that touch with external environment (Network, file, printer, DB...).


**Инкремент и декремент** не только возвращают значение, но и изменяют значение переменной.


#### Побочные эффекты

Код, взаимодействующий с внешней средой.
Поведение менее предсказуемым, ошибки, связанные с проблемами например сети. сложнее переиспользовать и тестировать.

Чем глубже по стеку вызовов помещается побочный эффект, тем хуже.


Изолируйте побочные эффекты от чистого кода. Стремиться в начале работы чтение данных на самом верхнем уровне, потом внутри блок чистой логики - поведение зависит только от входных аргументов, нет внешней среды и на выходе побочный эффект, запись в файл.


Ответственность функции парсинга входного HTML и возврата. поведение функции зависит от того, каким образом получен HTML? функция принимает объект response, который имеет прямое отношение к сети и специфичен для библиотеки.

функция слишком специфична. завязана ровно на два файла, в её коде нет ничего, что связывало бы эти файлы между собой. Если бы файлов было три, переписать, обработка файла не поменялась. количество файлов любым?
снижает модульность программы.
Одни части приложения опираться на другие, где этого можно избежать. изменение в одном месте к код ломаться в другом.
только сверху вниз, подстраивать модули и функции нижних уровней под верхние уровни, под имеющиеся данные и их структуру. Но внутренний код, независимый от приложения. Функция чтения файла — сама по себе, ей не важно, сколько у нас файлов.

аргументы функции подстроены под структуры внешнего кода, должно быть наоборот.


Проектируем функцию compareCourses по принципу сверху-вниз. Сначала определили её внешний интерфейс и затем вглубь. Фокус на клиентах библиотеки, а не на её внутренностях.

Механизм определения чётности и есть отдельная задача — проверка ввода пользователя, угадал ли он.
Модули нижнего уровня не знать про модули верхнего уровня. Верхний уровень подстраиваться под нижний уровень.

Разбиение на уровни код менее связанным. Использовать другую библиотеку для запросов или откажемся от HTTP в пользу работы с файлами, код, отвечающий за парсинг, затронут не будет. Не сказать о реализациях, где парсинг смешан с получением данных.


Код как плоская цепочка функций, сквозь которые пропускаются данные. Функция возвращает данные, которые используются в других функциях. Функции не зависят друг от друга напрямую, а фокусируются на выполнении своих задач.


К написанию кода с позиций:
- сверху-вниз — нисходящее - сначала реализуется высокоуровневая логика, а затем идет погружение в детали.
фокус не на устройстве кода, а на том, как он будет использоваться. способы использования влияют на интерфейсную часть кода — классы, методы, функции, с чем взаимодействуют клиенты кода.
TDD, встает на место пользователей, как лучше его спроектировать.

- снизу-вверх — восходящее - сначала реализуются детали, затем общая логика.
При проектировании в обратном направлении - делали-делали, а когда начали использовать — поняли, что неудобно.

Сначала понять, что от кода требуется и как он будет использоваться.

библиотека для построения различий между двумя файлами. интерфейс библиотеки — функция, принимает два пути до файлов (yml, json) и возвращает описание различий между структурами файлов.
описали, как она будет использоваться, но ещё не знаем как она будет написана. реализовать эту функциональность разными способами, и ни один из них не повлияет на то, как библиотека будет использоваться. модульность.

опуститься на уровень ниже, внутрь функции. Одна из первых задач: прочитать файлы. пути до файлов относительными, предварительно их нормализовать, получить полный путь до файла (абсолютный).

**Нормализация данных** - приведении данных к общему виду перед основным алгоритмом обработки этих данных.



Сравнение со строкой – худший из возможных подходов.
Адрес строится как строка. поменяется? Программист не узнает о проблеме в момент ее появления.
замена строк на вызовы функций. строить ссылки на базе сущ роутинга. несоответствия порождать исключения. менять готовую ссылку без переписывать код везде, где она используется.

с адресами вне роутинга (пользователь вводит адрес сам) Обработку через функции, проверяют их корректность.
с путями в файловой системе. Вместо ручной сборки - функции, защитить от опечаток

проверок на соответствие создание перечисления (enum). замена строк на обращение к значениям из специального описания, где есть все возможные значения. описание использоваться всеми частями программы, которые на него завязаны. изменение структуры к ошибкам, где есть неверные обращения с точки зрения нового кода.

Примеры кода для понимания: https://ru.hexlet.io/blog/posts/izbavlyaytes-ot-strok


**Глобальные переменные** избегать когда это возможно.
тесты не зависеть друг от друга, но с глобальным состоянием это невозможно. изменения состояния в одном тесте отразятся на втором.

способ работы с состоянием – его локализация относительно приложения.

принцип работы с состоянием неизменным – все приложение заворачивается в функцию, которая определяет состояние глобальное для приложения, но локальное относительно среды запуска этого приложения.
не используйте глобальное состояние для данных. хранить данные – объекты, создаваемые внутри приложения.


разделять получение данных и их использование
// Неправильно
const { output } = state.fileTabsInfo.tabs.find(tab => tab.id === 'output').result;
// Правильно
const outputTab = state.fileTabsInfo.tabs.find(tab => tab.id === 'output');
const { output } = outputTab.result;


#### Перегрузка методов
В Java нет возможности задать значение по умолчанию, имитировать с перегрузкой методов. Выбирается метода совпадает по типу и количеству параметров.
Для снижения дублирования определить общий метод, принимает больше всего параметров, затем вызывать его из методов, где есть значения по умолчанию.
```java
public static int sum(int x, int y) {
    return x + y;
}

public static int sum(int x) {
    return sum(x, 10);
}
```
