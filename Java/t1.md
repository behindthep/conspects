### Errors, Compiler

- Syntax errors are detected **during compilation**, before the program starts running.


- At the basic level, computers operate only with **numbers**.


- In Java, **integer division** is used **by default**: 3 / 2 = 1


### Variables

```java
var greeting = "Father";
greeting = "Mother"; // 'var' is not needed here because it was already declared.
```

- Java is **statically typed** language - the var type is set when it declared and cannot be changed afterwards.

If you try to assign a number to the same var, you will get an error: incompatible types: int cannot be converted to java.lang.String.

The **compiler** performs this check without running the code - this type of typing called static typing.
In dynamic languages, the same behavior would not cause an error - a var can change its type during execution.

'var' шы used to automatically define the type of a value based on the value:
```java
var x = 3; // x is inferred as int because 3 is an int
int x = 3; // this is the explicit way to declare x as int.
Using 'var' is often prefrebale the type is clear from the value assigned.
This feature is called **type inference**.
```

- Magic numbers - create vars for numbers used in expressions:
```java
// Instead of this:
var euros = 1000;
var dollars = euros * 1.25; // What is 1.25? How would u or ur team undestand it when looking at the project after a month?

// Do this:
var euroToDollarRate = 1.25;

var dollars = euros * euroToDollarRate;
```

#### Constants:

- To declare data that never changes, use constants:
```java
final var pi = 3.14; // 'final' tells the compiler not to allow changes tho this var
```


### null

null - is not type, it's default value for **reference types** when val is not defined.

```java
String a; // null
```

null and primitive types are not compatible. Primitive val always should be declared.


### type conversion

```java
// obvious
var n = Integer.parseInt("345"); // 345
var res = (int) 5.1; // 5 for conversion between primitive types
```

Implicit type conversion
Some conversion can be automatically happen if in one expression participate different types - for it need that type be compatible beside each other and dimension conversioned types was equal or lower than result type.

```java
var a true;
// Error: incompatible types: int cannot be converted to boolean
a = 1;

short a = 5; // 2 bytes in memory
int sum = a + 1; // 4 bytes now

// Loss of accuracy:
int a = 5;
// Error: incompatible types: possible lossy conversion from int to short
short sum = a + 2;

var a = 10;
var res = "Number: " + a; // Number: 10 - 10 to String representation
```


## Methods

In java not allowed create just function, all functions creates only inside classes and called methods.

All not primitive (reference) types are **objects**.

Methods returns values - so we can divide program to pieces and make something complex from it.


### Strings

Strings are **immutable**. String method can only return new string, not change existent.
Create new based on old val. Strings Immutability worth for memory optimization, string can be cached in String Pool, also for safety in multithreaded environment.
When use string concatenation many temporary object created, so it can decrease performance.

```java
var greet = "Hello"; // string store in specific memory space called 'String Pool'
```

String literals - strings that placed inside "literals". They automatically saved in String Pool, it let Java efficiently manage memory and decrease quantity of duplicating strings.

When string create with literal, JVM checks, if exists the same string in Pool. If she finded, then returns link to it, if doesn't - create new string and place it in Pool.

```java
var greet =  new String("Hello";) // This way created new string object, even if same string already exist in Pool. Because of it using literals are preferable.

var sub = greet.substring(0, 3).toUpperCase(); // "HEL". 'greet' is a object of class String and substring is a method of class String.
```

Fluent interface:
obj.method1().method2(); (chain of methods) - method2() gets val that returns by method1().

For string changing use StringBuilder and StringBuffer classes, that allow to change string without creating new objects.

```java
StringBuild sb = new StringBuilder("Hello");
sb.append(", world!");
```

