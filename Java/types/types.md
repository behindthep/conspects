### Память

программа перед выполнением загружается в оперативную память. В ней находится код программы - исполняется процессором и её данные - в память помещает сама программа.

Программа и её данные во время работы хранятся в памяти. память компьютера представлена в виде ячеек – байт. У ячейки уникальный номер – 0, 1, 2, 3, ... (нумерация с нуля) - адрес. Зная номер ячейки, можем сохранить в эту ячейку данные. взять их из неё. В ячейках хранится код программы – набор команд для процессора, в других ячейках – данные программы.

Процессор умеет исполнять команды из загруженной в память программы. Почти все команды процессора — взять данные из некоторых ячеек → сделать с ними что-то → результат поместить в другие ячейки.
Объединяя сотни простых команд, получаем сложные и полезные.

Когда выполнение программы доходит до команды создания переменной, ей выделяется область не использованной памяти (несколько байт) размером, в зависимости от типа переменной. При объявлении переменной указать тип. Без знания типа информации не ясно, какого размера блок памяти выделить под переменную.

программы работали с номерами ячеек памяти, но потом ячейкам стали давать имена (имя переменной).

Адрес переменной - адрес первой ячейки выделенного под неё блока памяти.
Java-программам запрещено напрямую обращаться к памяти - только через Java-машину.

Данные String помещаются в спец объект, под который выделяется память, адрес объекта помещается в переменную, под которую выделяется память.

<img width="1024" height="564" alt="image" src="https://github.com/user-attachments/assets/bb2131ae-f11a-41b7-af21-78b0de8efdb2" />

b int 4 байта и хранит значение 10555.
str String значение D12 — адрес первой ячейки объекта, содержащего текст.
Объект String (текст) хранится отдельным блоком памяти. Адрес его первой ячейки хранится в переменной str.

String s1 = "Hello";
String s2 = s1;
s2 = s2 + " World";
s1 и s2 ссылаются на ту же строку "Hello" до момента изменения. 
для s2 создаётся новая строка "Hello World", а s1 смотрит на старую строку "Hello".

Группу как "номер первого элемента" + "количество", внутри группы относительные номера. Переменной 100 байт, X – адрес первого, адреса у байтов: X+0, X+1, X+2, X+99.

ссылочные (не примитивные) типы являются объектами.

**null** - не тип, а значение по умолчанию ТОЛЬКО для **ссылочных типов**, у которых не инициализировано значение.
Переменная примитивного типа всегда должна иметь значение, не может быть null.

### Приведение типов

```java
var n = Integer.parseInt("345"); // строка это объект поэтому её преобразуем методом?
var res = (int) 5.1; // для примитивных типов
```

Java статически типизированные - тип переменной устанавливается при определении и не может измениться.
в Java сильная, статическая типизация. в коробку для числа засунуть текст — вставить вилку в USB-разъём.
String name = 5 + 5 + "1" + a; // "1015"

**Сильная — слабая**
язык сам приводят типы - слабой (нестрогой) типизацией. в выражении переменные любых типов и не беспокоиться об их приведении.
print("12" + 13) // 1213
print(12 + "13") // 25

язык требуют явно определить, что делать с данными, чтобы перевести их в другой тип. сильной (строгой) типизацией.
print("12" + 13) // Ошибка!
print("12" + toString(13)) // 1213
print(toNumber("12") + 13) // 25

Компилятор проверяет типы без запуска кода - статическая типизация. Синтаксические ошибки находятся во время компиляции, до запуска программы.
В динамических языках переменная может изменить тип во время выполнения программы.

**Статическая — динамическая**
В статически типизированном языке тип переменной известны на этапе написания кода и не может измениться во время выполнения. 
присвоить переменной одного типа значение другого - ошибка, найти без запуска программы.
number age = 44
age = "Not so old" // Ошибка

Динамически типизированные язык. тип меняться по ходу исполнения программы.
age = 44 
age = "Not so old"

### Размер в памяти

byte 1 байт	-128 до 127
short 2 байта	-32 768 до 32 767
int* 4 байта	-2 147 483 648 до 2 147 483 647
long 8 байт	-9 223 372 036 854 775 808 до 9 223 372 036 854 775 807 ≈ −9.22 × 10^18 ... ≈ 9.22 × 10^18 10000000000L

float (floating-point number — число с плавающей точкой) 4 байта 3.14f низкая, одинарная точность (7 знаков после запятой)
double* 8 байт	-1.7E+308 высокая, двойная точность (16 знаков после запятой)

boolean 1 бит

char — 16-битное число (0 - 65535), значению соответствует символ. За символом числовой код (стандарт Unicode - символы со всего мира).

символ внутри — число, преобразовывать char в int и обратно.

```java
int code = 'A';
System.out.println("Код символа 'A':" + " + code); // Код символа 'A': 65

char ch = (char) 1040;
System.out.println("Символ с кодом 1040: " + ch); // Символ с кодом 1040: А
```

### double

String.format("%.2f", 23.56789); // 23.57
String.format("%.1f%n", 23.56789); // 23.6

double result = 7 / 2; // деление двух int — int-результат 3.0
double result = (double) 7 / 2; // 3.5

Компьютеры работают с числами в двоичной системе. 1/3 нельзя точно записать десятичной дробью 0.333. 0.1 в двоичной системе — бесконечная дробь, и её "округлять" для хранения.
double хранит лишь близкое приближённое значение.

```java
0.1 + 0.2; // 0.30000000000000004 компьютер многие числа не может точно представить в двоичной системе.
```

сравнивать модуль разности чисел с маленьким числом (с допуском epsilon).

```java
double epsilon = 0.000001;

if (Math.abs((0.1 + 0.2) - (0.3)) < epsilon) {
    System.out.println("Почти равно!");
}

double rounded = Math.round(3.14159 * 100.0) / 100.0; // 3.14 Умножаем на 100 (два знака). Округляем до целого Math.round. Делим обратно на 100.0
Math.round(314.159) = 314

import java.text.DecimalFormat;

DecimalFormat df = new DecimalFormat("#,##0.00"); разделители тысяч  12345.678  12,345.68
df.format(1234567.89); // 1,234,567.89

String.format("%.2f", 3.14159); // 3.14 форматировать строки
```

символ в Java — число из таблицы Unicode.
```java
int big = 300;
byte small = (byte) big; // 44 byte от -128 до 127, число не помещается — "обрезание" по модулю 256 (остаток от деления).
```
