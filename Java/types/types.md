### Память

программа перед выполнением загружается в оперативную память. В ней находится код программы - исполняется процессором и её данные - в память помещает сама программа.

Программа и её данные во время работы хранятся в памяти. память компьютера представлена в виде ячеек – байт. У ячейки уникальный номер – 0, 1, 2, 3, ... (нумерация с нуля) - адрес. Зная номер ячейки, можем сохранить в эту ячейку данные. взять их из неё. В ячейках хранится код программы – набор команд для процессора, в других ячейках – данные программы.

Процессор умеет исполнять команды из загруженной в память программы. Почти все команды процессора — взять данные из некоторых ячеек → сделать с ними что-то → результат поместить в другие ячейки.
Объединяя сотни простых команд, получаем сложные и полезные.

Когда выполнение программы доходит до команды создания переменной, ей выделяется область не использованной памяти (несколько байт) размером, в зависимости от типа переменной. При объявлении переменной указать тип. Без знания типа информации не ясно, какого размера блок памяти выделить под переменную.

программы работали с номерами ячеек памяти, но потом ячейкам стали давать имена (имя переменной).

byte  1  занимает один байт памяти
short  2  Short Integer
int  4
long  8  Long Integer

float  4  Floating Point Number
double  8  Double Float

Адрес переменной - адрес первой ячейки выделенного под неё блока памяти.
Java-программам запрещено напрямую обращаться к памяти - только через Java-машину.


Объект String хранить большие объёмы данных.
Данные типа String (текст) помещаются в спец объект, под который выделяется память, адрес объекта помещается в переменную, под которую выделяется память.

<img width="1024" height="564" alt="image" src="https://github.com/user-attachments/assets/bb2131ae-f11a-41b7-af21-78b0de8efdb2" />

b int 4 байта и хранит значение 10,555. Запятая — не дробная часть числа, а разделение разрядов.
str String значение D12 — адрес первой ячейки объекта, содержащего текст.
Объект типа String (содержащий текст) хранится отдельным блоком памяти. Адрес его первой ячейки хранится в переменной str.

int a = 10;
int b = a; // копируется значение 10, а не "ящик".
b = 20; // Изменения в b не влияют на a.
System.out.println(a); // 10
В памяти создаются две ячейки: для a, для b.

String s1 = "Hello";
String s2 = s1;
s2 = s2 + " World";
s1 и s2 ссылаются на одну и ту же строку "Hello" до момента изменения. s2 = s2 + " World"; для s2 создаётся новая строка "Hello World", а s1 смотрит на старую строку "Hello".


Группу как "номер первого элемента" + "количество", внутри группы относительные номера +0, +1, +2, ...
Переменной выделили 100 байт, X – адрес первого байта, адреса у байтов? X+0, X+1, X+2, ..., X+99.


Все ссылочные (не примитивные) типы являются объектами.

Java статически типизированные - тип переменной устанавливается при определении и не может измениться.

Компилятор проверяет типы без запуска кода - статическая типизация.
В динамических языках переменная может изменить тип во время выполнения программы.

Синтаксические ошибки находятся во время компиляции, до запуска программы.

Целочисленное деление:
3 / 2 = 1 

**null** - не тип, а значение по умолчанию ТОЛЬКО для **ссылочных типов**, у которых не инициализировано значение.
Переменная примитивного типа всегда должна иметь значение, не может быть null.

### Приведение типов

```java
var n = Integer.parseInt("345"); // строка это объект поэтому её преобразуем методом?
var res = (int) 5.1; // для примитивных типов
```

Неявное преобразование типов - типы совместимы и нет потери точности - тип меньше по размеру чем результирующий

в Java сильная, статическая типизация — строго типизированный язык. в коробку для числа засунуть текст — вставить вилку в USB-разъём.
String name = 5 + 5 + "1" + a; // "1015"

**Сильная — слабая**
язык сам приводят типы - слабой (нестрогой) типизацией. в выражении переменные любых типов и не беспокоиться об их приведении.
print("12" + 13) // 1213
print(12 + "13") // 25

язык требуют явно определить, что делать с данными, чтобы перевести их в другой тип. сильной (строгой) типизацией.
print("12" + 13) // Ошибка!
print("12" + toString(13)) // 1213
print(toNumber("12") + 13) // 25

**Статическая — динамическая**
В статически типизированном языке тип переменной известны на этапе написания кода и не может измениться во время выполнения. 
присвоить переменной одного типа значение другого - ошибка, найти без запуска программы.
number age = 44
age = "Not so old" // Ошибка

Динамически типизированные язык. тип меняться по ходу исполнения программы.
age = 44 
age = "Not so old"

### Размер в памяти

1 байт = 8 бит

byte 1 байт	-128 до 127
short 2 байта	-32 768 до 32 767
int* 4 байта	-2 147 483 648 до 2 147 483 647
long 8 байт	-9 223 372 036 854 775 808 до 9 223 372 036 854 775 807 ≈ −9.22 × 10^18 ... ≈ 9.22 × 10^18 10000000000L

float (floating-point number — число с плавающей точкой) 4 байта 3.14f низкая, одинарная точность (7 знаков после запятой)
double* 8 байт	-1.7E+308 высокая, двойная точность (16 знаков после запятой)

boolean 1 бит

char — 16-битное число (0 - 65535), значению соответствует символ. За символом числовой код (стандарт Unicode - символы со всего мира).

символ внутри — число, преобразовывать char в int и обратно.

```java
int code = 'A';
System.out.println("Код символа 'A':" + " + code); // Код символа 'A': 65

char ch = (char) 1040;
System.out.println("Символ с кодом 1040: " + ch); // Символ с кодом 1040: А
```

### double

String.format("%.2f", 23.56789); // 23.57
String.format("%.1f%n", 23.56789); // 23.6

double result = 7 / 2; // деление двух int — int-результат 3.0
double result = (double) 7 / 2; // 3.5

Компьютеры работают с числами в двоичной системе. 1/3 нельзя точно записать десятичной дробью 0.333. 0.1 в двоичной системе — бесконечная дробь, и её "округлять" для хранения.
double хранит лишь близкое приближённое значение.

```java
0.1 + 0.2; // 0.30000000000000004 компьютер многие числа не может точно представить в двоичной системе.
```

сравнивать модуль разности чисел с маленьким числом (с допуском epsilon).
```java
double epsilon = 0.000001;

if (Math.abs((0.1 + 0.2) - (0.3)) < epsilon) {
    System.out.println("Почти равно!");
}
```

в double особые значения. В отличие от деления целых чисел, деление на 0.0 для double не вызывает ошибку, а возвращает Infinity или NaN (Not a Number).
```java
1.0 / 0.0; // Infinity
-1.0 / 0.0; // -Infinity

Math.sqrt(-1); // NaN
0.0 / 0.0; // NaN

Double.isInfinite(result);    // true, если бесконечность
Double.isNaN(result);         // true, если NaN


Math.round(-2.5); // -2
int roundedF = Math.round(5.8f); // 6 int
long roundedD = Math.round(5.8); // 6 long
int rounded = (int) Math.round(5.6); // 6 нужен int явное приведение
```

Умножаем число на 100 (два знака). Округляем до целого Math.round. Делим обратно на 100.0
```java
double rounded = Math.round(3.14159 * 100.0) / 100.0; // 3.14
Math.round(314.159) = 314
```

Создаём объект с шаблоном. Вызываем у него метод format(...)

```java
import java.text.DecimalFormat;

DecimalFormat df = new DecimalFormat("0.00");
df.format(3.14159); // 3.14
```

"0.00" — два знака после запятой
"0.###" — до трёх знаков после запятой, лишние нули не выводятся.
"#,##0.00" — добавляет разделители тысяч ("1,234.56").

"0.###"    2.567	    2.567
"0.###"    2.5	        2.5
"#,##0.00" 12345.678	12,345.68

разделителями тысяч
DecimalFormat df = new DecimalFormat("#,##0.00");
System.out.println(df.format(1234567.89)); // 1,234,567.89

вывод без лишних нулей
DecimalFormat df = new DecimalFormat("0.##");
System.out.println(df.format(3.1));   // 3.1
System.out.println(df.format(3.141)); // 3.14
System.out.println(df.format(3.145)); // 3.15

String.format — форматировать строки, похожий на printf в других языках.

System.out.println(String.format("%.2f", 3.14159)); // 3.14
"%.2f" — «вывести число с двумя знаками после запятой».

DecimalFormat — поддерживает шаблоны и локализацию, для разделителей тысяч.
String.format — задать количество знаков после запятой.

Math.floor(x) — округляет вниз в меньшую сторону, и для отрицательных чисел.
Math.ceil(x) — округляет вверх в большую сторону.
Math.rint(x) — округляет до ближайшего целого, но возвращает double. иногда округляет «к ближайшему чётному» — уменьшать накопление ошибок при массовых вычислениях.

System.out.println(Math.floor(2.7)); // 2.0
System.out.println(Math.ceil(2.1));  // 3.0
System.out.println(Math.rint(2.5));  // 2.0
System.out.println(Math.rint(3.5));  // 4.0

Число	Math.round	Math.floor	Math.ceil	Math.rint
2.3	2	2.0	         3.0	    2.0
2.5	3	2.0	         3.0	    2.0
3.5	4	3.0	         4.0	    4.0
-2.3	-2	        -3.0	   -2.0	        -2.0
-2.5	-2	        -3.0	   -2.0	        -2.0

Округление — изменение значения числа (2.718 → 2.72).
Форматирование — изменение как число выглядит при выводе (2.718 → "2.72" на экране, но в памяти 2.718).

double x = 2.718;
System.out.println(String.format("%.2f", x)); // 2.72
System.out.println(x); // 2.718

округлённое число в дальнейших вычислениях — округляйте математически! Если только для вывода — форматируйте.


Округлили только для вывода, а дальше используем «хвостатое» число.
вывести красиво отформатированное значение на экран, а затем использовать исходное «длинное» число в расчётах. Для денег, баллов и итогов — сначала округлите (Math.round или приём с умножением/делением), затем сохраняйте/передавайте пользователю.

Math.round(x) вернёт double с двумя знаками после запятой.
Math.round() всегда округляет до ближайшего целого: для float возвращает int, для double — long. Для двух знаков умножение/деление или форматирование.

DecimalFormat для вычислений.
DecimalFormat.format() возвращает строку. Использовать её в арифметике нельзя: ошибку компиляции или NumberFormatException при обратном разборе.

Неправильный шаблон DecimalFormat.
Шаблон соответствовать ожиданиям: "0.00" всегда покажет два знака ("2.00"), а "0.##" уберёт лишние нули ("2", "2.1", "2.12").

Потеря точности при делении на 100.
делите int на int, результат тоже int!

int a = 5;
System.out.println(a / 2); // 2, не 2.5

деление было «дробным», хотя бы один операнд double
int a = 5;
System.out.println(a / 2.0); // 2.5



В Java (как и в других языках) переменные имеют строгий тип — переменная int, хранить только целые числа, double — только числа с плавающей точкой. 
"переложить" значение из одной переменной в другую с другим типом.

Получили из метода int, использовать его как double для вычислений с дробями.
Храним код символа как число (int), получить сам символ (char).
результат вычислений в double, нужен целый результат (int), вывести количество целых яблок.

Неявное приведение —  Java преобразует значение из одного типа в другой, если это безопасно и не приводит к потере данных.
присваиваете значение меньшего типа переменной большего.
```java
int apples = 5;
double applesWeight = apples; // 5.0 int автоматически становится double
```
символ в Java — число из таблицы Unicode. преобразование char в int происходит автоматически:
```java
char letter = 'A';
int code = letter; // 'A' превращается в 65 (код символа в Unicode)
```

Откуда	Куда можно неявно
byte - short, int, long, float, double
short - int, long, float, double
char - int, long, float, double
int - long, float, double
long - float, double
float - double

Неявное преобразование работает только в сторону «расширения» (от меньшего к большему).

Явное приведение (type casting), преобразовать значение из большего типа в меньший или между несовместимыми типами. осознаёте возможную потерю данных.

```java
double price = 12.99;
int roundedPrice = (int) price; // 12 Для округления Math.round().

int code = 66;
char letter = (char) code; // 'B'

double d = 3.1415926535;
float f = (float) d; // 3.1415927 часть точности теряется
```

символы (char) — числа из таблицы Unicode. их преобразовывать в int и наоборот.

```java
char ch = 'Ж';
int code = ch; // 1046

int code = 8364;
char symbol = (char) code; // €

for (int i = 65; i < 65 + 26; i++) {
    System.out.print((char) i + " ");
}
// A B C D ... Z
```

int → double (неявно)

```java
int count = 10;
double avg = count; // 10.0 неявное расширение


double → int (явно)

double score = 8.75;
int rounded = (int) score; // 8

double price = 8.75;
int rounded = (int) Math.round(price); // 9 округлить до ближайшего целого
```

при "сужении" типа? Потеря данных
```java 
int big = 300;
byte small = (byte) big; // 44 byte от -128 до 127, число не помещается — "обрезание" по модулю 256 (остаток от деления).

double d = 1e20;
int i = (int) d; // -2147483648 (мин значение int)

int a = 3;
double b = 2.5;
double result = a + b; // 5.5 int станет double

char ch = 'A'; // 65
int offset = 2;
char next = (char) (ch + offset); // C char станет int

int x = 123;
String s = Integer.toString(x); // или: String s = "" + x;

String s = "456";
int x = Integer.parseInt(s);
```

Потеря дробной части при double → int. (int) 3.99 даст 4. результат — 3, дробная часть отбрасывается.
Неявное "сужение" не работает. Нельзя написать int x = 300; byte b = x; — компилятор ошибку. явно указать (byte) x, число больше диапазона byte.
Преобразование между несовместимыми типами. Нельзя написать (int) "123" — строку в число через Integer.parseInt().
Преобразование int в char только для значений, которые существуют в Unicode. передать большое число, результат неожиданным символом.
Смешанные типы в выражениях. выражение содержит int и double, результат double.
Округление — не приведение типа! (int) x — не округление, а отбрасывание дробной части.
