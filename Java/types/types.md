### Конвертация типов

Java — строго типизированный язык. у компьютера “коробочка” для числа, засунуть туда текст — вставить вилку в USB-разъём.

Компилятор не умеет автоматически преобразовывать строку в число, Нужно привести строку к числу явно.
все переменные, объекты, выражения в Java можно преобразовать к типу String. автоматически происходит, когда складываем тип String с другим типом.

Операция сложения выполняется слева направо:
int a = 5;
String name = a + a + "1" + a; // строку 1015
Порядок выполнения: ((a + a) + "1") + a


### Память

программа перед выполнением загружается в оперативную память. В ней находится код программы - исполняется процессором и её данные - в память помещает сама программа.

Программа и её данные во время работы хранятся в памяти. память компьютера представлена в виде ячеек – байт. У ячейки уникальный номер – 0, 1, 2, 3, ... (нумерация с нуля) - адрес. Зная номер ячейки, можем сохранить в эту ячейку данные. взять их из неё. В ячейках хранится код программы – набор команд для процессора, в других ячейках – данные программы.

Процессор умеет исполнять команды из загруженной в память программы. Почти все команды процессора — взять данные из некоторых ячеек → сделать с ними что-то → результат поместить в другие ячейки.
Объединяя сотни простых команд, получаем сложные и полезные.

Когда выполнение программы доходит до команды создания переменной, ей выделяется область не использованной памяти (несколько байт) размером, в зависимости от типа переменной. При объявлении переменной указать тип. Без знания типа информации не ясно, какого размера блок памяти выделить под переменную.

программы работали с номерами ячеек памяти, но потом ячейкам стали давать имена (имя переменной).

byte  1  занимает один байт памяти
short  2  Short Integer
int  4
long  8  Long Integer

float  4  Floating Point Number
double  8  Double Float

Адрес переменной - адрес первой ячейки выделенного под неё блока памяти.
Java-программам запрещено напрямую обращаться к памяти - только через Java-машину.


Объект String хранить большие объёмы данных.
Данные типа String (текст) помещаются в спец объект, под который выделяется память, адрес объекта помещается в переменную, под которую выделяется память.

<img width="1024" height="564" alt="image" src="https://github.com/user-attachments/assets/bb2131ae-f11a-41b7-af21-78b0de8efdb2" />

b int 4 байта и хранит значение 10,555. Запятая — не дробная часть числа, а разделение разрядов.
str String значение D12 — адрес первой ячейки объекта, содержащего текст.
Объект типа String (содержащий текст) хранится отдельным блоком памяти. Адрес его первой ячейки хранится в переменной str.

int a = 10;
int b = a; // копируется значение 10, а не "ящик".
b = 20; // Изменения в b не влияют на a.
System.out.println(a); // 10
В памяти создаются две ячейки: для a, для b.

String s1 = "Hello";
String s2 = s1;
s2 = s2 + " World";
s1 и s2 ссылаются на одну и ту же строку "Hello" до момента изменения. s2 = s2 + " World"; для s2 создаётся новая строка "Hello World", а s1 смотрит на старую строку "Hello".


Группу как "номер первого элемента" + "количество", внутри группы относительные номера +0, +1, +2, ...
Переменной выделили 100 байт, X – адрес первого байта, адреса у байтов? X+0, X+1, X+2, ..., X+99.


Все ссылочные (не примитивные) типы являются объектами.

Java статически типизированные - тип переменной устанавливается при определении и не может измениться.

Компилятор проверяет типы без запуска кода - статическая типизация.
В динамических языках переменная может изменить тип во время выполнения программы.

Синтаксические ошибки находятся во время компиляции, до запуска программы.

Целочисленное деление:
3 / 2 = 1 

**null** - не тип, а значение по умолчанию ТОЛЬКО для **ссылочных типов**, у которых не инициализировано значение.
Переменная примитивного типа всегда должна иметь значение, не может быть null.

### Приведение типов

```java
var n = Integer.parseInt("345"); // 345
var res = (int) 5.1; // 5 for conversion between primitive types
```

Implicit type conversion
Some conversion can be automatically happen if in one expression participate different types - for it need that type be compatible beside each other and dimension conversioned types was equal or lower than result type.

```java
var a true;
// Error: incompatible types: int cannot be converted to boolean
a = 1;

short a = 5; // 2 bytes in memory
int sum = a + 1; // 4 bytes now

// Loss of accuracy:
int a = 5;
// Error: incompatible types: possible lossy conversion from int to short
short sum = a + 2;

var a = 10;
var res = "Number: " + a; // Number: 10 - 10 to String representation
```



**Сильная — слабая**
системы типов делятся по способу приведения типов - превращение данных одного типа в данные другого типа. «12» превратить в 12:
number age = toNumber("12")

Некоторые языки сами приводят типы, скрыто от программиста - слабой (или нестрогой) типизацией. в одном выражении использовать переменные любых типов и не беспокоиться об их приведении.
print("12" + 13) // 1213
print(12 + "13") // 25

языки, которые требуют явно определить, что следует делать с данными, чтобы перевести их в другой тип. отдают эту работу программисту - сильной (или строгой) типизацией.
print("12" + 13) // Ошибка!
print("12" + toString(13)) // 1213
print(toNumber("12") + 13) // 25

**Статическая — динамическая**
В статически типизированном языке каждая переменная имеет определенный тип на всем протяжении жизни, он не может измениться во время выполнения. все типы известны ещё на этапе написания кода. Если же во время выполнения попытаться присвоить переменной одного типа значение другого типа, произойдет ошибка. такие ошибки можно найти без запуска программы.
number age = 44
age = "Not so old" // Ошибка!

Динамически типизированные языки у каждой переменной всё ещё есть тип. Но он может меняться по ходу исполнения программы. в конкретный момент времени мы достоверно не знаем, данные какого типа находятся в переменной.
age = 44 // Тип переменной — число
age = "Not so old" // Тип переменной — строка

Java — сильная статическая

1 байт = 8 бит

byte 1 байт	-128 до 127
short 2 байта	-32 768 до 32 767
int* 4 байта	-2 147 483 648 до 2 147 483 647
long 8 байт	-9 223 372 036 854 775 808 до 9 223 372 036 854 775 807 ≈ −9.22 × 1018 ... ≈ 9.22 × 1018

float (floating-point number — число с плавающей точкой) 4 байта	3.14f	низкая, одинарная точность (7 знаков после запятой)
double* 8 байт	-1.7E+308	высокая, двойная точность (16 знаков после запятой)

boolean 1 бит

явно указать, какой тип использовать для числа. не указать суффикс, целое число int, а дробное — double.
L или l — типа long (10000000000L) // если убрать L, ошибка компиляции
F или f — типа float (3.14f)
D или d — типа double (не нужен, дробные числа без суффикса по дефолту — double)


Тип char для хранения одного символа: буквы, цифры, знака препинания, пробела, спецсимвола и смайлика. Значение типа char в одиночных кавычках.
За каждым символом скрывается числовой код (стандарт Unicode - символы со всего мира). хранить латинские буквы, кириллицу, иероглифы, эмодзи и древнеегипетские иероглифы.
Тип char — 16-битное число (от 0 до 65535), каждому значению соответствует свой символ.

каждый символ внутри — число, преобразовывать char в int и обратно. узнать Unicode-код символа

```java
char ch = 'A';
int code = ch; // Неявное преобразование char → int
System.out.println("Код символа '" + ch + "': " + code); // Код символа 'A': 65

int code = 1040; // Код буквы 'А' в Юникоде (кириллица)
char ch = (char) code; // Явное преобразование int → char
System.out.println("Символ с кодом " + code + ": " + ch); // Символ с кодом 1040: А
```


double d = 3; не получите ошибку — типы автоматически приведутся (целое число превращается во "вещественное" без потерь).

Scanner.nextDouble() ориентируется на локаль: в русской локали запятая допустима, в английской — точка. настройте локаль для Scanner или читайте строку и парсьте вручную.

System.out.println(0.1 + 0.2); //0.30000000000000004 // компьютер многие числа не может точно представить в двоичной системе.


int ii = (int) 3.7; // 3 - явно привести double к int

System.out.println(String.format("%.2f", 23.56789)); // 23.57
System.out.println(String.format("%.1f%n", 23.56789)); // 23.6

неявное преобразование double в float
float f = 1.23; // Ошибка! положить double в float — может привести к потере точности! добавляй суффикс f.


double result = 7 / 2; // деление двух int — int-результат 3.0
double result = (double) 7 / 2; // 3.5

Не сравнивай дробные с ==, сравнивай с небольшим допуском (epsilon).



представлении чисел в памяти
Компьютеры работают с числами в двоичной системе. не все десятичные дроби представить конечной двоичной дробью, 1/3 нельзя точно записать десятичной дробью (0.333...). 0.1 в двоичной системе — бесконечная дробь, и её приходится "округлять" для хранения.
double иногда "делает вид", что хранит число точно, но хранит лишь близкое приближённое значение.
```java
double sum = 0.1 + 0.2;
System.out.println(sum);            // 0.30000000000000004
System.out.println(sum == 0.3);     // false

double result = 0;
for (int i = 0; i < 10; i++)
{
    result += 0.1;
}
System.out.println(result); // 0.9999999999999999
```

банк складывает 100 транзакций по 0.1 евро. программа "теряет" по одной стотысячной евро на итерацию, "потеряете" деньги. накопления ошибок округления.

double не может хранить значение, которое ожидаете, прямое сравнение == подвести. сравнивать модуль разности чисел с маленьким числом (epsilon). сравнения с допуском (epsilon).
```java
double a = 0.1 + 0.2;
double b = 0.3;
double epsilon = 0.000001;

if (Math.abs(a - b) < epsilon)
{
    System.out.println("Почти равно!"); // Так сравнивать безопаснее
}
```
"Если разница между числами меньше, чем одна миллионная, считаем, что числа равны".

double хранит не только числа, но и особые значения.
деление на 0 для double не вызывает исключения! В отличие от деления целых чисел, деление на 0.0 для double не вызывает ошибку, а возвращает Infinity или NaN. результат есть, но он не такой, как ожидали.
NaN ("Не число" (NaN — Not a Number)) — "всё, что не являлось числом в жизни".
```java
double result = 1.0 / 0.0; // Infinity
double result = -1.0 / 0.0; // -Infinity

double result = Math.sqrt(-1); // NaN
double result = 0.0 / 0.0; // NaN

System.out.println(Double.isInfinite(result));    // true, если бесконечность
System.out.println(Double.isNaN(result));         // true, если NaN
```

NaN как "специальное" значение для проверки, "если не найдено — вернём NaN". NaN сравнение через == не сработает!
Double.isNaN();
Double.isInfinite();


округлить число до ближайшего целого Math.round()
дробная часть меньше 0.5 — округляет вниз.
дробная часть 0.5 или больше — округляет вверх.

Если передать float, вернётся int.
Если передать double, вернётся long.
```java
System.out.println(Math.round(-2.5)); // -2

float f = 5.8f;
int roundedF = Math.round(f); // 6

double d = 5.8;
long roundedD = Math.round(d); // 6

int rounded = (int) Math.round(5.6); // 6 Если нужен int явное приведение
```

Умножаем число на 100 (если нужно два знака). Округляем до целого Math.round. Делим обратно на 100.0
```java
double rounded = Math.round(3.14159 * 100.0) / 100.0; // 3.14

3.14159 * 100 = 314.159
Math.round(314.159) = 314
314 / 100.0 = 3.14
```

знаков после запятой, ведущими нулями, разделителями разрядов.

Создаём объект с шаблоном. Вызываем у него метод format(...)

```java
import java.text.DecimalFormat;

double value = 3.14159;

DecimalFormat df = new DecimalFormat("0.00");
System.out.println(df.format(value)); // 3.14
```

"0.00" — всегда два знака после запятой (даже если число целое).
"0.###" — до трёх знаков после запятой, лишние нули не выводятся.
"#,##0.00" — добавляет разделители тысяч ("1,234.56").

"0.00"     2	        2.00
"0.00"     2.5	        2.50
"0.00"     2.567	    2.57
"0.###"    2.567	    2.567
"0.###"    2.5	        2.5
"#,##0.00" 12345.678	12,345.68

разделителями тысяч
DecimalFormat df = new DecimalFormat("#,##0.00");
System.out.println(df.format(1234567.89)); // 1,234,567.89

вывод без лишних нулей
DecimalFormat df = new DecimalFormat("0.##");
System.out.println(df.format(3.1));   // 3.1
System.out.println(df.format(3.141)); // 3.14
System.out.println(df.format(3.145)); // 3.15

String.format — форматировать строки, похожий на printf в других языках.

System.out.println(String.format("%.2f", 3.14159)); // 3.14
"%.2f" — «вывести число с двумя знаками после запятой».

DecimalFormat — поддерживает шаблоны и локализацию, для разделителей тысяч.
String.format — задать количество знаков после запятой.

Math.floor(x) — округляет вниз в меньшую сторону, и для отрицательных чисел.
Math.ceil(x) — округляет вверх в большую сторону.
Math.rint(x) — округляет до ближайшего целого, но возвращает double. иногда округляет «к ближайшему чётному» — уменьшать накопление ошибок при массовых вычислениях.

System.out.println(Math.floor(2.7)); // 2.0
System.out.println(Math.ceil(2.1));  // 3.0
System.out.println(Math.rint(2.5));  // 2.0
System.out.println(Math.rint(3.5));  // 4.0

Число	Math.round	Math.floor	Math.ceil	Math.rint
2.3	2	2.0	         3.0	    2.0
2.5	3	2.0	         3.0	    2.0
3.5	4	3.0	         4.0	    4.0
-2.3	-2	        -3.0	   -2.0	        -2.0
-2.5	-2	        -3.0	   -2.0	        -2.0

Округление — изменение значения числа (2.718 → 2.72).
Форматирование — изменение как число выглядит при выводе (2.718 → "2.72" на экране, но в памяти 2.718).

double x = 2.718;
System.out.println(String.format("%.2f", x)); // 2.72
System.out.println(x); // 2.718

округлённое число в дальнейших вычислениях — округляйте математически! Если только для вывода — форматируйте.


Округлили только для вывода, а дальше используем «хвостатое» число.
вывести красиво отформатированное значение на экран, а затем использовать исходное «длинное» число в расчётах. Для денег, баллов и итогов — сначала округлите (Math.round или приём с умножением/делением), затем сохраняйте/передавайте пользователю.

Math.round(x) вернёт double с двумя знаками после запятой.
Math.round() всегда округляет до ближайшего целого: для float возвращает int, для double — long. Для двух знаков умножение/деление или форматирование.

DecimalFormat для вычислений.
DecimalFormat.format() возвращает строку. Использовать её в арифметике нельзя: ошибку компиляции или NumberFormatException при обратном разборе.

Неправильный шаблон DecimalFormat.
Шаблон соответствовать ожиданиям: "0.00" всегда покажет два знака ("2.00"), а "0.##" уберёт лишние нули ("2", "2.1", "2.12").

Потеря точности при делении на 100.
делите int на int, результат тоже int!

int a = 5;
System.out.println(a / 2); // 2, не 2.5

деление было «дробным», хотя бы один операнд double
int a = 5;
System.out.println(a / 2.0); // 2.5



В Java (как и в других языках) переменные имеют строгий тип — переменная int, хранить только целые числа, double — только числа с плавающей точкой. 
"переложить" значение из одной переменной в другую с другим типом.

Получили из метода int, использовать его как double для вычислений с дробями.
Храним код символа как число (int), получить сам символ (char).
результат вычислений в double, нужен целый результат (int), вывести количество целых яблок.

Неявное приведение —  Java преобразует значение из одного типа в другой, если это безопасно и не приводит к потере данных.
присваиваете значение меньшего типа переменной большего.
```java
int apples = 5;
double applesWeight = apples; // 5.0 int автоматически становится double
```
символ в Java — число из таблицы Unicode. преобразование char в int происходит автоматически:
```java
char letter = 'A';
int code = letter; // 'A' превращается в 65 (код символа в Unicode)
```

Откуда	Куда можно неявно
byte - short, int, long, float, double
short - int, long, float, double
char - int, long, float, double
int - long, float, double
long - float, double
float - double

Неявное преобразование работает только в сторону «расширения» (от меньшего к большему).

Явное приведение (type casting), преобразовать значение из большего типа в меньший или между несовместимыми типами. осознаёте возможную потерю данных.

```java
double price = 12.99;
int roundedPrice = (int) price; // 12 Для округления Math.round().

int code = 66;
char letter = (char) code; // 'B'

double d = 3.1415926535;
float f = (float) d; // 3.1415927 часть точности теряется
```

символы (char) — числа из таблицы Unicode. их преобразовывать в int и наоборот.

```java
char ch = 'Ж';
int code = ch; // 1046

int code = 8364;
char symbol = (char) code; // €

for (int i = 65; i < 65 + 26; i++) {
    System.out.print((char) i + " ");
}
// A B C D ... Z
```

int → double (неявно)

```java
int count = 10;
double avg = count; // 10.0 неявное расширение


double → int (явно)

double score = 8.75;
int rounded = (int) score; // 8

double price = 8.75;
int rounded = (int) Math.round(price); // 9 округлить до ближайшего целого
```

при "сужении" типа? Потеря данных
```java 
int big = 300;
byte small = (byte) big; // 44 byte от -128 до 127, число не помещается — "обрезание" по модулю 256 (остаток от деления).

double d = 1e20;
int i = (int) d; // -2147483648 (мин значение int)

int a = 3;
double b = 2.5;
double result = a + b; // 5.5 int станет double

char ch = 'A'; // 65
int offset = 2;
char next = (char) (ch + offset); // C char станет int

int x = 123;
String s = Integer.toString(x); // или: String s = "" + x;

String s = "456";
int x = Integer.parseInt(s);
```

Потеря дробной части при double → int. (int) 3.99 даст 4. результат — 3, дробная часть отбрасывается.
Неявное "сужение" не работает. Нельзя написать int x = 300; byte b = x; — компилятор ошибку. явно указать (byte) x, число больше диапазона byte.
Преобразование между несовместимыми типами. Нельзя написать (int) "123" — строку в число через Integer.parseInt().
Преобразование int в char только для значений, которые существуют в Unicode. передать большое число, результат неожиданным символом.
Смешанные типы в выражениях. выражение содержит int и double, результат double.
Округление — не приведение типа! (int) x — не округление, а отбрасывание дробной части.
