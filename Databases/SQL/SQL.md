varchar(10) -- строк с ограничением макс длины
text -- строк без ограничения.

нельзя оставить первый тип без указания длины. Данные в бд хранятся на дисках в файлах. Быстрый доступ к данным возможен, когда у данных фикс размер. перемещаться по ним и считать смещения. Если размер данных не известен, просматривать весь файл в поисках значения. 
text хранится отдельно. негативно влияет на скорость, но не так сильно.

integer	-2147483648 .. +2147483647
bigint	-9223372036854775808 .. 9223372036854775807
real	вещественное число с переменной точностью	-2147483648 .. +2147483647, точность в пределах 6 десятичных цифр

даты как и строки заключаются в одинарные кавычки

timestamp	дата и время (без часового пояса) - момент времени	4713 до н. э.	294276 н. э.	1 микросекунда
date	    дата (без времени)	4713 до н. э.	5874897 н. э.	1 день
time	    время без даты	00:00:00	24:00:00	1 микросекунда

добавление и заполнение полей created_at и updated_at в каждую таблицу.

1999-01-08	ISO 8601 (рекомендуемый формат)

Первичный ключ (уникально идентифицирует запись в таблице - обеспечить целостность данных) в таблице только один, для него отдельное поле - идентификатор

Помимо типов данных для реальных значений, в базе сущ специальное значение NULL - отсутствие значения.
SELECT * FROM users WHERE birthday IS NOT NULL;


фильтрации строки по шаблону - подстроке, найти. оператор LIKE (NOT LIKE), после которого шаблон.
SELECT id, first_name, last_name, email, birthday FROM users WHERE last_name LIKE 'Sch%';

ILIKE строки без учета регистра


Для работы с регулярными выражениями оператор SIMILAR TO вместо LIKE.

выбрать пользователей, чье имя на 'A' или 'B'.
WHERE first_name SIMILAR TO '[AB]%';

В квадратных скобках допустимые символы, %. пользователей с именами Abigale, Andy, Brayan

найти пользователей, у которых username заканчивается буквой. %[abcdefghijklmnopqrstuvwxyz]. В квадратных скобках символ - для перечисления. записать в квадратных скобках начальный символ, поставить "-" и указать конечный символ, шаблон вернет символ из диапазона от начального до конечного. username заканчивается буквой.

WHERE username SIMILAR TO '%[a-z]';

WHERE email NOT SIMILAR TO '%@%.%';

адреса электронной почты,  национальная зона состоит ровно из двух символов — например, ru, su, io и так далее. исключим зоны, состоящие из трех и более символов — com.

%.[a-z][a-z]. подчеркиванием _ - один символ

WHERE email SIMILAR TO '%@%.__';

пользователей с адресами электронной почты оканчивающимися на 3 символа, добавить еще одно подчеркивание в шаблон:

WHERE email SIMILAR TO '%.___';


% любому количеству любых символов
[] для перечисления символов — [АЕИОУЭЮ]
Дефис - в квадратных скобках перечисление символов — [0-9] соответствует цифре


Операторы ~ и SIMILAR TO в PostgreSQL для выполнения операций поиска по регулярным выражениям.

Оператор ~ для поиска строк, соответствующих регулярному выражению. не входит в стандарт языка SQL и является специфичным для PostgreSQL. поддерживает широкий набор возможностей регулярных выражений.

-- все имена, начинающиеся с буквы "A"
WHERE name ~ '^A';

-- имена, содержащие две буквы "o" подряд
WHERE name ~ 'o{2}';

-- имена, начинающиеся с буквы "a" или "A", игнорируя регистр
WHERE name ~* '^a';

-- все имена, начинающиеся с букв от "A" до "F"
WHERE name ~ '^[A-F]';

-- все имена, начинающиеся с буквы "A"
WHERE name SIMILAR TO 'A%';

-- имена, содержащие две буквы "o" подряд
WHERE name SIMILAR TO '%o{2}%';

-- имена, начинающиеся с буквы "a" или "A", игнорируя регистр
WHERE name SIMILAR TO '(a|A)%';

-- все имена, начинающиеся с букв от "A" до "F"
WHERE name SIMILAR TO '[A-F]%';

-- строки, содержащие слово "John"
WHERE name SIMILAR TO '%\\yJohn\\y%';

\y граница слова, аналогично \b в стандартных регулярках.


приоритет оператора AND выше, чем OR.
Рассматривай NOT как ! отрицание


строки, в которых поле соответствует значению из набора. пользователей с идентификаторами 1, 2 или 5.
WHERE id IN (1, 2, 5);
WHERE first_name IN ('Lionel', 'Lucienne', 'Jennyfer');


отсортировать по нескольким полям.
ORDER BY first_name ASC, created_at DESC;
сначала сортировка по имени. Затем внутри групп с одинаковым именем данные сортируются по created_at.


сортировать данные с NULL. в MySQL NULL впереди при сортировке по возрастанию, в PostgreSQL в конце.
если данные содержат NULL, важно явно указывать, где располагаться значения NULL в результирующем наборе.
ORDER BY created_at ASC NULLS FIRST;
ORDER BY created_at DESC NULLS LAST;


Оператор LIMIT без сортировки не используется.
ORDER BY id LIMIT 10 OFFSET 10;

Пропустит первые 10 записей за счет части OFFSET 10. Возьмет следующие 10 записей.

-- записи с 21 по 30
ORDER BY id LIMIT 10 OFFSET 20;

-- записи с 31 по 40
ORDER BY id LIMIT 10 OFFSET 30;


SELECT course_id FROM course_members ORDER BY course_id;

выбрали идентификаторы всех курсов, на которые записался хотя бы один студент. некоторые идентификаторы курсов повторяются — на них записалось по несколько студентов.

оператор DISTINCT, удаляет повторяющиеся строки запроса и оставляет только уникальные.

SELECT DISTINCT course_id FROM course_members ORDER BY course_id;

из этого запроса исключены все повторяющиеся строки.

исключить повторяющиеся строки, нужно после оператора SELECT указать DISTINCT и перечислить все нужные столбцы.

добавим еще одно поле user_id, изменит результат запроса. В эту выборку попадут строки с уникальным сочетанием курса и слушателя.

По отдельности курсы и слушатели могут повторяться, но их сочетание будет уникальным:

-- DISTINCT добавляется в запрос только один раз,
-- независимо от того, сколько колонок перечисляется
SELECT DISTINCT
    course_id,
    user_id
FROM course_members ORDER BY course_id;

выбрать уникальные курсы и добавить дату, когда на него записался первый студент.

после DISTINCT укажем course_id и created_at. Он вернет нам уникальные сочетания этих двух полей:

SELECT DISTINCT course_id, created_at FROM course_members ORDER BY course_id;

модификация оператора DISTINCT ON.
Поле, которое должно быть уникальным.
Поля, которые нужно вывести.

SELECT DISTINCT ON (course_id)
    course_id,
    created_at
FROM course_members
ORDER BY course_id, created_at;

После DISTINCT ON в скобках поле, по которому проверяться уникальность. перечисляем те поля, которые видеть в запросе.
идентификаторы курсов не повторяются, а в качестве created_at выводится первая дата выбора курса.

В DISTINCT ON можно указывать несколько полей в качестве уникальных:

SELECT DISTINCT ON (course_id, created_at)
    course_id,
    created_at
FROM course_members
ORDER BY course_id;

равносилен первому запросу этого раздела:

SELECT DISTINCT
    course_id,
    created_at
FROM course_members ORDER BY course_id;
Сортировка с оператором DISTINCT ON

При работе с DISTINCT ON правильно использовать сортировку. Первыми полями в ORDER BY должны быть те, которые идут после DISTINCT ON.

к каждому уникальному курсу выведем дату, в которую записался последний студент.
после ORDER BY сначала указать поле course_id, как того требует синтаксис. добавить поле created_at с сортировкой по убыванию:

SELECT DISTINCT ON (course_id)
    course_id,
    created_at
FROM course_members
ORDER BY course_id, created_at DESC;

все уникальные курсы и дату, когда на этот курс в последний раз записывались.




количество строк, в которых поле НЕ равно NULL.

SELECT COUNT(id) FROM users;

99 — количество строк, id которых не равен NULL.

SELECT COUNT(email_confirmed) FROM users;

0, в таблице поле email_confirmed не содержит данных.

COUNT возвращает количество записей в запросе, а не в таблице:
SELECT COUNT(*) FROM users WHERE gender = 'female';

количество девушек среди всех пользователей.


SELECT SUM(spent_minutes) FROM course_reviews;
суммарное время, проведенное всеми пользователями на онлайн-курсах.


среднее время, проведенное пользователем с id = 9 на площадке онлайн-школы:
SELECT AVG(spent_minutes) FROM course_reviews WHERE user_id = 9;

максимальное время прохождения курса:
SELECT MAX(spent_minutes) FROM course_reviews;

в функции MAX и MIN можно передавать поля числовых типов, даты и строки. Для строк минимальное значения — первая строки, по алфавиту:
SELECT MIN(username) FROM users;
пользователя Abelardo58, потому что он идет первым по алфавиту.

SELECT MAX(username) FROM users;
пользователя Zoey24, потому что он идет по алфавиту последним.


количество курсов, на которые записался каждый пользователь.
выберем уникальных пользователей в таблице course_members:
SELECT DISTINCT user_id
FROM course_members
ORDER BY user_id;

для каждого пользователя подсчитаем количество курсов.
SELECT COUNT(*) FROM course_members WHERE user_id = 2;

Группировка данных позволяет объединить одинаковые значения в заданных полях в группы, а затем выполнять подсчеты для каждой группы.
Запрос с подсчетом курсов каждого пользователя будет выглядеть так:

SELECT
    user_id,
    COUNT(*)
FROM course_members
GROUP BY user_id
ORDER BY user_id;

Мы могли бы создавать по отдельному запросу для каждого пользователя, но вместо этого использовали конструкцию GROUP BY user_id. объединить строки с одинаковыми идентификаторами user_id, вывести идентификатор и количество строк в каждой группе COUNT(*).

SELECT
    user_id AS student,
    COUNT(*) AS courses_count
FROM course_members
GROUP BY user_id
ORDER BY user_id;

присвоить столбцу псевдоним, нужно после его определения записать AS и указать желаемое имя. Оно должно начинаться с буквы и не должно содержать пробелов.

SELECT
    user_id AS student,
    created_at,
    COUNT(user_id) AS courses_count
FROM course_members
GROUP BY user_id
ORDER BY user_id;
Запрос завершится с ошибкой:

Query Error: error: column "course_members.created_at" must appear in the GROUP BY clause
or be used in an aggregate function
СУБД не понимает, что делать со столбцом created_at — либо он должен быть в конструкции GROUP BY, либо к нему надо применить агрегатную функцию.

группировка обращается к записям в таблице. Она создает из них независимые группы записей, по которым проводится анализ.

При работе с группой мы можем выбрать один из двух вариантов:

Либо вывести поле, по которому проводим группировку. Его значение одинаковым для группы
Либо применить к полю какую-либо агрегатную функцию — например, COUNT(), MAX(), MIN() или AVG(). СУБД будет знать, как обработать несколько разных значений.
Вернемся к примеру выше. В своем запросе мы не группируем данные по столбцу created_at — это не то, что нам нужно. работать с группами, в которых совпадают идентификатор пользователя и дата создания.

не указали никакой агрегатной функции для этого столбца. СУБД не понимает, что сделать с группой разных дат создания. посчитать среднее? взять максимальную дату?

максимальное значение поля created_at для группы. Это будет дата последней регистрации пользователя на курс:

SELECT
    user_id AS student,
    COUNT(user_id) AS courses_count,
    MAX(created_at) AS last_reg
FROM course_members
GROUP BY user_id
ORDER BY user_id;

<img width="2001" height="1908" alt="image" src="https://github.com/user-attachments/assets/e9e02551-7634-4146-8ef5-c4ca948f9449" />

оператор GROUP BY. объединять одинаковые записи в группы и считать для этих групп агрегатные функции.

поля, которые вы будете выводить в запросе, нужно указывать в операторе GROUP BY или применять к ним агрегатную функцию.

отфильтровать записи после группировки.

вывести суммарное время, проведенное на платформе каждым пользователем:

SELECT
  user_id,
  SUM(spent_minutes)
FROM course_reviews
GROUP BY user_id
ORDER BY user_id;


Подобные условия невозможно задать с помощью WHERE, потому что они применяются к выборке до момента группировки. задать условие на результат агрегатной функции после проведения группировки.


HAVING условия на строки выборки после группировки данных.

найти пользователей, которые потратили менее 30 минут в онлайн-школе. Для этого напишем такой запрос:

SELECT
    user_id,
    SUM(spent_minutes)
FROM course_reviews
GROUP BY user_id
HAVING SUM(spent_minutes) < 30
ORDER BY user_id;

искать пользователей мы будем только среди первых 40 человек. Для этого добавим условие user_id <= 40:

SELECT
    user_id,
    SUM(spent_minutes)
FROM course_reviews
WHERE user_id <= 40
GROUP BY user_id
HAVING SUM(spent_minutes) < 30
ORDER BY user_id;

Условия в HAVING проверяются после группировки, поэтому они задаются после предложения GROUP BY. условий WHERE, применяются к строкам исходной таблицы до группировки.

убрали из исходной таблицы всех пользователей с user_id > 40, затем провели группировку и посчитали суммарное время, а после этого отсеяли тех, кто пользовался платформой дольше 30 минут.

добавить условие на user_id и в HAVING и получили бы тот же результат:

SELECT
    user_id,
    SUM(spent_minutes)
FROM course_reviews
GROUP BY user_id
HAVING SUM(spent_minutes) < 30 AND user_id <= 40
ORDER BY user_id;

запрос выполняться дольше, особенно если таблицы большими. сперва исключить ненужных пользователей, сгруппировать уже отфильтрованные данные и затем посчитать агрегатные функции.

задавать условия на значение полей после группировки и применения агрегатных функций. как отфильтровать строки в сгруппированных данных с помощью HAVING.

условия через WHERE, они применяются к строкам исходной таблицы до группировки данных. Поэтому WHERE записывается до GROUP BY
условия через HAVING, они проверяются уже после группировки данных и записываются после предложения GROUP BY

INSERT INTO users (username, email, first_name, last_name, birthday, gender, id, created_at, password_digest)
VALUES ('AgentJ', 'wsmith09@gmail.com', 'Will', 'Smith', '1968-09-25', 'male', 100, '2023-05-01', '11111');

На первой строке мы написали оператор INSERT INTO, указали имя таблицы, а далее в скобках перечислили поля таблицы, в которые будем добавлять значения.

На второй строке мы написали ключевое слово VALUES, а после него в круглых скобках перечислили сами значения, которые будем добавлять в таблицу. Обратите внимание, что значения идут в той же последовательности, в которой мы перечислили поля.

Важно следить за порядком полей в запросе на добавление. Для примера представим, что мы перепутали местами поля gender и id. В таком случае запрос не выполнится:

INSERT INTO users (username, email, first_name, last_name, birthday, gender, id, created_at, password_digest)
VALUES ('wsmith09@gmail.com', 'AgentJ', 'Will', 'Smith', '1968-09-25', 100, 'male', '2023-05-01', '11111');


Запрос выдаст ошибку, потому что в этих полях хранятся данные разных типов. Другими словами, мы не сможем записать текст male в поле id, потому что в этом поле должно храниться число.

Возьмем другой пример и представим, что мы перепутали поля email и username. В таком случае запрос выполнится, но в поле username будет сохранена электронная почта, а в поле email — псевдоним пользователя:

INSERT INTO users (username, email, first_name, last_name, birthday, gender, id, created_at, password_digest)
VALUES ('wsmith09@gmail.com', 'AgentJ', 'Will', 'Smith', '1968-09-25', 'male', 100, '2023-05-01', '11111');


В одном запросе можно добавить сразу несколько записей, перечислив их после ключевого слова VALUES через запятую:

INSERT INTO users (username, email, first_name, last_name, birthday, gender, id, created_at, password_digest)
VALUES ('AgentJ', 'wsmith09@gmail.com', 'Will', 'Smith', '1968-09-25', 'male', 100, '2023-05-01', '11111'),
       ('MrBatman', 'benaff@gmail.com', 'Ben', 'Affleck', '1973-08-15', 'male', 101, '2023-05-01', '22222');

При работе с INSERT важно помнить, что в таблицу нельзя добавить две одинаковые записи. Правильно спроектированная база данных не позволит это сделать, потому что проверяет уникальность заданных полей. Но даже если условия уникальности не заданы, две абсолютно одинаковые строки не получится добавить из-за ограничений самой СУБД.

Два следующих запроса не выполнятся, потому что идентификатор пользователя должен быть уникальным:

INSERT INTO users (username, email, first_name, last_name, birthday, gender, id, created_at, password_digest)
VALUES ('Bond007', 'agent007@yahoo.com', 'Sean', 'Connery', '1930-08-25', 'male', 102, '2023-05-01', '33333');

INSERT INTO users (username, email, first_name, last_name, birthday, gender, id, created_at, password_digest)
VALUES ('Bond007', 'agent007@yahoo.com', 'Sean', 'Connery', '1930-08-25', 'male', 102, '2023-05-01', '33333');


Оператор UPDATE
Обновление записей в таблице выполняется UPDATE запросом:

UPDATE users SET username = 'SuperAgent007' WHERE email = 'agent007@yahoo.com';

Обычно UPDATE запрос состоит из двух частей:

SET username = 'SuperAgent007' — описывается, какое значение установить в какое поле
WHERE email = 'agent007@yahoo.com' — указывается ограничение на то, к каким строкам применить обновление
Символ «=» в WHERE — это не присваивание, а проверка на совпадение. В SET равно используется как обычное присваивание.

Поскольку в нашей таблице только одна запись удовлетворяет условию WHERE email = 'agent007@yahoo.com', то и обновится одна запись. Если бы их было больше, то обновились бы все соответствующие записи.

UPDATE в примере выше можно выполнять безопасно любое количество раз. После первого запроса дальнейшие его вызовы не сделают никаких изменений.

За одну операцию можно обновить несколько полей. Для этого достаточно перечислить каждое присваивание через запятую в части SET. Порядок, в котором изменяются поля, — не важен:

UPDATE users SET first_name = 'Pierce', last_name = 'Brosnan' WHERE email = 'agent007@yahoo.com';

Часть WHERE можно вообще не указывать:

UPDATE users SET first_name = 'John', last_name = 'Doe' ;

Такой запрос обновит все записи. Если записей в таблице много и они важны, то он приведет к тому, что данные конкретного поля будут перезаписаны у всех данных в таблице. Почти наверняка это не то, чего мы хотим. Поэтому нужно внимательно следить за тем, как пишется update. Потеря условия WHERE может обернуться перезаписью важных данных.

Проверка на точное соответствие это самый простой способ сравнения, которого не всегда достаточно. SQL позволяет выполнять значительно более хитрые проверки. Рассмотрим несколько примеров:

Операции сравнения
Мы можем использовать любые математические операции сравнения: больше, меньше, не равно и другие.

UPDATE users SET first_name = 'John' WHERE birthday > '1970-01-01';

Логические операции
Мы можем использовать логические операции для объединения условий: И и ИЛИ.

UPDATE users SET email = 'johndoe@yahoo.com'
  WHERE first_name = 'John' AND last_name = 'Doe';

UPDATE users SET first_name = 'John'
  WHERE birthday BETWEEN '1950-01-01' AND '2000-01-01';

Для логических операций используются ключевые слова AND и OR. Их можно добавлять и комбинировать в любых количествах. В составных выражениях полезно задавать приоритет с помощью круглых скобок:

UPDATE users SET username = 'secretagent'
WHERE
    (first_name = 'Sean' AND last_name = 'Connery') OR (birthday = '1968-09-25' AND gender = 'male');

Оператор DELETE
Чтобы удалить данные, можно воспользоваться оператором DELETE. Следующий запрос удалит из базы строку с пользователем 'secretagent':

DELETE FROM users WHERE username = 'secretagent';

Рассмотрим запрос подробнее:

Сначала мы указываем оператор DELETE FROM
После него идет имя таблицы, из которой удаляем данные
В конце мы указываем условие через оператор WHERE
Можно задавать любые условия, поддерживаемые языком SQL. Например, следующий запрос удалит из таблицы users пользователя с идентификатором 100, а также все записи с датой, где дата рождения пользователя с 1968 года по 2000:

DELETE FROM users
WHERE
    (birthday BETWEEN '1968-01-01' AND '2000-01-01')
    OR (id = 100);

Если никакое условие указано не будет, то будут удалены все записи из указанной таблицы:

DELETE FROM users;


Этот запрос удалит все записи из таблицы users. Такой запрос опасно выполнять. Он отработает, даже если не указана секция WHERE. Секция WHERE в разных видах запросов работает идентично — все, что описывалось для UPDATE, справедливо и для DELETE.

В базах данных есть еще один способ удалять данные в таблице — TRUNCATE. Это не часть стандарта, но реализуется большинством баз данных. У этого запроса есть две особенности:

Он предназначен для полной очистки таблиц
В отличие от DELETE, он выполняется очень эффективно, так как у TRUNCATE нет возможности задавать условия. В этом случае СУБД не нужно ничего дополнительно анализировать. Она сразу очищает место на диске без промежуточных этапов:
TRUNCATE courses;


В этом уроке мы научились добавлять, редактировать и удалять данные из таблицы. Теперь вы знаете, как с помощью оператора INSERT можно добавить строки в таблицу. Важно помнить, что порядок значений после ключевого слова VALUES должен совпадать с порядком полей, которые перечислены после имени таблицы.

С помощью оператора UPDATE можно обновить все данные или только определенные, подходящие под условие.

Еще мы разобрали оператор DELETE, с помощью которого можно удалить данные из таблицы. Если выполнить запрос на удаление данных без указания условий через WHERE, то будут удалены все записи в таблице.

С последними двумя запросами стоит быть осторожными, так как будут затронуты все записи, и могут быть серьезные последствия.


Ограничения (constraints) в SQL - это правила, устанавливаемые для столбцов таблицы, которые определяют допустимые значения для этих столбцов. Ограничения в SQL обеспечивают целостность данных и помогают предотвратить ошибки при вставке, обновлении или удалении данных.

В предыдущих уроках мы уже познакомились с одним ограничением PRIMARY _KEY

В этом уроке рассмотрим ограничения UNIQUE и NOT NULL.

Ограничение UNIQUE

<img width="1920" height="1080" alt="image" src="https://github.com/user-attachments/assets/c43af736-3adf-46e0-bb24-54518df39259" />

Ограничение UNIQUE гарантирует, что значение столбца (или комбинация столбцов) в таблице будут уникальными. Это означает, что в столбце не может быть двух одинаковых значений. При попытке вставить или обновить значение, которое уже существует в столбце с ограничением UNIQUE, будет выдана ошибка.

Пример создания ограничения UNIQUE:

CREATE TABLE users (
    id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    username VARCHAR(50),
    email VARCHAR(255) UNIQUE,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    created_at TIMESTAMP
);

INSERT INTO users (created_at, email, first_name, last_name, username) VALUES ('2022-06-14 18:31:05.296', 'Trevion53@yahoo.com', 'Lucienne', 'Feil', 'Duncan3');
INSERT INTO users (created_at, email, first_name, last_name, username) VALUES ('2022-06-14 02:04:13.104', 'Baylee52@yahoo.com', 'Ramiro', 'Wolf', 'Michaela11');
INSERT INTO users (created_at, email, first_name, last_name, username) VALUES ('2022-06-14 02:28:26.058', 'Casimer_Cronin@yahoo.com', 'Maureen', 'Romaguera', 'Margarete_Hegmann6');


Если добавить значение повторно, то запрос завершится с ошибкой:

--- этот email уже существует
INSERT INTO users (created_at, email, first_name, last_name, username) VALUES ('2022-06-14 02:28:26.058', 'Casimer_Cronin@yahoo.com', 'Caleigh', 'Connelly', 'Curtis_Baumbach');

Query Error: error: duplicate key value violates unique constraint "users_email_key"

Ограничение NOT NULL
Ограничение NOT NULL требует, чтобы значение в столбце не было NULL. Это означает, что при добавлении или обновлении записи в таблице, значение в столбце с ограничением NOT NULL должно быть обязательно указано.

Пример создания ограничения NOT NULL:

CREATE TABLE users (
    id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(255) UNIQUE,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    created_at TIMESTAMP
);

INSERT INTO users (created_at, email, first_name, last_name, username) VALUES ('2022-06-14 18:31:05.296', 'Trevion53@yahoo.com', 'Lucienne', 'Feil', 'Duncan3');
INSERT INTO users (created_at, email, first_name, last_name, username) VALUES ('2022-06-14 02:04:13.104', 'Baylee52@yahoo.com', 'Ramiro', 'Wolf', 'Michaela11');
INSERT INTO users (created_at, email, first_name, last_name, username) VALUES ('2022-06-14 02:28:26.058', 'Casimer_Cronin@yahoo.com', 'Maureen', 'Romaguera', 'Margarete_Hegmann6');


INSERT INTO users (created_at, email, first_name, last_name, username) VALUES ('2022-06-14 02:28:26.058', 'Angelita.Altenwerth96@hotmail.com', 'Caleigh', 'Connelly', NULL);

Query Error: error: null value in column "username" of relation "users" violates not-null constraint
Несколько ограничений одновременно
CREATE TABLE users (
  id bigint PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
  username VARCHAR(50) UNIQUE NOT NULL,
  birthday DATE,
  email_confirmed BOOLEAN,
  email VARCHAR(255) UNIQUE NOT NULL,
  gender VARCHAR(255) NOT NULL,
  password_digest VARCHAR(255) NOT NULL,
  first_name VARCHAR(50),
  last_name VARCHAR(50),
  created_at TIMESTAMP NOT NULL
);

 создали таблицу users со множеством полей. Поле id является первичным ключом и генерируется автоматически. Поле username имеет ограничение UNIQUE -- его значение должно быть уникальным, а также не может быть пустым благодаря ограничению NOT NULL. Поле email имеет ограничение UNIQUE и NOT NULL, гарантируя уникальность и наличие email адреса для каждого пользователя.

Ограничения позволяют гарантировать целостность данных и избежать ошибок. Ограничение UNIQUE гарантирует уникальность значений в указанном поле. NOT NULL требует, чтобы значение в указанном поле не было NULL, то есть присутствовало всегда.

Ограничения UNIQUE и NOT NULL играют важную роль при проектировании баз данных в SQL. Они помогают обеспечить целостность данных и предотвращают появление ошибок. Помните об этих ограничениях при работе с базами данных и используйте их с умом.


Наиболее сложный запрос при работе с таблицами -- обновление ее структуры. Если посмотреть официальную документацию, то общая запись этого запроса занимает больше трех экранов монитора. Но ни один человек не помнит всех возможностей этой команды. Более того, большинство из них редко выполняются. Единственное, что нужно знать -- возможности этой команды -- общие принципы ее работы. А детали всегда можно будет найти в документации.

В этом уроке разберем такой тип запроса, как ALTER TABLE. Он отвечает за изменение таблицы базы данных. Также узнаем, какие четыре операции со столбцами он включает в себя.

Запрос ALTER TABLE
Запрос ALTER TABLE используют, чтобы изменять структуру столбца таблицы базы данных. Он включает четыре операции:

Добавление колонки
Переименование колонки
Удаление колонки
Обновление колонки
Разберем каждую операцию подробнее.

Добавление колонки
С помощью ALTER можно добавить колонку в уже имеющуюся таблицу:


добавили колонку age.

Делается это таким образом:

CREATE TABLE users (
    id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    username VARCHAR(50),
    email VARCHAR(255) UNIQUE NOT NULL,
    created_at TIMESTAMP
);

INSERT INTO users (created_at, email, username) VALUES ('2022-06-14 18:31:05.296', 'Trevion53@yahoo.com', 'Duncan3');
INSERT INTO users (created_at, email, username) VALUES ('2022-06-14 02:04:13.104', 'Baylee52@yahoo.com', 'Michaela11');
INSERT INTO users (created_at, email, username) VALUES ('2022-06-14 02:28:26.058', 'Casimer_Cronin@yahoo.com', 'Margarete_Hegmann6');

-- в таблицу "users"
-- добавить колонку с именем "birthday" и типом "date"
ALTER TABLE users ADD COLUMN birthday DATE;

Здесь после фразы ADD COLUMN идет строка описания новой колонки, точно такая же, как и при создании таблицы. В простом варианте она выглядит так: <имя колонки> <тип>. Здесь можно указывать любые ограничения, добавлять ключи, автогенерацию, значение по умолчанию и многое другое. Синтаксис на 100% совпадает с синтаксисом определения колонки, когда таблица создается.

Переименование колонки
Чтобы переименовать колонку, нужно сделать следующий запрос:

-- добавляем колонку, которой еще нет.
ALTER TABLE users ADD COLUMN name VARCHAR(255);
-- в таблице "users"
-- изменить колонку "name":
-- поменять имя с "name" на "first_name"
ALTER TABLE users RENAME COLUMN name TO first_name;

Здесь нет никаких сложностей -- одно имя меняется на другое.

Удаление колонки
Следующий запрос удаляет колонку:

ALTER TABLE users ADD COLUMN age DATE;
-- в таблице "users"
-- удалить колонку с именем "age"
ALTER TABLE users DROP COLUMN age;

Это тоже простая операция, которая убирает ненужную колонку.

Обновление колонки
Команда по изменению параметров колонки наиболее сложная. Практически у каждого элемента, который поддается обновлению, есть собственный синтаксис для этого обновления. Вот несколько базовых примеров:

CREATE TABLE courses (
    id bigint PRIMARY KEY,
    name varchar(255) NOT NULL,
    body text,
    created_at timestamp
);

-- Установка ограничения уникальности в таблице courses для колонки name
ALTER TABLE courses
ADD UNIQUE (name);

-- Изменение типа данных в таблице courses для колонки created_at
-- и снятие ограничения NOT NULL в таблице courses для колонки name
ALTER TABLE courses
ALTER COLUMN created_at SET DATA TYPE DATE,
ALTER COLUMN name DROP NOT NULL;

-- Установка ограничения NOT NULL в таблицу courses для колонки name
ALTER TABLE courses
ALTER COLUMN name SET NOT NULL;

Наиболее распространенные команды:

ADD -- добавление ограничения: например, ключа или уникальности
SET -- установка значения: например, типа данных
DROP -- удаление ограничения
В рамках одного обновления можно группировать операции, но существует ряд исключений. Например, группировке не поддается операция RENAME -- ее нужно выполнять отдельным запросом, иначе СУБД завершит запрос с ошибкой.

Выводы
В этом уроке мы разобрали тип запроса ALTER, который отвечает за изменение таблицы базы данных. Мы узнали, что с его помощью можно добавлять, переименовывать, удалять и обновлять колонки.

Первые три операции достаточно простые. При этом переименование или удаление колонок -- небезопасные процессы. Если удалить колонки в работающей базе данных, это приведет к ошибкам, когда мы будем вставлять или обновлять записи. Любые выборки, включающие эту колонку, также завершатся с ошибкой.

Такие операции выполняют редко и только тогда, когда есть уверенность, что эти колонки никто не использует. Еще обновление колонки может серьезно влиять на производительность. А если данных много, то они будут обновляться продолжительное время -- часы и даже дни.


Получаем количество денег пользователя:
   SELECT amount FROM accounts WHERE user_id = 10;
Списываем необходимую сумму со счета этого пользователя:
   UPDATE accounts SET amount = amount - 50 WHERE user_id = 10;
Зачисляем деньги другому пользователю:
   UPDATE accounts SET amount = amount + 50 WHERE user_id = 30;

отсутствует гарантия завершения. Представим, что система успела выполнить списание, и в этот момент произошла ошибка, например, выключили питание или компьютер перезагрузился. В результате получится странная ситуация: деньги списались, но никуда не зачислились:

Приложения по возможности должны находиться в согласованном состоянии. В распределенных системах это невозможно, добиться этого можно с помощью механизма транзакций. Мы не будем подробно разбирать эту тему, но вы можете узнать о ней больше, изучив CAP-теорему и Eventual Consistency.

Транзакции используют не только в базах данных, но и в обычной жизни. Например, операция снятия денег в банкомате -- это бизнес-транзакция. Пользователи банкомата ожидают, что эта операция либо снимет деньги, либо нет, и банкомат это обеспечивает.

Операция снятия денег -- это процесс, который приводит не только к множеству запросов в базу данных, но и к затрагиванию многих систем. У них есть свои процессы и базы данных внутри.

транзакции атомарность -- когда операция либо завершается успешно, либо не проходит. Транзакции в базе данных в этом смысле проще, чем бизнес-транзакции. За обеспечением необходимых гарантий следит сама СУБД, а не программист:

BEGIN;
SELECT amount FROM accounts WHERE user_id = 10;
UPDATE accounts SET amount = amount - 50 WHERE user_id = 10;
UPDATE accounts SET amount = amount + 50 WHERE user_id = 30;
COMMIT;

Транзакции в PostgreSQL -- это блок запросов, который обрамляется запросами:

BEGIN -- открытие транзакции
COMMIT -- закрытие транзакции
Любая ошибка внутри транзакции откатывает все изменения, которые были сделаны после запроса BEGIN:

<img width="878" height="1080" alt="image" src="https://github.com/user-attachments/assets/7b05645d-665e-451e-93aa-ef7baf2d2a45" />

Если нужно, транзакцию можно откатить самостоятельно. Для этого необходимо выполнить запрос ROLLBACK до COMMIT. Это нужно, когда выполняются запросы из кода приложения.

BEGIN;
UPDATE accounts SET amount = amount - 50 WHERE user_id = 10;
ROLLBACK;

транзакция была надежной и предсказуемой, нужно соблюдать определенные требования.

Требования к транзакционной системе
В информатике есть набор требований к транзакционной системе, которые гарантируют ее надежность -- ACID. К ним относятся:

Atomicity (Атомарность)
Любая транзакция не может быть частично завершена -- она либо выполнена, либо нет.

Consistency (Согласованность)
Завершившаяся транзакция должна сохранять согласованность базы данных. Каждая успешная транзакция фиксирует только допустимые результаты, при том, что в процессе работы транзакции данные могут оказываться несогласованными.

снятие денег с одного счета приводит к тому, что данные рассинхронизированы. Но когда транзакция завершается, этого нет.

Гарантию согласованности данных нельзя полностью обеспечить только средствами базы данных, например, различными ограничениями. Поддержка` этого требования включает в себя работу со стороны программистов, которые пишут необходимый для этого код.

Isolation (Изолированность)
Когда транзакция выполняется, параллельные транзакции не должны оказывать влияния на ее результат. Ни одна транзакция не может увидеть изменения, которые сделаны другими незавершенными транзакциями. Изолированность -- дорогое требование, поэтому в реальных БД существуют режимы, которые изолируют транзакцию не полностью -- уровни изолированности Repeatable Read и ниже.

Durability (Устойчивость)
Изменения, которые сделаны успешно завершенной транзакцией, должны остаться сохраненными после возвращения системы в работу. не должно зависеть от проблем на нижних уровнях, обесточивание системы или сбои в оборудовании. Если пользователь получил подтверждение от системы, что транзакция выполнена, он будет уверен, что ничего не отменится из-за какого-либо сбоя.

выполнять запросы внутри транзакции. Такие операции нельзя выполнить за один запрос, поэтому нужно проходить несколько шагов. набор свойств транзакции гарантирует, что данные в БД будут целостные независимо от любых сбоев.
