Семейство стандартов POSIX (Portable Operating System Interface for UNIX), описывает работу ключевых компонентов ОС Unix и способов взаимодействия с ними из программ на Си.

Обеспечивает совместимость ОС и ПО, позволяя приложениям работать на разных UNIX-подобных системах (Linux, macOS, BSD) без существенных изменений, определяет единые API, системные вызовы, утилиты и среду выполнения, особенно для Cи. Система POSIX-совместима, она соответствует этим стандартам, делая код переносимым.


Терминалом программу, эмулирует поведение железного терминала из клавиатуры и монитора. окошко с командной строкой внутри
Командная оболочка — программа, через которую пользователь управляет ОС и установленными программами, используя командную строку. (shell, командный интерпретатор).
Оболочка — средство для выполнения определенных задач, а не сама задача.
Внутри терминала пользователь передает системе строки:

<img width="2048" height="1536" alt="image" src="https://github.com/user-attachments/assets/cad30575-fd03-4959-9959-1ccf13f5f092" />

Оболочка запускается внутри терминала и приглашает ко вводу команд. Командная оболочка позволяет запускать на выполнение установленные программы.
Терминал — программа, запускает командную оболочку внутри себя:

<img width="2707" height="965" alt="image" src="https://github.com/user-attachments/assets/961b5c1a-5627-435e-9d08-3d443dbb453a" />

В *nix-системах единственное дерево с корнем в /. устройства, физические и логические диски внутри дерева в виде директорий и файлов.

Информация о файле или директории stat (file system status)

Директория — специальный файл, содержит список файлов. подключаемое устройство становится файлом или директорией, если это накопитель.
печать на принтер и вывод на экран не отличаются с точки зрения кода - запись в файл.

Hard Link — доп имя для уже сущ файла
Symbolic link — символическая ссылка. файл похож на ярлык в Windows. Если удалить основной файл, символическая ссылка вести в никуда
Socket — специальный файл, через который взаимодействие между разными процессами ОС.

в каталоге /var/log файл логов Linux syslog.

В WSL syslog установите:
sudo add-apt-repository ppa:adiscon/v8-stable
sudo apt-get install rsyslog
sudo service rsyslog start.

tail -f path/to/file последние строчки файла, и ждет появления новых.

программ для просмотра содержимого файла и поиска по нему, только в режиме чтения — пейджеры.
sudo less syslog



Для работы с потоком ввода создать объект класса Scanner, при создании указав, с каким потоком ввода связан. 
Стандартный поток ввода (клавиатура) объектом — System.in.
стандартный поток вывода (дисплей) — объектом System.out. 
стандартный поток для вывода ошибок — System.err.

```java
// считать значение без предварительной проверки, во время исполнения программы ошибку (отладчик заранее ошибку не обнаружит)
if (sc.hasNextInt()) { // можно ли с потока ввода считать целое число
  i = sc.nextInt(); // считывает число с потока ввода
}
```

hasNext(), остались ли в потоке ввода символы.


# STDOUT перенаправляется в output, затем STDERR перенаправляется в STDOUT, запись в файл продолжается
ls lala > output 2>&1
& поток, в который осуществляется перенаправление.

2>&1 перед > output. не работать, интерпретатор прочитает 2>&1, не знать, куда перенаправлен стандартный поток вывода. потоки ошибок и вывода не объединены:
ls lala 2>&1 > output
ls: cannot access 'lala': No such file or directory # Вывод в окне терминала



grep PATH .profile | grep local
PATH="$HOME/.local/bin:$PATH"
командная оболочка взять поток STDOUT процесса и соединить его с потоком STDIN другого.

<img width="1975" height="1059" alt="image" src="https://github.com/user-attachments/assets/65fbbe99-e801-4646-91c3-6b65e6400448" />

grep PATH .profile | grep local изменить, используя перенаправление. станет проще для модификации:

cat .profile | grep PATH | grep local
файл читается катом и отправляется в поток STDIN грепа.



cd без аргументов делает домашнюю директорию пользователя (~) рабочей - ориентируется на переменную окружения - домашняя директория доступна в переменной окружения HOME.
сущ в рамках запущенной сессии командной оболочки, переменные пропадут, когда терминал закроется. подгружаются во время инициализации.

предназначение переменных окружения — конфигурирование системы и программ.

При вызове cd каждый раз указывать, где находится домашняя директория. cd --home-dir /home/kirill.m.
Договариваться, что где-то будет храниться специальный файл с настройками, домашней директории. Настройки из файла читаться командой cd при каждом запуске
набор переменных, которые всегда устанавливаются bash при старте.

echo $HOME

/home/kirill.m

HOME=/tmp
echo $HOME

/tmp

# Возвращаем обратно
HOME=/home/kirill.m
echo $HOME

/home/kirill.m

установить HOME и выполнить переход в эту директорию с cd, отправить в домашнюю директорию:

# присваивание слева от запускаемой команды
HOME=/tmp cd

/tmp

pwd

/tmp

cd выполнила переход по пути, указанном в переменной HOME. cd, но не добавляя определение переменной слева:

cd
pwd

/home/kirill.m

echo $HOME

/home/kirill.m

переход в настоящую домашнюю директорию. вызов HOME=/tmp cd изменил переменную для конкретного запуска. 
значение переменной окружения: локальный и глобальный.

HOME=/tmp перед cd, переменная не была изменена для текущей сессии — она была изменена для запущенной команды, в данном случае cd.

установки изменяет значение глобально, для всей сессии:

echo $HOME

/home/kirill.m

export HOME=/tmp
cd
pwd

/tmp

echo $HOME

/tmp

изменение в текущей сессии. две вкладки терминала, изменение только в той вкладке, в которой написали команду.


### export

Определение переменной в Bash: с командой export и без

Bash-переменные Linux два способа определения переменной оболочки — с командой export и без нее. добавление команды меняет область действия переменной.

Bash — командный интерпретатор в юниксоподобных системах, особенно в GNU/Linux. С другой — скриптовый язык программирования со своим синтаксисом и особенностями.

Определение переменной с export и без
Переменные Bash не нуждаются в объявлении. Переменную создает присвоение ее имени значения.

MYVAR=1729
export MYVAR=1729
В первом случае создается переменная оболочки с именем MYVAR, присваивается значение 1729. 
Во втором определение переменной с export. команда отмечает переменную для экспорта во все дочерние процессы, которые созданы внутри оболочки и делают ее переменной окружения.

export делает переменную доступной для всех след команд, которые выполняются в этой оболочке. Команда export помечает MYVAR для автоматического экспорта в среду дочерних процессов, которые создаются командами:

export MYVAR=1729
echo $MYVAR
1729
bash    # Open a new child shell
echo $MYVAR
1729

Если переменная задана без использования export, доступна только внутри оболочки. дочерние оболочки, процесс или команды вне ее не получат доступа к ней:

MYVAR=1729
echo $MYVAR
1729
bash    # Open a new child shell
echo $MYVAR
$

Переменные оболочки (определенные без экспорта) локальным переменным. Доступ к ним только внутри этой оболочки.
Переменные окружения (определенные с экспорта) глобальным переменным. Доступ к ним как в родительской оболочке, во всех дочерних оболочках, процессах и командах.
Родительская оболочка может экспортировать свои переменные в среду дочерней оболочки, но дочерняя оболочка не может экспортировать переменные обратно в родительскую.

Переменные окружения использовать когда экспортировать переменные и сделать их доступными для следующих команд и процессов. среду использовать вместе с дочерними процессами:
При настройке среды дочернего процесса или оболочки
При определении переменной, которую будет использовать сценарий bash, выполняемый из родительской оболочки
При настройке переменных окружения для терминальных мультиплексоров (screen или tmux)
При настройке среды сборки для сценариев и инструментов сборки
Переменные оболочки использовать, когда они должны сущ только в родительской оболочке.

export экспортировать не только переменные, но и функции. опцию командной строки export -f. функции доступны и в дочерних оболочках и процессах:

func(){
> echo hi
> }
func
hi
bash    # Open a new child shell
func
bash: func: command not found
exit   # Back to parent shell
export -f func
bash    # Open a new child shell
func
hi

Переменные окружения автоматически экспортируются во все дочерние оболочки, в их дочерние оболочки. Для удаления автоматически унаследованной переменной export -n:

echo $USER
ubuntu
bash    # Open a new child shell
echo $USER
ubuntu
exit   # Back to parent shell
export -n USER
bash    # Open a new child shell again
echo $USER
$

Для получения списка всех переменных и функций, экспортированных в текущую оболочку export -p:

export -p
declare -x COLORTERM="truecolor"
declare -x DESKTOP_SESSION="ubuntu"
declare -x DISPLAY=":0"
declare -x GDMSESSION="ubuntu"
declare -x LESSCHARSET="latin1"
declare -x LESSCLOSE="/usr/bin/lesspipe %s %s"
declare -x LESSOPEN="|/usr/bin/lesspipe.sh %s 2>&-"
.
declare -x XDG_SESSION_DESKTOP="ubuntu"
declare -x XDG_SESSION_ID="2"
declare -x XDG_SESSION_TYPE="x11"
declare -x XDG_VTNR="1"

все переменные оболочки экспортированы правильно.

Для автоматического экспорта всех переменных, определенных в текущей оболочке, опция all export. включать или отключать set:

set -a # Enable allexport using single letter syntax
set -o allexport # Enable using full option name syntax
set +a # Disable allexport using single letter syntax
set +o allexport # Disable using full option name syntax
set -a
MYVAR=1729    # no export
bash    # Open a new child shell
echo $MYVAR
1729

команду включать перед вызовом сценария Bash, который определяет множество переменных без команды экспорта.

У передачи переменной окружения между родительской и дочерними оболочками иерархия:

<img width="3042" height="1119" alt="image" src="https://github.com/user-attachments/assets/828d5dc6-1e40-4726-ac00-8ab6bf368431" />

При создании сценария, вызываемого из командной оболочки и содержащего команду export, проверить соответствие результата экспорта ожидаемому.

Export во время выполнения скрипта
Выполнение сценария с командой export из командной оболочки происходит в дочерней оболочке. переменные, экспортируемые сценарием, доступны только его дочерним оболочкам, но не родительской. Когда выполнение сценария завершится, экспортированные переменные исчезнут из среды:

echo "export MYVAR=1729" > myscript.sh
chmod +x myscript.sh
./myscript.sh
echo $MYVAR
$

Экспорт переменной в родительскую оболочку
при выполнении сценария необходимо экспортировать переменную окружения в родительскую оболочку, команду source. выполнить сценарий в текущей среде без создания дочерней оболочки.

echo "MYVAR=1729" > myscript.sh
source myscript.sh
echo $MYVAR
1729

Команда export помогает экспортировать переменные окружения, чтобы доступны во всех дочерних процессах, оболочках и командах. различные параметры командной строки export и других связанных команд предоставляют различные способы определения, экспорта и использования переменных в разных оболочках и сценариях.

### История

```bash
history
 1  docke rps
 2  free -m
 3  docker ps

!2
free -m

history | grep export
 174  export HOME=/tmp
 183  history | grep export
```

реверсивный поиск Ctrl + r. повторное Ctrl + r выберет следующее соответствие из истории

### Пользователи

Взаимодействие с ос ведется от пользователя, созданного в системе.
Тема пользователей и их прав в системе относится к функционированию ос. Оболочка лишь предоставляет утилиты, позволяющие анализировать доступы и изменять их.

процесс, запускаемый в ос, стартует от имени пользователя.

«процесс запускается от имени пользователя». присутствие пользователя для запуска необязательно. когда система загружается, она запускает множество процессов автоматически.

Для процессов в системе создаются собственные пользователи с ограниченным набором прав.
ps (process status) работающих процессах. какой процесс и под каким пользователем запущен:

ps aux

root      7717  0.0  0.0   4244  1504 ?        S    10:52   0:00 mpstat 1 3
kirill.m  7718  0.0  0.1  36084  3236 pts/0    R+   10:52   0:00 ps aux
alexand+ 10542  0.0  0.1  21500  2892 pts/1    Ss+  10:10   0:00 -bash
root     11113  0.0  0.1  92796  2596 ?        Ss   08:50   0:00 sshd: kirill.m [priv]
kirill.m 11116  0.0  0.0  45276  1408 ?        Ss   08:50   0:00 /lib/systemd/systemd --user
kirill.m 11119  0.0  0.0  61148  1860 ?        S    08:50   0:00 (sd-pam)
kirill.m 11194  0.0  0.0  92796  1800 ?        S    08:50   0:00 sshd: kirill.m@pts/0
kirill.m 11195  0.0  0.2  21388  4448 pts/0    Ss   08:50   0:00 -bash
root     12195  0.0  0.0      0     0 ?        S    10:13   0:00 [kworker/u30:1]
root     12880  0.0  0.1  92796  2748 ?        Ss   08:55   0:00 sshd: alexander.v [priv]
alexand+ 12883  0.0  0.0  45276  1924 ?        Ss   08:55   0:00 /lib/systemd/systemd --user
alexand+ 12884  0.0  0.0  61148  1860 ?        S    08:55   0:00 (sd-pam)
alexand+ 12920  0.0  0.1  92796  2420 ?        S    08:55   0:00 sshd: alexander.v@pts/1,pts/2



запускаем утилиту touch. от своего имени стартуем процесс, внутри которого запускается программа touch. программа создает файл и делает вас владельцем нового файла.

сменится идентификатор UID - сменится и пользователь, новый пользователь потеряет доступы к старому аккаунту.

хранилищем пользователей в *nix-системах.

cat /etc/passwd

root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
proxy:x:13:13:proxy:/bin:/usr/sbin/nologin
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
kirill.m:x:1002:1002::/home/kirill.m:/bin/bash

<img width="993" height="536" alt="image" src="https://github.com/user-attachments/assets/19533b31-0224-4a45-bb2a-efa746fb74fa" />

Кроме имени и идентификатора, указана командная оболочка по умолчанию и домашняя директория пользователя, которую можно поменять. 
/usr/sbin/nologin, пользователь не может входить в систему. пользователи для запуска программ, у которых ограниченные права — входить в систему им не нужно.


группа для группового доступа к общему ресурсу — файлу. создать группу и привязать ее к пользователю.

группа kirill.m считается основной — такая группа может быть только одна, и именно в нее входят любые создаваемые файлы от имени текущего пользователя. Кроме основной, пользователь может входить в произвольное число дополнительных групп.

пользователя root выполнять любые действия в системе. в файле /etc/passwd:

<img width="993" height="536" alt="image" src="https://github.com/user-attachments/assets/8519ef19-82b1-4ad8-8cc0-e219509a5d95" />

Использовать root только для выполнения некоторых привилегированных действий.

# владелец файла — суперпользователь `root`
stat /etc/myfile

sudo -u nobody mkdir /tmp/test
# Директория создана от имени nobody
stat /tmp/test

  File: '/tmp/test'
  Size: 4096        Blocks: 8          IO Block: 4096   directory
Device: ca01h/51713d    Inode: 4577        Links: 2
Access: (0755/drwxr-xr-x)  Uid: (65534/  nobody)   Gid: (65534/ nogroup)

произвести пачку действий от имени другого пользователя, запустить новую оболочку внутри текущей. стартуем новую сессию:
sudo -i

не забыть переключиться обратно после завершения манипуляций.
exit.

из-под sudo команду, создает файлы и директории. владельцем файлов суперпользователь. обращения к файлу без sudo ошибку. Множество программ обращаются к файловой системе для чтения конфигурационных файлов.

-rw-r--r-- 1 kirill.m kirill.m 3771 Aug 31  2015 .profile
r-- — права второго типа (для группы владельца). такие права есть у тех, кто входит в группу kirill.m.
r-- — права третьей группы (все остальные).

файл не может обозначить прав на свое удаление, права всегда берутся из директории, в которой файл находится. Удалить файл, если есть возможность писать в директорию

ls -la /home/ | grep kirill

drwxr-xr-x  5 kirill.m          kirill.m          4096 Aug 29 11:34 kirill.m

x в отношении директорий - перемещаться в директорию и обращаться к расположенным в ней файлам и каталогам, при условии, что эти файлы доступны на чтение, запись или выполнение. 
положить доступный на чтение файл в директорию с правом x, прочитать этот файл. Если убрать с этой директории право x, лишитесь доступа к файлу.

директория — список файлов, право на чтение прочитать этот список, вывести список имен файлов в директории.

посмотреть список имен файлов с дополнительной информацией — право x, обращаться к файлам за их метаданными (владелец, группа, дата изменения, права и др.). 
без права r не сможете посмотреть содержимое директории.

### пакетные менеджеры

Пакетный менеджер состоит из нескольких частей. взаимодействует с пользователем — консольная утилита apt.
пакетные менеджеры требуют запуска от суперпользователя, установка программ в системные директории, недоступные для записи обычному пользователю:

sudo apt install php

apt remove php

На другом конце каталог пакетов. установить программу утилита apt запрос в каталог.


Для экономии ресурсов и ускорения работы пакетный менеджер apt сохраняет индекс — список пакетов в каталоге. Индекс хранится на локальном диске и используется для работы пакетного менеджера.

пакет существует, но apt утверждает обратное. запустите ручное обновление локального индекса:

sudo apt update
sudo apt install php

установить программу — найти сайт программы и выполнить действия, указанные на странице «Скачать» (Download). на этой странице инструкции по пакетному менеджеру и примеры команд.

пакет — упаковка для программы. программа не знает о существовании пакета и пакетного менеджера. пользователи могли установить программу через менеджер пакетов, ее разработчик заранее упаковывает программу в пакет.

В Ubuntu формат пакетов deb. У этого формата документация как производить упаковку.

Как программы попадают в каталог?

пройти некую процедуру, чтобы добавить программу в каталог. аспектов, по которому дистрибутивы Linux отличаются друг от друга.

Пакетные менеджеры есть не только в ОС. экосистема, внутри которой возможно распространение библиотек или программ, имеет пакетный менеджер.
В Node.js — пакетный менеджер npm



Запуск программ в командной строке активирует механизм по поиску и выполнению программы.

Программа — файл или набор файлов на диске. Один из этих файлов должен быть исполняемым. выполнить программу можно, если она исполняемая.

вводим команду,  командная оболочка начинает поиск исполняемого файла с именем ls в списке директорий, указанном в переменной окружения PATH:

echo $PATH
/home/hex/.local/bin:/home/hex/bin/:/home/hex/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

Поиск программы: командная оболочка перебирает директории слева направо и ищет директорию с файлом ls, доступным для исполнения.

Если файл с одним именем находится в нескольких директориях, найдем файл в директории, расположенной левее.
где лежит исполняемый файл программы, командой type (which и whereis):

type cp

cp is /bin/cp

whereis cp

cp: /bin/cp /usr/share/man/man1/cp.1

which cp

/bin/cp

ls -al /bin | grep cp

-rwxr-xr-x 1 root root  141528 Jan 18  2018 cp

файл cp принадлежит суперпользователю, но исполнять его могут все.

пути к исполняемым файлам программ оканчиваются на директории bin. Пакетные менеджеры знают о бинарниках и во время установки программ переносят их в одну из директорий, входящих в переменную PATH. Для вновь устанавливаемых программ это /usr/local/bin.

расширить PATH. устанавливаем программу через пакетные менеджеры языков программирования. Делать это убедившись, что по-другому нельзя.

программа, которую запустить, не лежит по путям поиска, прописанным в PATH. исполняемый файл программы в текущей директории.

запустить стандартную программу, а злоумышленник положил в текущую директорию вредоносную программу с таким же именем. прямой запуск программ всегда должен быть путем до файла — path/to/executable/file.

./executable

При правильной установке программы сами добавляют свои исполняемые файлы в нужные места.

export PATH=$PATH:/path/to/директория с исполняемыми файлами

### Коды завершения

Как использовать коды завершения в Bash-скриптах

Инструменты автоматизации и мониторинга, взять готовые скрипты, адаптировать и использовать в проекте.  использовать его в скриптах командной строки.

В Linux и других Unix-подобных ос программы во время завершения могут передавать значение родительскому процессу. значение кодом завершения или состоянием завершения. программа передаёт 0 при успешном исполнении и 1 или большее число при неудачном исполнении.

полезный Bash-скрипт будет использоваться в других скриптах или его обернут в однострочник Bash. инструментов автоматизации типа SaltStack или инструментов мониторинга типа Nagios. Эти программы исполняют скрипт и проверяют статус завершения.

В Linux любой код, запущенный в командной строке, имеет код завершения. Если код завершения не определён, Bash-скрипты используют код выхода последней запущенной команды.

#!/bin/bash
touch /root/test
echo created file

Этот скрипт запускает команды touch и echo. Если запустить этот скрипт без прав суперпользователя, команда touch не выполнится. получить информацию об ошибке с помощью соответствующего кода завершения. проверить код выхода, достаточно ввести в командную строку специальную переменную $?. Она печатает код возврата последней запущенной команды.

$ ./tmp.sh
touch: cannot touch '/root/test': Permission denied
created file
$ echo $?
0

после запуска команды ./tmp.sh получаем код завершения 0. Этот код говорит об успешном выполнении команды, хотя на самом деле команда не выполнилась. код завершения не определён, получаем код выхода последней запущенной команды.

#!/bin/bash
touch /root/test
Если убрать из скрипта команду echo, можно получить код завершения команды touch.

$ ./tmp.sh
touch: cannot touch '/root/test': Permission denied
$ echo $?
1

touch в данном случае — последняя запущенная команда, и она не выполнилась, получаем код возврата 1.

Удаление из скрипта команды echo позволило нам получить код завершения. разные действия в случае успешного и неуспешного выполнения команды touch? печати stdout в случае успеха и stderr в случае неуспеха.

переменной $?, получить код завершения скрипта. проверить, выполнилась ли команда touch успешно.

#!/bin/bash
touch /root/test 2> /dev/null
if [ $? -eq 0 ]
then
  echo "Successfully created file"
else
  echo "Could not create file" >&2
fi

Если команда touch выполняется с кодом 0, скрипт с echo сообщает об успешно созданном файле.
Если команда touch выполняется с другим кодом, скрипт сообщает, что не смог создать файл.
код завершения кроме 0 значит неудачную попытку создать файл. Скрипт с echo отправляет сообщение о неудаче в stderr.

$ ./tmp.sh
Could not create file

скрипт сообщает об ошибке, если touch выполняется с ошибкой. успешного выполнения команды получаем код 0.

$ ./tmp.sh
Could not create file
$ echo $?
0

скрипт завершился с ошибкой, передавать код успешного завершения в другую программу, которая использует этот скрипт. добавить собственный код завершения, командой exit.

#!/bin/bash
touch /root/test 2> /dev/null
if [ $? -eq 0 ]
then
  echo "Successfully created file"
  exit 0
else
  echo "Could not create file" >&2
  exit 1
fi

успешного выполнения команды touch скрипт с echo сообщает об успехе и завершается с кодом 0. скрипт печатает сообщение об ошибке при попытке создать файл и завершается с кодом 1.

$ ./tmp.sh
Could not create file
$ echo $?
1

Скрипт уже умеет сообщать пользователям и программам об успешном или неуспешном выполнении. его можно использовать с другими инструментами администрирования или однострочниками командной строки.

$ ./tmp.sh && echo "bam" || (sudo ./tmp.sh && echo "bam" || echo "fail")
Could not create file
Successfully created file
bam

команда выполняет скрипт ./tmp.sh, выполняет echo "bam", если код завершения 0. Если код завершения 1, выполняется следующая команда в скобках. в скобках для группировки команд снова используются && и ||.
