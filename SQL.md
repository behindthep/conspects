psql -h 65.108.223.44 (DBMS_server_address) -d coursesdb -U student

<img width="840" height="767" alt="image" src="https://github.com/user-attachments/assets/5a623a5f-93ff-4e9e-af76-7c91db3a228a" />



varchar(10) -- строк с ограничением макс длины
text -- строк без ограничения.

нельзя оставить первый тип без указания длины. Данные в бд хранятся на дисках в файлах. Быстрый доступ к данным возможен, когда у данных фикс размер. перемещаться по ним и считать смещения. Если размер данных не известен, просматривать весь файл в поисках значения. 
text хранится отдельно. негативно влияет на скорость, но не так сильно.

integer	-2147483648 .. +2147483647
bigint	-9223372036854775808 .. 9223372036854775807
real	вещественное число с переменной точностью	-2147483648 .. +2147483647, точность в пределах 6 десятичных цифр

даты как и строки заключаются в одинарные кавычки

timestamp	дата и время (без часового пояса) - момент времени	4713 до н. э.	294276 н. э.	1 микросекунда
date	    дата (без времени)	4713 до н. э.	5874897 н. э.	1 день
time	    время без даты	00:00:00	24:00:00	1 микросекунда

добавление и заполнение полей created_at и updated_at в каждую таблицу.

1999-01-08	ISO 8601 (рекомендуемый формат)

Первичный ключ (уникально идентифицирует запись в таблице - обеспечить целостность данных) в таблице только один, для него отдельное поле - идентификатор

Помимо типов данных для реальных значений, в базе сущ специальное значение NULL - отсутствие значения.
SELECT * FROM users WHERE birthday IS NOT NULL;


фильтрации строки по шаблону - подстроке, найти. оператор LIKE (NOT LIKE), после которого шаблон.
SELECT id, first_name, last_name, email, birthday FROM users WHERE last_name LIKE 'Sch%';

ILIKE строки без учета регистра


Для работы с регулярными выражениями оператор SIMILAR TO вместо LIKE.

выбрать пользователей, чье имя на 'A' или 'B'.
WHERE first_name SIMILAR TO '[AB]%';

В квадратных скобках допустимые символы, %. пользователей с именами Abigale, Andy, Brayan

найти пользователей, у которых username заканчивается буквой. %[abcdefghijklmnopqrstuvwxyz]. В квадратных скобках символ - для перечисления. записать в квадратных скобках начальный символ, поставить "-" и указать конечный символ, шаблон вернет символ из диапазона от начального до конечного. username заканчивается буквой.

WHERE username SIMILAR TO '%[a-z]';

WHERE email NOT SIMILAR TO '%@%.%';

адреса электронной почты,  национальная зона состоит ровно из двух символов — например, ru, su, io и так далее. исключим зоны, состоящие из трех и более символов — com.

%.[a-z][a-z]. подчеркиванием _ - один символ

WHERE email SIMILAR TO '%@%.__';

пользователей с адресами электронной почты оканчивающимися на 3 символа, добавить еще одно подчеркивание в шаблон:

WHERE email SIMILAR TO '%.___';


% любому количеству любых символов
[] для перечисления символов — [АЕИОУЭЮ]
Дефис - в квадратных скобках перечисление символов — [0-9] соответствует цифре


Операторы ~ и SIMILAR TO в PostgreSQL для выполнения операций поиска по регулярным выражениям.

Оператор ~ для поиска строк, соответствующих регулярному выражению. не входит в стандарт языка SQL и является специфичным для PostgreSQL. поддерживает широкий набор возможностей регулярных выражений.

-- все имена, начинающиеся с буквы "A"
WHERE name ~ '^A';

-- имена, содержащие две буквы "o" подряд
WHERE name ~ 'o{2}';

-- имена, начинающиеся с буквы "a" или "A", игнорируя регистр
WHERE name ~* '^a';

-- все имена, начинающиеся с букв от "A" до "F"
WHERE name ~ '^[A-F]';

-- все имена, начинающиеся с буквы "A"
WHERE name SIMILAR TO 'A%';

-- имена, содержащие две буквы "o" подряд
WHERE name SIMILAR TO '%o{2}%';

-- имена, начинающиеся с буквы "a" или "A", игнорируя регистр
WHERE name SIMILAR TO '(a|A)%';

-- все имена, начинающиеся с букв от "A" до "F"
WHERE name SIMILAR TO '[A-F]%';

-- строки, содержащие слово "John"
WHERE name SIMILAR TO '%\\yJohn\\y%';

\y граница слова, аналогично \b в стандартных регулярках.


приоритет оператора AND выше, чем OR.
Рассматривай NOT как ! отрицание


строки, в которых поле соответствует значению из набора. пользователей с идентификаторами 1, 2 или 5.
WHERE id IN (1, 2, 5);
WHERE first_name IN ('Lionel', 'Lucienne', 'Jennyfer');


отсортировать по нескольким полям.
ORDER BY first_name ASC, created_at DESC;
сначала сортировка по имени. Затем внутри групп с одинаковым именем данные сортируются по created_at.


сортировать данные с NULL. в MySQL NULL впереди при сортировке по возрастанию, в PostgreSQL в конце.
если данные содержат NULL, важно явно указывать, где располагаться значения NULL в результирующем наборе.
ORDER BY created_at ASC NULLS FIRST;
ORDER BY created_at DESC NULLS LAST;


Оператор LIMIT без сортировки не используется.
ORDER BY id LIMIT 10 OFFSET 10;

Пропустит первые 10 записей за счет части OFFSET 10. Возьмет следующие 10 записей.

-- записи с 21 по 30
ORDER BY id LIMIT 10 OFFSET 20;

-- записи с 31 по 40
ORDER BY id LIMIT 10 OFFSET 30;


SELECT course_id FROM course_members ORDER BY course_id;

выбрали идентификаторы всех курсов, на которые записался хотя бы один студент. некоторые идентификаторы курсов повторяются — на них записалось по несколько студентов.

оператор DISTINCT, удаляет повторяющиеся строки запроса и оставляет только уникальные.

SELECT DISTINCT course_id FROM course_members ORDER BY course_id;

из этого запроса исключены все повторяющиеся строки.

исключить повторяющиеся строки, нужно после оператора SELECT указать DISTINCT и перечислить все нужные столбцы.

добавим еще одно поле user_id, изменит результат запроса. В эту выборку попадут строки с уникальным сочетанием курса и слушателя.

По отдельности курсы и слушатели могут повторяться, но их сочетание будет уникальным:

-- DISTINCT добавляется в запрос только один раз,
-- независимо от того, сколько колонок перечисляется
SELECT DISTINCT
    course_id,
    user_id
FROM course_members ORDER BY course_id;

выбрать уникальные курсы и добавить дату, когда на него записался первый студент.

после DISTINCT укажем course_id и created_at. Он вернет нам уникальные сочетания этих двух полей:

SELECT DISTINCT course_id, created_at FROM course_members ORDER BY course_id;

модификация оператора DISTINCT ON.
Поле, которое должно быть уникальным.
Поля, которые нужно вывести.

SELECT DISTINCT ON (course_id)
    course_id,
    created_at
FROM course_members
ORDER BY course_id, created_at;

После DISTINCT ON в скобках поле, по которому проверяться уникальность. перечисляем те поля, которые видеть в запросе.
идентификаторы курсов не повторяются, а в качестве created_at выводится первая дата выбора курса.

В DISTINCT ON можно указывать несколько полей в качестве уникальных:

SELECT DISTINCT ON (course_id, created_at)
    course_id,
    created_at
FROM course_members
ORDER BY course_id;

равносилен первому запросу этого раздела:

SELECT DISTINCT
    course_id,
    created_at
FROM course_members ORDER BY course_id;
Сортировка с оператором DISTINCT ON

При работе с DISTINCT ON правильно использовать сортировку. Первыми полями в ORDER BY должны быть те, которые идут после DISTINCT ON.

к каждому уникальному курсу выведем дату, в которую записался последний студент.
после ORDER BY сначала указать поле course_id, как того требует синтаксис. добавить поле created_at с сортировкой по убыванию:

SELECT DISTINCT ON (course_id)
    course_id,
    created_at
FROM course_members
ORDER BY course_id, created_at DESC;

все уникальные курсы и дату, когда на этот курс в последний раз записывались.




количество строк, в которых поле НЕ равно NULL.

SELECT COUNT(id) FROM users;

99 — количество строк, id которых не равен NULL.

SELECT COUNT(email_confirmed) FROM users;

0, в таблице поле email_confirmed не содержит данных.

COUNT возвращает количество записей в запросе, а не в таблице:
SELECT COUNT(*) FROM users WHERE gender = 'female';
количество девушек среди всех пользователей.

SELECT SUM(spent_minutes) FROM course_reviews;
суммарное время, проведенное всеми пользователями на онлайн-курсах.

среднее время, проведенное пользователем с id = 9 на площадке онлайн-школы:
SELECT AVG(spent_minutes) FROM course_reviews WHERE user_id = 9;

максимальное время прохождения курса:
SELECT MAX(spent_minutes) FROM course_reviews;

в функции MAX и MIN можно передавать поля числовых типов, даты и строки. Для строк минимальное значения — первая строки, по алфавиту:
SELECT MIN(username) FROM users;
пользователя Abelardo58, потому что он идет первым по алфавиту.

SELECT MAX(username) FROM users;
пользователя Zoey24, потому что он идет по алфавиту последним.

количество курсов, на которые записался каждый пользователь.
выберем уникальных пользователей в таблице course_members:
SELECT DISTINCT user_id
FROM course_members
ORDER BY user_id;

для каждого пользователя подсчитаем количество курсов.
SELECT COUNT(*) FROM course_members WHERE user_id = 2;

Группировка данных объединить одинаковые значения в заданных полях в группы, подсчеты для каждой группы.
Запрос с подсчетом курсов каждого пользователя:

SELECT
    user_id,
    COUNT(*)
FROM course_members
GROUP BY user_id
ORDER BY user_id;

создавать по отдельному запросу для каждого пользователя, но вместо этого GROUP BY user_id. объединить строки с одинаковыми идентификаторами user_id, вывести идентификатор и количество строк в каждой группе COUNT(*).

SELECT
    user_id AS student,
    COUNT(*) AS courses_count
FROM course_members
GROUP BY user_id
ORDER BY user_id;


Либо вывести поле, по которому проводим группировку. Его значение одинаковым для группы
Либо применить к полю агрегатную функцию. СУБД знать, как обработать несколько разных значений.
не группируем данные по столбцу created_at — это не то, что нам нужно. работать с группами, в которых совпадают идентификатор пользователя и дата создания.

SELECT
    user_id AS student,
    COUNT(user_id) AS courses_count,
    MAX(created_at) AS last_reg
FROM course_members
GROUP BY user_id
ORDER BY user_id;

<img width="2001" height="1908" alt="image" src="https://github.com/user-attachments/assets/e9e02551-7634-4146-8ef5-c4ca948f9449" />

оператор GROUP BY объединять одинаковые записи в группы и считать для этих групп агрегатные функции.

SELECT
    user_id,
    SUM(spent_minutes)
FROM course_reviews
WHERE user_id <= 40
GROUP BY user_id
HAVING SUM(spent_minutes) < 30
ORDER BY user_id;

убрали из исходной таблицы всех пользователей с user_id > 40, затем провели группировку и посчитали суммарное время, а после этого отсеяли тех, кто пользовался платформой дольше 30 минут.

HAVING SUM(spent_minutes) < 30 AND user_id <= 40
запрос выполняться дольше. сперва исключить ненужных пользователей, сгруппировать уже отфильтрованные данные и затем посчитать агрегатные функции.

Правильно спроектированная база не позволит в таблицу добавить две одинаковые записи, проверяет уникальность заданных полей.

TRUNCATE courses; не часть стандарта, но реализуется большинством бд.
полной очистки таблиц. эффективно, у TRUNCATE нет возможности задавать условия. СУБД сразу очищает место на диске без промежуточных этапов:

Ограничения (constraints) в SQL - правила, устанавливаемые для столбцов таблицы, определяют допустимые значения для этих столбцов. Ограничения в SQL обеспечивают целостность данных и помогают предотвратить ошибки при вставке, обновлении или удалении данных.

ограничением PRIMARY _KEY

<img width="1920" height="1080" alt="image" src="https://github.com/user-attachments/assets/c43af736-3adf-46e0-bb24-54518df39259" />

Ограничение UNIQUE, значение столбца (комбинация столбцов) в таблице уникальными.

CREATE TABLE users (
  id bigint PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
  username VARCHAR(50) UNIQUE NOT NULL,
  birthday DATE,
  email_confirmed BOOLEAN,
  email VARCHAR(255) UNIQUE NOT NULL,
  gender VARCHAR(255) NOT NULL,
  password_digest VARCHAR(255) NOT NULL,
  first_name VARCHAR(50),
  last_name VARCHAR(50),
  created_at TIMESTAMP NOT NULL
);

Ограничения позволяют гарантировать целостность данных и избежать ошибок.


Запрос ALTER TABLE, изменять структуру столбца таблицы бд.

С помощью ALTER можно добавить колонку в уже таблицу:

CREATE TABLE users (
    id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    username VARCHAR(50),
    email VARCHAR(255) UNIQUE NOT NULL,
    created_at TIMESTAMP
);


ALTER TABLE users ADD COLUMN birthday DATE;

после фразы ADD COLUMN идет строка описания новой колонки, точно такая же, как и при создании таблицы. <имя колонки> <тип>. Здесь можно указывать любые ограничения, добавлять ключи, автогенерацию, значение по умолчанию и многое другое. Синтаксис на 100% совпадает с синтаксисом определения колонки, когда таблица создается.

переименовать колонку:

-- добавляем колонку, которой еще нет.
ALTER TABLE users ADD COLUMN name VARCHAR(255);
-- изменить колонку "name":
-- поменять имя с "name" на "first_name"
ALTER TABLE users RENAME COLUMN name TO first_name;

удаляет колонку:

ALTER TABLE users ADD COLUMN age DATE;
-- удалить колонку с именем "age"
ALTER TABLE users DROP COLUMN age;

изменению параметров колонки. у каждого элемента, который поддается обновлению, есть собственный синтаксис для этого обновления.

CREATE TABLE courses (
    id bigint PRIMARY KEY,
    name varchar(255) NOT NULL,
    body text,
    created_at timestamp
);

-- Установка ограничения уникальности в таблице courses для колонки name
ALTER TABLE courses
ADD UNIQUE (name);

-- Изменение типа данных в таблице courses для колонки created_at
-- и снятие ограничения NOT NULL в таблице courses для колонки name
ALTER TABLE courses
ALTER COLUMN created_at SET DATA TYPE DATE,
ALTER COLUMN name DROP NOT NULL;

-- Установка ограничения NOT NULL в таблицу courses для колонки name
ALTER TABLE courses
ALTER COLUMN name SET NOT NULL;

ADD -- добавление ограничения: например, ключа или уникальности
SET -- установка значения: например, типа данных
DROP -- удаление ограничения
В рамках одного обновления можно группировать операции, но существует ряд исключений. группировке не поддается операция RENAME -- ее отдельным запросом, иначе запрос с ошибкой.


переименование или удаление колонок -- небезопасные процессы. удалить колонки в работающей базе, ошибкам, вставлять или обновлять записи. выборки, включающие эту колонку, с ошибкой.

операции выполняют только когда уверенность, эти колонки никто не использует. обновление колонки влиять на производительность. данных много, обновляться продолжительное время.

Получаем количество денег пользователя:
   SELECT amount FROM accounts WHERE user_id = 10;
Списываем необходимую сумму со счета этого пользователя:
   UPDATE accounts SET amount = amount - 50 WHERE user_id = 10;
Зачисляем деньги другому пользователю:
   UPDATE accounts SET amount = amount + 50 WHERE user_id = 30;

отсутствует гарантия завершения. система успела выполнить списание, произошла ошибка, выключили питание или компьютер перезагрузился. деньги списались, но никуда не зачислились:

Приложения по возможности должны находиться в согласованном состоянии. В распределенных системах это невозможно, добиться этого можно с помощью механизма транзакций. изучив CAP-теорему и Eventual Consistency.

Операция снятия денег -- процесс, не только к множеству запросов в базу, но и к затрагиванию многих систем. У них есть свои процессы и базы внутри.

транзакции атомарность -- когда операция либо завершается успешно, либо не проходит. За обеспечением необходимых гарантий следит СУБД, а не программист:

BEGIN;
SELECT amount FROM accounts WHERE user_id = 10;
UPDATE accounts SET amount = amount - 50 WHERE user_id = 10;
UPDATE accounts SET amount = amount + 50 WHERE user_id = 30;
COMMIT;

Транзакции в PostgreSQL -- блок запросов, обрамляется запросами:

BEGIN -- открытие транзакции
COMMIT -- закрытие транзакции
ошибка внутри транзакции откатывает все изменения, которые были сделаны после запроса BEGIN:

<img width="878" height="1080" alt="image" src="https://github.com/user-attachments/assets/7b05645d-665e-451e-93aa-ef7baf2d2a45" />

транзакцию откатить самостоятельно. ROLLBACK до COMMIT. нужно, когда выполняются запросы из кода приложения.

BEGIN;
UPDATE accounts SET amount = amount - 50 WHERE user_id = 10;
ROLLBACK;

транзакция надежной и предсказуемой - соблюдать требования к транзакционной системе

Atomicity (Атомарность)
транзакция не может быть частично завершена -- либо выполнена, либо нет.

Consistency (Согласованность)
Завершившаяся транзакция должна сохранять согласованность бд. успешная транзакция фиксирует только допустимые результаты, в процессе работы транзакции данные могут оказываться несогласованными.
снятие денег с счета приводит к тому, что данные рассинхронизированы. Но когда транзакция завершается, этого нет.
Гарантию согласованности данных нельзя полностью обеспечить только средствами бд, ограничениями. Поддержка` требования включает работу со стороны программистов, которые пишут для этого код.

Isolation (Изолированность)
Когда транзакция выполняется, параллельные транзакции не должны оказывать влияния на ее результат. Ни одна транзакция не может увидеть изменения, которые сделаны другими незавершенными транзакциями. Изолированность -- дорогое требование, в реальных БД сущ режимы, изолируют транзакцию не полностью -- уровни изолированности Repeatable Read и ниже.

Durability (Устойчивость)
Изменения, которые сделаны успешно завершенной транзакцией, должны остаться сохраненными после возвращения системы в работу. не должно зависеть от проблем на нижних уровнях, обесточивание системы или сбои в оборудовании. пользователь получил подтверждение от системы, что транзакция выполнена, он уверен, что ничего не отменится из-за сбоя.

выполнять запросы внутри транзакции. операции нельзя выполнить за один запрос, проходить несколько шагов. набор свойств транзакции гарантирует, что данные в БД целостные независимо от сбоев.
