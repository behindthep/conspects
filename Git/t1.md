git branch newImage
The branch newImage now refers to the actual commit


Choose the branch for commiting
git checkout newImage
(git switch)


Create a new branch and check it out at the same time
git checkout -b name


Merging branch into main* (staying on main branch) - creates new merge commit on main*
git merge bugFix


current branch - git merge branch that you want merge with

Placed on bugFix aand merge with main

git checkout bufFix; git merge main


For combining commits with linear sequence. With bugFix selected
git rebase main

Now bugFix copies of commits move at the top of main branch (rebased onto main), so history is linear

Checked out on the main and rebase onto bugFix
Move the main branch reference forward on history


HEAD points to the current branch on the recent (last) commit

Detaching HEAD - attaching it to a commit instead of a branch.

Was:
HEAD -> main -> Commit1

Git checkout Commit1

Now:
HEAD -> Commit1

Changes are not effect of any branches


Relative refs
allow us use HEAD or branch name to moving on history

git checkout main^.  Find the parent of the specified commit. Now HEAD points on commits parent. This detach HEAD
Git cheackout commit2;
git checkout HEAD~3.   Num times moves HEAD to parents

-f option (not allowed for current branch) reasign a branch to a commit
git branch -f main HEAD~3
Moves by force the main branch to three parents behind HEAD


Rrvering changes

Revers changes by moving a branch reference backwars in time to an older commit.
git reset HEAD~1

Reverse last commit changes and share those with others - create commit with reversed changes:
git revert HEAD


git cherry-pick C1 C2 ...
Copy commits below HEAD (after - make them lasts)



Git Interactive Rebase
Git cherry-pick is great when you know which commits you want (and their hashes).

you don't know what commits you want? interactive rebasing -- review a series of commits you're about to rebase.

All interactive rebase - Git using rebase command with -i.
open up a UI to show you which commits are about to be copied below the target of the rebase.

reorder commits.
choose to keep all commits or drop specific ones. When the dialog opens, each commit is set to be included.
squashing (combining) commits, amending commit messages, editing the commits themselves.

git rebase -i HEAD~4

Git copied down commits in the same way you specified through the UI.


Locally stacked commits
track down a bug but it is quite elusive. In order to aid in my detective work, I put in a few debug commands and a few print statements.

All of these debugging / print statements are in their own commits. Finally I track down the bug, fix it, and rejoice!

need to get my bugFix back into the main branch. If I fast-forwarded main, then main get all my debug statements which is undesirable.

copy only one of the commits over.

git rebase -i
git cherry-pick



Juggling Commits
changes (newImage) and another set of changes (caption) that are related, so they are stacked on top of each other in your repository (aka one after another).

make a small modification to an earlier commit. change newImage, even though that commit is way back in history!

re-order the commits so the one we want to change is on top with git rebase -i
git commit --amend to make modification
Then re-order the commits back to how they were previously with git rebase -i
Finally move main to this updated part of the tree

Once the commit we wanted to change was on top, we could --amend it and re-order back to our preferred order.

git cherry-pick will plop down a commit from anywhere in the tree onto HEAD (as long as that commit isn't an ancestor of HEAD).


Git Tags
branches are easy to move around and often refer to different commits as work is completed on them.

permanently mark historical points in your project's history. For things like major releases and big merges, mark these commits with something more permanent than a branch?

Git tags permanently mark certain commits as "milestones" that you can then reference like a branch.

You can't "check out" a tag and then complete work on that tag -- tags exist as anchors in the commit tree that designate certain spots.

git tag v1 C1
(version 1)


Git Describe
tags serve as such great "anchors" in the codebase, git has a command to describe where you are relative to the closest "anchor" (tag).

get your bearings after you've moved many commits backwards or forwards in history; after you've completed a git bisect (a debugging search).


git describe <ref>

<ref> ('main' for example) is anything git can resolve into a commit. If you don't specify a ref, git uses where you're checked out right now (HEAD).

The output of the command:

<tag>-<numCommits>-g<hash>

tag is the closest ancestor tag in history, numCommits is how many commits away that tag is, and <hash> is the hash of the commit being described.


Rebasing Multiple Branches
rebase all the work from these branches onto main.

git rebase main bugFix
bugFix встанет за main
git rebase c2
ветка станет на коммит c2

Specifying Parents
Like the ~ modifier, the ^ modifier also accepts an optional number after it.

Rather than specifying the number of generations to go back (what ~ takes), the modifier on ^ specifies which parent reference to follow from a merge commit. merge commits have multiple parents, so the path to choose is ambiguous.

Git will follow the "first" parent upwards from a merge commit, but specifying a number with ^ changes this default behavior.

have a merge commit. If we checkout main^ without the modifier, we will follow the first parent after the merge commit.

git checkout main^ первый родитель (обычно ветка, в которую вливали изменения)
git checkout main^2 второй родитель (обычно ветка, которую влили)

HEAD or main эквивалентно можно использовать в командах

git branch -f three C2
ветку три переместить на коммит


git fetch удалённый репозиторий, содержит два коммита, отсутствующих в локальном.
Коммиты C2 и C3 скачаны в локальный репозиторий, удалённая ветка o/main отобразила эти изменения.

связывается с удалённым репозиторием и забирает данные проекта, которых ещё нет
должны появиться ссылки на все ветки из удалённого репозитория (o/main)
git fetch синхронизирует локальное представление удалённых репозиториев с тем, что является актуальным на текущий момент.

удалённые ветки отображают состояние удалённых репозиториев на тот момент когда вы 'общались' с ними в последний раз.
git fetch 'общается' с удалёнными репозиториями посредством Интернета (через протоколы http:// или git://).

git fetch забирает данные в локальный репозиторий, но не сливает их.

обновим работу, отобразить изменения!
локальный коммит, соединить с другой веткой.
git cherry-pick o/main
git rebase o/main
git merge o/main

Процедура скачивания (fetching) изменений с удалённой ветки и объединения (merging) - git pull.

git fetch; и git merge origin/main; - скачали C3 с fetch и объединяем наработки с git merge o/main. ветка main отображает изменения с удалённого репозитория. git pull делает тоже самое.





история версий «Revision history». зафиксированное изменение в системе контроля версий ревизией.

Фиксация изменений создаёт ревизию, ревизия может содержать внутри либо дельту изменений, либо снимок.

процесс переключения между ревизиями. загружаем ревизию, переключаемся на неё (checkout).

Между ревизиями выявлять различия в случае, если СКВ использует снимки, демонстрирует Word.

diff index.js index2.js > index.patch

patch index.js -i index.patch -o index2.js


повелительного наклонения в заголовке: «Fix scrolling» (Исправить прокрутку), а не «Fixed scrolling» (Исправлена прокрутка) или «Fixes scrolling» (Исправляет прокрутку).
Атомарность. Коммит решать одну задачу от начала до конца.  откатить изменение или перенести его в другую версию программы.


перед началом работы всегда git pull --rebase, скачивает из репозитория коммиты и добавляет в локальный.
git pull, к созданию ненужных коммитов, сложнее следить за историей.
работа с git pull знания ветвление и git rebase.


git diff показывает разницу между тем, что было и что стало. запускает пейджер искать (/слово) внутри него нужные данные.
git diff не были добавлены в индекс.
git diff --staged # были добавлены в индекс

git diff обязательно запускать перед каждым коммитом. случайно добавляют в коммит что не должно.

коммиты имеют понятное описание, и каждый из них делает одну законченную вещь — история инструментом для анализа кода.

git log список всех выполненных коммитов через пейджер
git log -p # диф для каждого коммита
git log -- file - в каких комитах менялся

У коммита — идентификатор («хеш»). посмотреть все изменения, сделанные в коммите:
git show 5120bea # диф между этим коммитом и предыдущим


не знаем коммита, кто последним менял строчку в файле? выводит файл и рядом с строчкой показывает кто ее менял и в каком коммите:

git blame INFO.md
e6f625cf (tirion 2020-09-17 16:14:09 -0400 1) git is awesome!
5120bea3 (tirion 2020-09-17 18:04:19 -0400 2) new line

git grep ищет совпадение с строкой во всех файлах проекта. знает про игнорирование и не смотрит в .git, искать по истории:

git grep -i hexlet # без учета регистра
git grep Hexlet 5120bea # Поиск в коммите

git grep Hexlet $(git rev-list --all) # Поиск по истории. список хешей `rev-list`

откат изменений, в рабочей директории, но еще не попали в коммит. откат незакоммиченных изменений безвозвратен.

добавили новые файлы в репозиторий, что они вам не нужны.
# удалит все неотслеживаемые файлы -f – force, -d – directory
git clean -fd

# Отменяем Измененные файлы в рабочей директории
git restore INFO.md

С файлами, подготовленными к коммиту — отменить изменения совсем, второй — отменить индексацию, не изменяя файлы в рабочей директории. изменения нужны, не хотим их коммитить сейчас:

git restore --staged INFO.md

git restore - окончательно отменить изменения


В Git есть способ восстановить или изменить коммиты.
Git движется «только вперед». создавать новое, а не изменять старое.
новым коммитом, изменяющим код в нужном направлении. Изменение истории коммитов — опасная операция, чревата проблемами при синхронизации с удаленными репозиториями.

отмена изменений. к созданию коммита, выполняет изменения, противоположные тому коммиту, который отменяется:

<img width="723" height="343" alt="image" src="https://github.com/user-attachments/assets/ab0049b5-acad-4f5e-8f50-974f7dbc577f" />

автоматизирующую откат git revert:

git revert aa600a4
# сообщение revert не меняют
[main 65a8ef7] Revert "remove PEOPLE.md"
 1 file changed, 1 insertion(+)
 create mode 100644 PEOPLE.md
# В проект вернулся файл PEOPLE.md

git log -p

commit 65a8ef7fd56c7356dcee35c2d05b4400f4467ca8
Author: tirion <tirion@got.com>
Date:   Sat Sep 26 15:32:46 2020 -0400

    Revert "remove PEOPLE.md"

    This reverts commit aa600a43cb164408e4ad87d216bc679d097f1a6c.

diff --git a/PEOPLE.md b/PEOPLE.md
new file mode 100644
index 0000000..4b34ba8
--- /dev/null
+++ b/PEOPLE.md
@@ -0,0 +1 @@
+Haskell Curry

Команда revert может отменять не только последний коммит, но и любой другой коммит из истории проекта. Согласитесь, это очень круто. Без системы контроля версий о таком нельзя было и мечтать.

git reset
удалить только что сделанный по ошибке коммит. git revert, но история менее читаемой. коммит сделан только сейчас и еще не отправлялся на GitHub, сделать будто коммита не существовало.
удалять коммиты если речь про коммиты, которых нет ни у кого, кроме вас.
Если коммит был отправлен во внешний репозиторий,  менять историю нельзя. сломает работу у тех, кто работает с вами над проектом.

Для удаления коммита git reset:

# Добавляем новый коммит, сразу же удалим
echo 'test' >> INFO.md
git add INFO.md
git commit -m 'update INFO.md'

[main 17a77cb] update INFO.md
 1 file changed, 1 insertion(+)
 # не делаем git push

git reset --hard HEAD~

HEAD is now at 65a8ef7 Revert "remove PEOPLE.md"

# `git log`, последнего коммита там больше нет
git reset удалять коммиты, отменять их без удаления, восстанавливать файлы из истории и так далее.
--hard полное удаление. Без него git reset отменит коммит, но не удалит его, а поместит все изменения этого коммита в рабочую директорию, с ними можно будет продолжить работать.
HEAD~ «один коммит от последнего коммита». удалить два последних коммита, HEAD~2:

<img width="745" height="343" alt="image" src="https://github.com/user-attachments/assets/15921e44-e427-42c1-8235-82af2e621073" />

HEAD — последний сделанный коммит.
Без --hard команда git reset по умолчанию работает в режиме --mixed, изменения остаются в рабочей директории, но исключаются из индекса (unstage). исправить или отменить и выполнить новый коммит:

echo 'no code no pain' >> README.md
git add README.md
git commit -m 'update README.md'

[main f85e3a6] update README.md
 1 file changed, 1 insertion(+)

# откатываем последний коммит
git reset HEAD~

Unstaged changes after reset:
M   README.md

git status

On branch main
Your branch is up to date with 'origin/main'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
    modified:   README.md

--soft сохранить изменения в индексе:

git reset --soft HEAD~1

git status

On branch main
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
    modified:   README.md

git reset --soft отменяет коммит, но оставляет изменения в индексе (staging area). Следующий коммит включит в себя те же изменения, если их не модифицировать.

Последнего коммита больше не существует. сделанные в нем изменения не пропали. Они находятся в рабочей директории для дальнейшей доработки.

<img width="749" height="575" alt="image" src="https://github.com/user-attachments/assets/6feac47d-c455-465b-a163-7646ceaa7c4a" />

отменять, даже если допущена ошибка.
git revert — безопасный способ отмены коммитов. Он создаёт новый коммит, отменяет изменения предыдущего. не меняет историю коммитов.
git reset — опасный инструмент. отменять коммиты, но при этом может изменить или удалить изменения:

git reset --soft оставляет изменения в индексе.
git reset --mixed (по умолчанию) снимает индексацию, но оставляет изменения в рабочей директории.
git reset --hard полностью удаляет изменения, и их нельзя восстановить без специальных команд.
Изменять историю коммитов с осторожностью. Если коммиты уже отправлены в удалённый репозиторий - git revert. git reset к проблемам при синхронизации с другими разработчиками.

подход в Git — двигаться вперёд. Если в коммите ошибка, проще сделать новый исправляющий коммит, чем менять историю.

Перед использованием git reset --hard убедиться, изменения не будут потеряны.


git add README.md
git commit --amend --no-edit

--amend не добавляет изменения в сущ коммит. откату коммита через git reset и выполнению нового коммита с новыми данными. один коммит, git commit выполнялась два раза (первый раз — когда сделали ошибочный коммит).


Индекс — промежуточная область, в которой хранятся изменения файлов на пути от рабочей директории до репозитория. При выполнении коммита в него только те изменения, которые были добавлены в индекс.



коммит, в который включили и основную задачу, и доп исправления. сложнее смотреть историю. Коммит содержать несвязанные изменения, отвлекают во время проверки чужого кода:

# условие И в описании
git commit -m 'add new feature and fix something'

откат коммита - откатятся правки, которые все равно нужно делать.

# Не нужно явно вызывать `git add`
git commit INFO.md -m 'update INFO.md'

перед коммитом смотреть git diff --staged.

коммит с одновременным добавлением всего в индекс:

# -a добавляет все изменения в индекс
git commit -am 'do something'
разные изменения делаются в одних и тех же файлах. изменения в этих файлах в разных коммитах.

git add -i, показывает измененные куски файлов и спрашивает, что с ними сделать

# сокращенный вывод
git log --oneline

fc74e2d update README.md
65a8ef7 Revert "remove PEOPLE.md"

Переключимся на момент, когда был выполнен коммит с сообщением add INFO.md. git checkout <хеш коммита>:

git checkout e6f625c

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by switching back to a branch.

Or undo this operation with:

  git switch -
  
пропала часть изменений из-за возврата в прошлое. вернуться на последний коммит:
git checkout main

забрать изменения, которые были удалены, но понадобились. их скопировать, переключиться на последний коммит и вставить в нужный файл.

git branch
Переключение по коммитам отражается только на содержимом рабочей директории. 
узнать место нахождения — вызвать команду git branch. находимся на последнем коммите, Git покажет вывод:

git branch

* main

загружен коммит из прошлого:

* (HEAD detached at e6f625c)
  main

# Если на последнем коммите
hexlet-git git:(main)

# Если на коммите из прошлого
hexlet-git git:(e6f625c)

В Bash вывод местоположения редактированию переменной окружения $PS1
https://ru.hexlet.io/blog/posts/kak-prisoedinitsya-k-rabote-nad-opensorsom-chto-takoe-ps1-i-drugie-voprosy-otvechaet-razrabotchik-heksleta-andrey-moshkov#chto-takoe-ps1-i-dlya-chego-ispolzuetsya

наибольший эффект при работе с Git в команде. ситуаций, возникающих при совместной работе над кодом.

выведем коммиты проекта

git log --graph

* commit e7bb5e51f96e572084f6c04ba3312e32ce6b8c0f (HEAD -> main, origin/main, origin/HEAD)
|
|     update README.md
|
* commit 65a8ef7fd56c7356dcee35c2d05b4400f4467ca8
|
|     Revert "remove PEOPLE.md"
|
|     This reverts commit aa600a43cb164408e4ad87d216bc679d097f1a6c.

полоску слева отражает связи между коммитами. новый коммит базируется на коде предыдущего. коммиты выстраиваются в односвязный список. каждый элемент ссылается на предыдущий. Последний элемент головой списка (head).

В Git элементы списка — коммиты. Как и в односвязном списке, новый коммит — элемент, имеет ссылку на предыдущий коммит. Предыдущий коммит ссылается на свой предыдущий, и так далее до первого коммита, который никуда не ссылается.

«голова списка» (HEAD). удаление последнего коммита:

# HEAD~1: взять голову и удалить один коммит, начиная от нее
# удаляем только последний коммит
git reset --hard HEAD~1
список коммитов называется main. список - веткой (branch). команда для показа текущего местоположения в истории git branch

git branch

* main

ветка в Git — подвижный указатель на один из коммитов. При новом коммите указатель сдвигается вперед автоматически.

работа Git — формировать односвязный список из коммитов. большинство команд Git — небольшие программы, умеют ходить по этому списку и извлекать нужную информацию. блуждаем по этому списку, меняем его и добавляем новые коммиты.

Ветки
цепочка коммитов в Git это не просто односвязный список. направленный ациклический граф — множество односвязных списков, переплетенных вместе.

в один момент два разных человека должны делать какие-то длинные задачи, требующие нескольких дней разработки или даже больше. main-ветка должна оставаться рабочей: коммитить промежуточные изменения в нее нельзя, изменения могут сломать код.

отпочковаться от основного списка — сформировать ветку. создается отдельный список коммитов, идет мимо главной ветки. В конце разработки все коммиты из такой ветки вливаются обратно в main-ветку:

<img width="1280" height="720" alt="image" src="https://github.com/user-attachments/assets/fef9fefa-bbf4-45b7-a0d2-adb86c8ee613" />

# Игнорируем файл в любой директории проекта
access.log

# Игнорируем директорию в любой директории проекта
node_modules/

# Игнорируем каталог в корне рабочей директории
/coverage/

# Игнорируем все файлы с расширением sqlite3 в директории db
# При этом не игнорируются такие же файлы внутри любого вложенного каталога в db
# Например, /db/something/lala.sqlite3
/db/*.sqlite3

# Игнорировать все .txt файлы в каталоге doc/ на всех уровнях вложенности
doc/**/*.txt

добавил в репозиторий файл, который нужно проигнорировать. недостаточно обновить правила игнорирования. удалить файл или директорию из Git с помощью git rm и закоммитить.
git rm file -- cached - удалить фалй из репозитория(гит перестанет его отслеживать), файл останется в рабочей директории.


работаете над задачей и исправили довольно много файлов. появляется срочная задача — сделать изменение в исходном коде, не связанное с тем, над чем вы сейчас работаете. изменения еще не готовы, и они не должны попасть в репозиторий.

изменения не пересекаются с изменениями по срочной задаче. внести исправления, добавить их в индекс, закоммитить и запушить. изменения в тех файлах, с которыми вы работаете сейчас?

# пропадут все измененные файлы независимо, добавлены они в индекс или нет
git stash

попадают в специальное место внутри директории .git на временное хранение. Эта команда не трогает новые файлы, не являются частью репозитория:

<img width="1280" height="720" alt="image" src="https://github.com/user-attachments/assets/f7bc1d73-4a89-4984-ae77-1fb8130b0fb5" />

После выполнения всех изменений в чистой рабочей директории вернуть спрятанные изменения:

git stash pop

Стэш в Git работает по принципу стека. сохранить внутрь любое количество изменений и восстановить их в обратном порядке:

git stash

# Изменяем файлы
git stash

# Возвращаем последние изменения
git stash pop

# Возвращаем предпоследние изменения
git stash pop

Проекты с открытым исходным кодом или OpenSource (Open Source Software, OSS) — по с общедоступным кодом. пользователь может увидеть код.

К такому ПО относятся:

Прикладное ПО и сервисы, как VSCode или Git
Огромное число библиотек в нашем коде
Практически все современные языки программирования


запрос на включение изменений - pull request.
создаем копию репозитория Fork на странице репозитория
клонируем репозиторий на компьютер и производим изменения в отдельной ветке, созданной от main.

залили изменения на GitHub. На странице склонированного репозитория кнопка Pull request
После отправки пулреквеста в оригинальном репозитории на странице Pull requests отобразится ваш запрос.
