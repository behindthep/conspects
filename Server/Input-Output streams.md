Для ввода данных класс Scanner из библиотеки пакетов Java.
класс импортировать в той программе, где он будет использоваться. до начала открытого класса в коде программы.

В классе методы для чтения очередного символа заданного типа со стандартного потока ввода, для проверки существования такого символа.

Для работы с потоком ввода создать объект класса Scanner, при создании указав, с каким потоком ввода он будет связан. Стандартный поток ввода (клавиатура) в Java представлен объектом — System.in.
стандартный поток вывода (дисплей) — объектом System.out. стандартный поток для вывода ошибок — System.err.

```java
import java.util.Scanner; // импортируем класс

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in); // создаём объект класса Scanner
        int i = 2;
        System.out.print("Введите целое число: ");
        if(sc.hasNextInt()) { // возвращает истину если с потока ввода можно считать целое число
          i = sc.nextInt(); // считывает целое число с потока ввода и сохраняем в переменную
          System.out.println(i*2);
        } else {
          System.out.println("Вы ввели не целое число");
        }
    }
}
```

hasNextDouble(), применённый объекту класса Scanner, можно ли считать с потока ввода вещественное число типа double, а метод nextDouble() — считывает его.

считать значение без предварительной проверки, во время исполнения программы можно получить ошибку (отладчик заранее такую ошибку не обнаружит). в представленной далее программе ввести какое-то вещественное число:

```java
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        double  i = sc.nextDouble(); // если ввести букву s, то случится ошибка во время исполнения
        System.out.println(i/3);
    }
}
```

nextLine(), считывать целую последовательность символов, строку, полученное через этот метод значение нужно сохранять в объекте класса String.
создаётся два таких объекта, потом в них поочерёдно записывается ввод пользователя, на экран выводится одна строка, полученная объединением введённых последовательностей символов.

```java
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s1, s2;
        s1 = sc.nextLine();
        s2 = sc.nextLine();
        System.out.println(s1 + s2);
    }
}
```

hasNext(), проверяющий остались ли в потоке ввода какие-то символы.

В классе String полезных методов, применять к строкам (перед именем метода указывать тип того значения, которое он возвращает):

int length() — возвращает длину строки (количество символов в ней);
boolean isEmpty() — проверяет, пустая ли строка;
String replace(a, b) — возвращает строку, где символ a (литерал или переменная типа char) заменён на символ b;
String toLowerCase() — возвращает строку, где все символы исходной строки преобразованы к строчным;
String toUpperCase() — возвращает строку, где все символы исходной строки преобразованы к прописным;
boolean equals(s) — возвращает истинну, если строка к которой применён метод, совпадает со строкой s указанной в аргументе метода (с помощью оператора == строки сравнивать нельзя, как и любые другие объекты);
int indexOf(ch) — возвращает индекс символа ch в строке (индекс это порядковый номер символа, но нумероваться символы начинают с нуля). Если символ совсем не будет найден, то возвратит -1. Если символ встречается в строке нескольо раз, то вовзвратит индекс его первого вхождения.
int lastIndexOf(ch) — аналогичен предыдущему методу, но возвращает индекс последнего вхождения, если смивол встретился в строке несколько раз.
int indexOf(ch,n) — возвращает индекс символа ch в строке, но начинает проверку с индекса n (индекс это порядковый номер символа, но нумероваться символы начинают с нуля).
char charAt(n) — возвращает код символа, находящегося в строке под индексом n (индекс это порядковый номер символа, но нумероваться символы начинают с нуля).

```java
public class Main {
    public static void main(String[] args) {
        String s1 = "firefox";
        System.out.println(s1.toUpperCase()); // выведет «FIREFOX»
        String s2 = s1.replace('o', 'a');
        System.out.println(s2); // выведет «firefax»
        System.out.println(s2.charAt(1)); // выведет «i»
        int i;
        i = s1.length();
        System.out.println(i); // выведет 7
        i = s1.indexOf('f');
        System.out.println(i); // выведет 0
        i = s1.indexOf('r');
        System.out.println(i); // выведет 2
        i = s1.lastIndexOf('f');
        System.out.println(i); // выведет 4
        i = s1.indexOf('t');
        System.out.println(i); // выведет -1
        i = s1.indexOf('r',3);
        System.out.println(i); // выведет -1
    }
}
```

выведет на экран индексы всех пробелов в строке, введенноё пользователем с клавиатуры:

```java
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine();
        for(int i=0; i < s.length(); i++) {
            if(s.charAt(i) == ' ') {
                System.out.println(i);
            }
        }
    }
}
```





Функция печати записывает данные в поток STDOUT (1) функцией write
ОС решает, куда вывести результат. По умолчанию на экран терминала

ЯП не взаимодействуют с железом, уметь писать в STDOUT, а дальше все сделает ОС. Программы могут только попросить ОС выполнить задачу.


перенаправление потоков.
вывод команды не выводить на экран, а записать в файл:
ls -la > output

> - перезаписывает файл, >> - добавляет. взять вывод из команды и отправить его в файл.


Кроме стандартного вывода, с каждым процессом ассоциируются два потока:

STDERR — вывод ошибок
STDIN (0) — стандартный ввод, через него программа может получать данные на вход.

wc (word count). считать количество слов, строк или символов в файле. Когда говорим о файле, в *nix-системах означает, что данные можно передать и в стандартный поток ввода:

# Флаг l считать количество строк
wc -l < result # Содержимое result в стандартный ввод команды wc

стрелка меняет направление и содержимое файла отправляется в поток STDIN запускаемой программы wc.

объединим перенаправление ввода и вывода:
wc -l < result > output # Содержимое result в стандартный ввод команды wc, а вывод в файл output

отправить вывод на печать.

<img width="2048" height="1336" alt="image" src="https://github.com/user-attachments/assets/6651a098-da0e-4356-a5dc-38282b14d051" />

Поток STDERR (2) отделить вывод программы от ошибок.

Как и STDOUT, он выводит информацию на экран.

перенаправление вывода в файл перенаправляет только STDOUT.
отобразить содержимое несущ директории, команда ls выдаст ошибку:

ls lala > output # Направляем вывод команды ls в файл output

ls: cannot access 'lala': No such file or directory # Вывод на экран
Перенаправление есть, но сообщение вывелось на экран. STDERR остался привязан к экрану, а внутри файла output — пустота.

Перенаправление STDERR в STDOUT
за каждым потоком закреплен файловым дескриптором. доступ к потокам ввода и вывода.

перенаправить STDERR в STDOUT или отправить оба потока в файл.

стандартный поток ошибок объединяют со стандартным потоком вывода, обрабатывать ошибки и результат выполнения вместе:

# STDOUT перенаправляется в файл output, затем STDERR перенаправляется в STDOUT, запись в файл продолжается
ls lala > output 2>&1

ls: cannot access 'lala': No such file or directory # Содержимое файла output в окне терминала

& ставить, указать поток, в который осуществляется перенаправление.

2>&1 перед > output. не будет работать, интерпретатор прочитает 2>&1, еще не будет знать, куда перенаправлен стандартный поток вывода. потоки ошибок и вывода не будут объединены:

ls lala 2>&1 > output

ls: cannot access 'lala': No such file or directory # Вывод в окне терминала
Перенаправление потока STDERR само по себе, без вывода в файл:

#  STDERR просто перенаправляется в другой поток (STDOUT)
cd lala 2>&1

-bash: cd: lala: No such file or directory

Перенаправление потока в файл - указать номер перед >:

#  перенаправить STDERR в файл
cd lala 2> output

-bash: cd: lala: No such file or directory

Перенаправление обоих потоков в файл

# Оба потока (STDERR и STDOUT) перенаправляются в файл
cd lala &> output

-bash: cd: lala: No such file or directory





у процесса есть вход, а у другого — выход. При этом их можно подменять. их можно соединить.
соединять программы и протаскивать данные сквозь них. Получается цепочка функций, в которой каждое звено выступает в роли преобразователя или фильтра.

погрепать по нескольким словам. Не важно, как они расположены внутри строки, главное, что они встречаются там вместе.

grep PATH .profile | grep local

PATH="$HOME/.local/bin:$PATH"
| — пайп. командная оболочка должна взять поток STDOUT одного процесса и соединить его с потоком STDIN другого процесса.

Все утилиты, которые читают файлы, могут принимать данные через поток STDIN. Поскольку утилита grep принимает на вход и возвращает текст, то его можно комбинировать бесконечно:

<img width="1975" height="1059" alt="image" src="https://github.com/user-attachments/assets/65fbbe99-e801-4646-91c3-6b65e6400448" />


Запись grep PATH .profile | grep local можно изменить, используя перенаправление. Так она станет проще для модификации:

cat .profile | grep PATH | grep local
файл читается катом и отправляется в поток STDIN грепа.


cat source | grep Dog | uniq | sort

Читается файл source
Грепаются входные данные по подстроке Dog
Убираются дубли (в исходном файле две одинаковых строки Dog)
Сортируются входные данные и выводятся на экран
Пайплайн стал основой философии Unix, которая звучит так:

Пишите программы, которые делают что-то одно и делают это хорошо
Пишите программы, которые бы работали вместе
Пишите программы, которые бы поддерживали текстовые потоки, поскольку это универсальный интерфейс
Именно поэтому большинство утилит работают с сырым текстом — принимают его на вход и возвращают в поток STDOUT.

сложное поведение из крайне простых составных блоков. концепция стандартные интерфейсы и отражена в конструкторах Lego.


~ - домашняя директория


В *nix-системах нет понятия «переименовать файл». перемещению:

mv file renamed-file

Имя источника (откуда копируем)
Имя приемника (куда копируем)

cp renamed-file renamed-file-copy

Для копирования директории флаг -r (recursive).


флагом -p (--parents), создает директории рекурсивно:
mkdir -p one/two/three


флаг -r (recursion). режим рекурсивного удаления содержимого директорий. просмотр содержимого во всех вложенных директориях и поддиректориях до самого конца:

rm -r my-dir

внутри директории содержатся файлы или директории с ограниченными правами доступа, например, доступные только для чтения. команда rm начнет задавать вопрос по каждому из них, нужно ли удалять файл.

удалить нужно все, флаг -f (--force). игнорировать несуществующие файлы и не запрашивать подтверждение на удаление. rm удалит всю директорию без вопросов:

rm -rf one



cd без аргументов делает домашнюю директорию пользователя рабочей. она узнает о том, где находится домашняя директория?

Можно предположить, что команда cd каким-то образом обращается к операционной системе и узнает у нее эту информацию или смотрит напрямую в конфигурационных файлах. Но ни первого, ни второго она не делает.

Эта команда ориентируется на переменную окружения.


Переменные окружения похожи на переменные в яп. Они сущ в рамках запущенной сессии командной оболочки, переменные пропадут, когда терминал закроется. Они подгружаются туда во время его инициализации, хотя это не единственный путь их появления.

установленные переменные env.

TERM=xterm-256color
SHELL=/bin/bash
LC_ALL=en_US.UTF-8
USER=kirill.m
HEXLET_VERSION=v2711
PATH=/home/kirill.m/bin:/home/kirill.m/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
PWD=/home/kirill.m
LANG=en_US.UTF-8
SHLVL=1
HOME=/home/kirill.m
LOGNAME=kirill.m

слева от знака равно расположено имя переменной, справа — значение. В вашем случае вывод команды env будет отличаться не только значениями этих переменных, но и их составом. Например, у вас точно не будет HEXLET_VERSION, но наверняка будет HOME, только с другим значением.

предназначение переменных окружения — конфигурирование системы и программ. Их удобство заключается в универсальности. Кроме того, они помогают отвязать нас от способа появления этих значений в системе.

cd знает лишь то, что домашняя директория доступна в переменной окружения HOME. Как она попала в систему — не важно.

Без переменной окружения пришлось бы делать одну из двух вещей:

При вызове cd каждый раз указывать, где находится домашняя директория. Например, так: cd --home-dir /home/kirill.m.
Договариваться, что где-то будет храниться специальный файл с настройками, в том числе домашней директории. Настройки из этого файла будут читаться командой cd при каждом запуске
набор переменных, которые всегда устанавливаются bash при старте. используются большим количеством утилит и нужны для функционирования системы.

# Для вывода переменной используется echo, а перед самой переменной ставится знак $
echo $HOME

/home/kirill.m

# Вокруг знака `=` не должно быть пробелов
HOME=/tmp
echo $HOME

/tmp

# Возвращаем обратно
HOME=/home/kirill.m
echo $HOME

/home/kirill.m

установить HOME и выполнить переход в эту директорию с помощью команды cd, которая должна отправить нас в домашнюю директорию:

# присваивание слева от запускаемой команды
HOME=/tmp cd

/tmp

pwd

/tmp

cd выполнила переход по пути, указанном в переменной HOME. Теперь снова сделаем cd, но не добавляя определение переменной слева:

cd
pwd

/home/kirill.m

echo $HOME

/home/kirill.m

переход в настоящую домашнюю директорию. вызов HOME=/tmp cd изменил переменную только для того конкретного запуска. задавать значение переменной окружения: локальный и глобальный.

HOME=/tmp перед cd, переменная не была изменена для текущей сессии — она была изменена для запущенной команды, в данном случае cd.

установки изменяет значение глобально, для всей сессии и выполняется так:

echo $HOME

/home/kirill.m

export HOME=/tmp
cd
pwd

/tmp

echo $HOME

/tmp

изменение происходит в рамках текущей сессии. открыто две вкладки терминала, то изменение произойдет только в той вкладке, в которой мы написали команду.


Определение переменной в Bash: с командой export и без

Bash-переменные Linux предполагают два способа определения переменной оболочки — с командой export и без нее. добавление команды меняет область действия переменной.

Bash — командный интерпретатор в юниксоподобных системах, особенно в GNU/Linux. С другой — скриптовый язык программирования со своим синтаксисом и особенностями.

Определение переменной с export и без
Переменные Bash похожи на переменные в Java или C++, но с одним существенным отличием: они не нуждаются в объявлении. Переменную создает присвоение ее имени значения.

MYVAR=1729
export MYVAR=1729
В первом случае создается переменная оболочки с именем MYVAR, которой присваивается значение 1729. Во втором определение переменной происходит точно также, но с помощью export. Эта команда отмечает переменную для экспорта во все дочерние процессы, которые созданы внутри оболочки и делают ее переменной окружения.

export делает переменную доступной для всех следующих команд, которые выполняются в этой оболочке. Команда export помечает MYVAR для автоматического экспорта в среду дочерних процессов, которые создаются такими командами:

export MYVAR=1729
echo $MYVAR
1729
bash    # Open a new child shell
echo $MYVAR
1729

Если переменная задана без использования export, то она будет доступна только внутри оболочки. Другими словами, дочерние оболочки, процесс или команды вне ее не получат доступа к ней:

MYVAR=1729
echo $MYVAR
1729
bash    # Open a new child shell
echo $MYVAR
$

Отличия переменных в Bash от переменных в других языках программирования заключаются в следующем:

Переменные оболочки (определенные без экспорта) подобны локальным переменным. Доступ к ним можно получить только внутри этой оболочки.
Переменные окружения (определенные с помощью экспорта) подобны глобальным переменным. Доступ к ним могут получить как в родительской оболочке, так и во всех дочерних оболочках, процессах и командах.
Однако между глобальными переменными в Bash и других языках программирования существует важное различие. Родительская оболочка может экспортировать свои переменные в среду дочерней оболочки, но дочерняя оболочка не может экспортировать переменные обратно в родительскую.

Переменные окружения использовать когда экспортировать переменные и сделать их доступными для следующих команд и процессов. среду использовать вместе с дочерними процессами:

При настройке среды дочернего процесса или оболочки
При определении переменной, которую будет использовать сценарий bash, выполняемый из родительской оболочки
При настройке переменных окружения для терминальных мультиплексоров (screen или tmux)
При настройке среды сборки для сценариев и инструментов сборки
Переменные оболочки стоит использовать в случаях, когда они должны существовать только в родительской оболочке.

Переменные счетчика циклов
Временные переменные

export может экспортировать не только переменные, но и функции. опцию командной строки export -f. функции будут доступны и в дочерних оболочках и процессах:

func(){
> echo hi
> }
func
hi
bash    # Open a new child shell
func
bash: func: command not found
exit   # Back to parent shell
export -f func
bash    # Open a new child shell
func
hi

Удаление переменной
Переменные окружения автоматически экспортируются во все дочерние оболочки, а также в их дочерние оболочки. Для удаления автоматически унаследованной переменной существует команда export -n:

echo $USER
ubuntu
bash    # Open a new child shell
echo $USER
ubuntu
exit   # Back to parent shell
export -n USER
bash    # Open a new child shell again
echo $USER
$

Для получения списка всех переменных и функций, экспортированных в текущую оболочку, команда export -p:

export -p
declare -x COLORTERM="truecolor"
declare -x DESKTOP_SESSION="ubuntu"
declare -x DISPLAY=":0"
declare -x GDMSESSION="ubuntu"
declare -x LESSCHARSET="latin1"
declare -x LESSCLOSE="/usr/bin/lesspipe %s %s"
declare -x LESSOPEN="|/usr/bin/lesspipe.sh %s 2>&-"
.
.
declare -x XDG_SESSION_DESKTOP="ubuntu"
declare -x XDG_SESSION_ID="2"
declare -x XDG_SESSION_TYPE="x11"
declare -x XDG_VTNR="1"

все переменные оболочки экспортированы правильно.

Для автоматического экспорта всех переменных, определенных в текущей оболочке, существует опция all export. Ее можно включать или отключать, используя команду set:

set -a # Enable allexport using single letter syntax
set -o allexport # Enable using full option name syntax
set +a # Disable allexport using single letter syntax
set +o allexport # Disable using full option name syntax
set -a
MYVAR=1729    # no export
bash    # Open a new child shell
echo $MYVAR
1729

Эту команду полезно включать перед вызовом сценария Bash, который определяет множество переменных без команды экспорта.

Как связаны родительская и дочерние оболочки
У передачи переменной окружения между родительской и дочерними оболочками существует определенная иерархия:

<img width="3042" height="1119" alt="image" src="https://github.com/user-attachments/assets/828d5dc6-1e40-4726-ac00-8ab6bf368431" />


Сценарии и export
При создании сценария, вызываемого из командной оболочки и содержащего команду export, нужно проверить соответствие результата экспорта ожидаемому. Для этого есть несколько способов.

Export во время выполнения скрипта
Выполнение сценария с командой export из командной оболочки происходит в дочерней оболочке. Это означает, что любые переменные, экспортируемые сценарием, будут доступны только его дочерним оболочкам, но не родительской. Когда выполнение сценария завершится, экспортированные переменные исчезнут из среды:

echo "export MYVAR=1729" > myscript.sh
chmod +x myscript.sh
./myscript.sh
echo $MYVAR
$

Экспорт переменной в родительскую оболочку
Если при выполнении сценария необходимо экспортировать переменную окружения в родительскую оболочку, можно использовать команду source. Она позволяет выполнить сценарий в текущей среде без создания дочерней оболочки.

echo "MYVAR=1729" > myscript.sh
source myscript.sh
echo $MYVAR
1729

Команда export помогает экспортировать переменные окружения так, чтобы они были доступны во всех дочерних процессах, оболочках и командах. Кроме того, различные параметры командной строки export и других связанных команд предоставляют различные способы определения, экспорта и использования переменных в разных оболочках и сценариях.



История команд bash хранится в файле .bash_history в домашней директории. Запись происходит при завершении сеанса. какое количество команд хранится в истории, отвечает переменная окружения HISTFILESIZE.

history

 1  docke rps
 2  free -m
 3  docker ps
 4  docker exec -it 8678a6520641 bash
 5  ls
 6  exit
 7  docker ps
 8  docker exec -it 1209b6e5ce6b bash

номер команды в выводе history, можно выполнить повторный запуск без необходимости набирать или копировать команду из истории:

# команда имела второй номер в списке выше
!2

free -m
              total        used        free      shared  buff/cache   available
Mem:           1998        1532          75          21         390         227
Swap:             0           0           0


history | grep export

 174  export HOME=/tmp
 183  history | grep export

реверсивный поиск. Ctrl + r, запустится поиск по истории. Он ожидает ввода символов и сразу отображает ближайшую команду, в которой эти символы встречаются. Если найденное соответствие вас не устроило, то повторное нажатие Ctrl + r выберет следующее соответствие из истории:



Взаимодействие с ос ведется от пользователя, созданного в системе.

Тема пользователей и их прав в системе относится к функционированию самой операционной системы. Оболочка лишь предоставляет утилиты, позволяющие анализировать доступы и изменять их.

Команда whoami выяснить имя пользователя:

whoami

kirill.m

Права пользователей
любой процесс, запускаемый в ос, стартует от имени некоторого пользователя. его возможности по влиянию на файловую систему ограничены правами пользователя, от имени которого процесс запущен.

Обратите внимание, что мы говорим не «пользователь запустил процесс», а «процесс запускается от имени пользователя». присутствие пользователя для запуска необязательно. Работая в командной строке, мы запускаем все сами. Но когда система загружается, то она запускает множество различных процессов автоматически.

Для многих процессов в системе создаются собственные пользователи с ограниченным набором прав.

Команда ps (process status) выводит отчет о работающих процессах. какой процесс и под каким пользователем запущен, можно получить из вывода ps aux:

ps aux

# Левый столбец — имя пользователя
root      7717  0.0  0.0   4244  1504 ?        S    10:52   0:00 mpstat 1 3
kirill.m  7718  0.0  0.1  36084  3236 pts/0    R+   10:52   0:00 ps aux
alexand+ 10542  0.0  0.1  21500  2892 pts/1    Ss+  10:10   0:00 -bash
root     11113  0.0  0.1  92796  2596 ?        Ss   08:50   0:00 sshd: kirill.m [priv]
kirill.m 11116  0.0  0.0  45276  1408 ?        Ss   08:50   0:00 /lib/systemd/systemd --user
kirill.m 11119  0.0  0.0  61148  1860 ?        S    08:50   0:00 (sd-pam)
kirill.m 11194  0.0  0.0  92796  1800 ?        S    08:50   0:00 sshd: kirill.m@pts/0
kirill.m 11195  0.0  0.2  21388  4448 pts/0    Ss   08:50   0:00 -bash
root     12195  0.0  0.0      0     0 ?        S    10:13   0:00 [kworker/u30:1]
root     12880  0.0  0.1  92796  2748 ?        Ss   08:55   0:00 sshd: alexander.v [priv]
alexand+ 12883  0.0  0.0  45276  1924 ?        Ss   08:55   0:00 /lib/systemd/systemd --user
alexand+ 12884  0.0  0.0  61148  1860 ?        S    08:55   0:00 (sd-pam)
alexand+ 12920  0.0  0.1  92796  2420 ?        S    08:55   0:00 sshd: alexander.v@pts/1,pts/2

Взаимодействие с файловой системой через запуск тех или иных утилит, которые модифицируют, создают или анализируют файловую структуру.

запускаем утилиту touch. Мы от своего имени стартуем процесс, внутри которого запускается программа touch. Эта программа создает файл и делает вас владельцем нового файла.

модификация существующих файлов не влияет на владельца — для его смены нужно воспользоваться специальной утилитой. В домашней директории все принадлежит пользователю:

ls -la

total 44
drwxr-xr-x 5 kirill.m kirill.m 4096 Aug 29 11:34 .
drwxr-xr-x 8 root     root     4096 Apr 26 10:38 ..
-rw------- 1 kirill.m kirill.m 2540 Aug 30 07:26 .bash_history
-rw-r--r-- 1 kirill.m kirill.m  220 Aug 31  2015 .bash_logout
-rw-r--r-- 1 kirill.m kirill.m 3771 Aug 31  2015 .bashrc
drwx------ 2 kirill.m kirill.m 4096 Mar 30 18:10 .cache
-rw------- 1 kirill.m kirill.m   55 Aug 28 18:49 .lesshst
drwxrwxr-x 2 kirill.m kirill.m 4096 Aug 29 08:35 .nano
-rw-r--r-- 1 kirill.m kirill.m  655 May 16  2017 .profile
-rw-rw-r-- 1 kirill.m kirill.m    0 Aug 29 11:27 renamed-file
drwx------ 2 kirill.m kirill.m 4096 Jan 22  2018 .ssh
-rw------- 1 kirill.m kirill.m  513 Aug 29 08:06 .viminfo

Третий столбец в этом выводе — как раз владелец. директория /home не является собственностью пользователей системы:

ls -la /home/

total 32
drwxr-xr-x  8 root              root              4096 Apr 26 10:38 .
drwxr-xr-x 23 root              root              4096 Aug 27 06:53 ..
drwxr-xr-x  5 alexander.v       alexander.v       4096 Jan 22  2018 alexander.v
drwxr-xr-x  5 kirill.m          kirill.m          4096 Aug 29 11:34 kirill.m
drwxr-xr-x  4 rakhim            rakhim            4096 Apr 26 10:05 rakhim
drwxr-xr-x  4 rakhim.d          rakhim.d          4096 Apr 26 10:41 rakhim.d
Каждый каталог в директории /home — это домашний каталог конкретного пользователя. Поэтому они все имеют разных владельцев, как правило, совпадающих с именем директории.

имя пользователя связано с идентификатором, называемым UID. Это число, которое и определяет пользователя.

Если поменяется имя пользователя, но идентификатор UID останется прежним, то все доступы останутся. Если сменится идентификатор, сменится и пользователь. Соответственно, новый пользователь потеряет доступы к старому аккаунту.

идентификатор можно разными способами.

id

uid=1002(kirill.m) gid=1002(kirill.m) groups=1002(kirill.m),999(docker)

просмотром одного важного файла, который выступает основным хранилищем пользователей в *nix-системах. Да, это обычный текстовый файл, как и все остальное:

cat /etc/passwd

root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
proxy:x:13:13:proxy:/bin:/usr/sbin/nologin
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
kirill.m:x:1002:1002::/home/kirill.m:/bin/bash

<img width="993" height="536" alt="image" src="https://github.com/user-attachments/assets/19533b31-0224-4a45-bb2a-efa746fb74fa" />


Кроме имени и идентификатора, указана командная оболочка по умолчанию и домашняя директория пользователя, которую можно поменять. Запись /usr/sbin/nologin, пользователь не может входить в систему. пользователи для запуска программ, у которых ограниченные права — входить в систему им не нужно.

Права групп пользователей
Кроме имени, у пользователей *nix-систем есть связанное с ним понятие — группа. Она создана для группового доступа к разделяемому (общему) ресурсу — например, файлу.

группа разработчиков, которые регулярно заходят на сервер. Им нужно дать одинаковые возможности по управлению определенными файлами. Владелец у файла один, не можем решить этот вопрос через смену владельца. Для этого нужно создать группу и привязать ее к самому пользователю.

Группы, ассоциированные с текущим пользователем, показываются в выводе команды id:

id

uid=1002(kirill.m) gid=1002(kirill.m) groups=1002(kirill.m),999(docker)

группа kirill.m считается основной — такая группа может быть только одна, и именно в нее входят любые создаваемые файлы от имени текущего пользователя. Кроме основной, пользователь может входить в произвольное число дополнительных групп. То, как это влияет на доступы, мы рассмотрим в одном из следующих уроков.

В *nix-системе специальный пользователь — root или суперпользователь. идентификатор со значением 0. имеет особое значение и может выполнять любые действия в системе. У пользователя root в файле /etc/passwd:

<img width="993" height="536" alt="image" src="https://github.com/user-attachments/assets/8519ef19-82b1-4ad8-8cc0-e219509a5d95" />


не использовать root на регулярной основе, и не входить под ним в систему. Суперпользователь — прямой доступ ко всему и дыра в безопасности. через него систему очень легко убить: удалить не тот файл или испортить важную конфигурацию, после чего вход в систему станет невозможным.

root для выполнения некоторых привилегированных действий, которые недоступны обычным пользователям.


повышать привилегии и выполнять команды от имени суперпользователя root.

В этом уроке обсудим, как стать другим пользователем. зайдите в систему и воспользуйтесь утилитой su (substitute user или switch user).

повышать привилегии в современных системах — утилита sudo (substitute user and do — дословно «подменить пользователя и выполнить»).

# Нет прав на выполнение
touch /etc/myfile

touch: cannot touch '/etc/myfile': Permission denied

# С `sudo` все работает
sudo touch /etc/myfile

# Видно, что владелец файла — это суперпользователь `root`
stat /etc/myfile

  File: '/etc/myfile'
  Size: 0           Blocks: 0          IO Block: 4096   regular empty file
Device: ca01h/51713d    Inode: 2761        Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)

# Нет прав на удаление
rm /etc/myfile

rm: remove write-protected regular empty file '/etc/myfile'? y
rm: cannot remove '/etc/myfile': Permission denied

# Опять помогла утилита `sudo`
sudo rm /etc/myfile

пользователя, отличного от root.  флаг -u:

sudo -u nobody mkdir /tmp/test
# Директория создана от имени пользователя nobody
stat /tmp/test

  File: '/tmp/test'
  Size: 4096        Blocks: 8          IO Block: 4096   directory
Device: ca01h/51713d    Inode: 4577        Links: 2
Access: (0755/drwxr-xr-x)  Uid: (65534/  nobody)   Gid: (65534/ nogroup)

произвести сразу пачку действий от имени другого пользователя, можно запустить новую оболочку внутри текущей. Другими словами, мы стартуем новую сессию:

# Команда `sudo` запросит пароль текущего пользователя
sudo -i

# Проверяем, что сессия запущена от суперпользователя
id

uid=0(root) gid=0(root) groups=0(root)

не забыть переключиться обратно после завершения необходимых манипуляций. Для этого наберите exit.

из-под sudo мы запустили команду, которая создает файлы и директории. владельцем этих файлов становится суперпользователь. Все последующие обращения к этому файлу без sudo начнут выдавать ошибку «У вас нет прав доступа». необязательно работать с этими файлами напрямую. Множество программ так или иначе обращаются к файловой системе для чтения конфигурационных и других файлов.


Все, что лежит в личных директориях пользователя, принадлежать этому пользователю
Все, что находится вне домашней директории пользователя и требует доп прав, должно запускаться с sudo, но бывают и исключения

ls -la

# Все содержимое домашней директории принадлежит одному пользователю
# Сама директория пользователя принадлежит ему же
# Родительская директория принадлежит суперпользователю
drwxr-xr-x+ 117 mokevnin  staff    3744 Feb 19 15:55 .
drwxr-xr-x    5 root      admin     160 Oct 12 19:15 ..
-r--------    1 mokevnin  staff       7 Nov 21  2017 .CFUserTextEncoding
-rw-r--r--@   1 mokevnin  staff   22532 Feb  8 00:04 .DS_Store


touch /etc/myfile

touch: cannot touch '/etc/myfile': Permission denied
текущий пользователь не имеет прав на создание файлов в каталоге /etc.

Кроме имени пользователя и группы, с каждым файлом ассоциированы права доступа:



# Пример строчки из вывода команды ls -la
-rw-r--r-- 1 kirill.m kirill.m 3771 Aug 31  2015 .profile

- — файл
rw- — права первого типа (для владельца файла). Владелец может читать этот файл (r) и писать в него (w). Прочерк в конце означает, что этот файл нельзя исполнять
r-- — права второго типа (для группы владельца). В нашем случае такие права есть у тех, кто входит в группу kirill.m. Запись r-- говорит о наличии доступа только для чтения, а изменение и исполнение запрещены.
r-- — права третьей группы (все остальные). В нашем случае права совпадают со второй группой, поэтому файл доступен только для чтения

<img width="2048" height="1007" alt="image" src="https://github.com/user-attachments/assets/d3677278-cc8b-4bc8-b019-cc76cfeea6d1" />


А кто может удалить этот файл? владельца, группу и права той директории, в которой лежит файл .profile. Сам файл не может обозначить прав на свое удаление, потому что права всегда берутся из той директории, в которой файл находится.

Удалить файл можно, только если у вас есть возможность писать в эту директорию:

ls -la /home/ | grep kirill

drwxr-xr-x  5 kirill.m          kirill.m          4096 Aug 29 11:34 kirill.m

Домашняя директория имеет другие права:

В самом начале вместо - d директорию
Права для владельца — rwx, а для всех остальных — r-x. только пользователь может писать внутрь своей домашней директории
Что такое x в отношении директорий? Это право позволяет перемещаться в директорию и обращаться ко всем расположенным в ней файлам и каталогам. Обращаться можно при условии, что эти файлы доступны на чтение, запись или выполнение. положить доступный на чтение файл в директорию с правом x, прочитать этот файл. Если убрать с этой директории право x, то вы лишитесь доступа к файлу.

директория — список файлов, право на чтение позволяет прочитать этот список, вывести список имен файлов, содержащихся в директории.

посмотреть не простой список имен файлов, а список с дополнительной информацией — как при выводе ls -l. Тогда потребуется еще и право x, потому что в этом случае надо обращаться к файлам за их метаданными (владелец, группа, дата изменения, права и др.). без права r вы не сможете посмотреть содержимое директории.

A	B	C	D
#	Permission	rwx	Binary
7	read, write and execute	rwx	111
6	read and write	rw-	110
5	read and execute	r-x	101
4	read only	r--	100
3	write and execute	-wx	011
2	write only	-w-	010
1	execute only	--x	001

перевести несколько примеров из буквенной формы в числовую:

drwxr-xr-x соответствует 755
-rw-r--r-- соответствует 644

пользователь root находится вне этой системы. Для него не имеет никакого значения наличие любых прав — суперпользователь может все.

Для изменения владельца файлов или директорий можно использовать утилиту chown (от англ. change owner). В самом простом использовании команда принимает имя пользователя и файл (или директорию) для которого нужно сменить пользователя:

chown kirill .profile
Для изменения прав доступа к файлам и директориям можно использовать утилиту chmod (от англ. change mode). Утилита принимает права доступа и путь к файлу. Права доступа можно записывать обоими способами. С помощью знаков + и - права добавляются или удаляются соответственно:

chmod +r file.txt
chmod 754 file.txt



В *nix-системах такой способ используется значительно реже. Для установки программ придумали пакетные менеджеры.

# Требует sudo, устанавливаем в системную директорию
sudo apt install php


Пакетный менеджер состоит из нескольких частей. Одна из них взаимодействует с пользователем напрямую — консольная утилита apt. Для установки набрать apt install и далее указать имя необходимой программы.

пакетные менеджеры требуют запуска от суперпользователя root, установка программ происходит в системные директории, недоступные для записи обычному пользователю:

apt install php

E: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)
E: Unable to lock the administration directory (/var/lib/dpkg/), are you root?
Но это не всегда так — например, в macOS не нужно использовать sudo.

Установленные пакеты можно удалять. команда apt remove:

apt remove php
# Тут тоже много вывода и вопрос, удалять ли?
На другом конце провода находится каталог пакетов. Во время попытки установить программу утилита apt выполняет запрос в каталог и пытается понять, есть ли там пакет с таким именем. Если его нет, то вы об этом узнаете:

# Пакета wrongname не существует
sudo apt install wrongname

Reading package lists... Done
Building dependency tree
Reading state information... Done
E: Unable to locate package wrongname

Для экономии ресурсов и ускорения работы пакетный менеджер apt сохраняет индекс — список пакетов в каталоге. Индекс хранится на локальном диске и используется для работы пакетного менеджера.

пакет в реальности существует, но apt утверждает обратное. Если вы чувствуете подвох, то запустите ручное обновление локального индекса:

sudo apt update
# Теперь можно устанавливать
sudo apt install php
Здесь у вас может возникнуть как минимум три вопроса:

Как узнать, какой пакет ставить?

установить определенную программу, то самый очевидный способ сделать это — найти сайт программы и выполнить действия, указанные на странице «Скачать» (Download). на этой странице написаны инструкции по пакетному менеджеру и примеры команд. К примеру, такое описание есть у Node.js.

загуглить php install ubuntu. Вы найдете статьи с такими же инструкциями.

пакет — упаковка для программы. программа ничего не знает о существовании своего пакета и пакетного менеджера. пользователи могли установить программу через менеджер пакетов, ее разработчик заранее упаковывает программу в пакет.

В Ubuntu специальный формат пакетов deb. У этого формата документация как производить упаковку.

Как программы попадают в каталог?

Все сильно зависит от политики тех, кто поддерживает работу каталога. В некоторые каталоги попасть очень тяжело. Разработчики добавляют туда только проверенный софт, поэтому программы в них обновляют медленно. В других каталогах все происходит просто и быстро.

пройти некую процедуру, чтобы добавить программу в каталог. Это один из ключевых аспектов, по которому дистрибутивы Linux отличаются друг от друга. каталоги огромны, в них входят десятки и сотни тысяч программ и библиотек.

Пакетные менеджеры есть не только в операционных системах. экосистема, внутри которой возможно распространение библиотек или программ, имеет свой пакетный менеджер.
В Node.js — пакетный менеджер npm
в PHP — Composer



Запуск программ в командной строке активирует механизм по поиску и выполнению этой программы.

Программа — лишь файл или набор файлов на диске. Один из этих файлов обязательно должен быть исполняемым. выполнить программу можно, только если она исполняемая, иначе попытка запустить ее приведет к ошибке.

механизм по запуску программ в *nix-системах основан на соглашениях. вводим некоторую команду, ls, командная оболочка начинает поиск исполняемого файла с именем ls в списке директорий, указанном в переменной окружения PATH:

echo $PATH

/home/hex/.local/bin:/home/hex/bin/:/home/hex/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

Директории друг от друга отделяются двоеточием. В этом списке присутствуют как общесистемные пути, так и специфичные пути для конкретного пользователя. В вашем случае PATH будет другой.

Поиск программы выглядит следующим образом: командная оболочка перебирает директории слева направо и ищет директорию с файлом ls, доступным для исполнения. Если такого файла не оказалось, то выводится ошибка:

wrongname

bash: wrongname: command not found

Если файл с одним и тем же именем находится одновременно в нескольких директориях, то в первую очередь мы найдем файл в директории, расположенной левее.

Если вам интересно узнать, а где лежит исполняемый файл конкретной программы, то можно воспользоваться командой type (а еще which и whereis):

type cp

cp is /bin/cp

whereis cp

cp: /bin/cp /usr/share/man/man1/cp.1

which cp

/bin/cp

ls -al /bin | grep cp

-rwxr-xr-x 1 root root  141528 Jan 18  2018 cp

файл cp принадлежит суперпользователю, но исполнять его могут все.

Скорее всего, вы заметили, что почти все пути к исполняемым файлам программ оканчиваются на директории bin. По общему соглашению исполняемые файлы в таких директориях называют бинарниками. Пакетные менеджеры знают о бинарниках и во время установки программ переносят их в одну из директорий, входящих в переменную PATH. Для вновь устанавливаемых программ это обычно /usr/local/bin.

Иногда возникает необходимость расширить PATH. Особенно часто так происходит, когда мы устанавливаем программу через пакетные менеджеры языков программирования. Делать это надо осторожно — убедившись в том, что по-другому нельзя.

В некоторых ситуациях программа, которую вы хотите запустить, не лежит по путям поиска, прописанным в PATH. Более того, она и не должна там оказаться. Представим, что исполняемый файл программы находится прямо в текущей директории. Логично предположить, что мы можем набрать имя файла и запустить его, и программа выполнится. На самом деле этого не произойдет.

Такое поведение сделано в целях безопасности: возможно, вы хотели запустить какую-то стандартную программу, а злоумышленник положил в текущую директорию вредоносную программу с таким же именем. По этой причине, прямой запуск программ всегда должен быть путем до файла — например, path/to/executable/file. А если файл лежит в текущей директории? Здесь нам поможет обращение через точку ./:

pwd

/home/hex

cd test/
ls -al

total 16
drwxr-xr-x 2 hex hex 4096 Sep 10 15:24 .
drwxr-xr-x 1 hex hex 4096 Sep 10 15:24 ..
-rwxr-xr-x 1 hex hex   60 Sep 10 15:24 executable

executable

bash: executable: command not found

./executable

Hello from executable!

Из домашней директории переходим в директорию test.
Находим в директории test исполняемый файл executable, который при запуске выводит сообщение Hello from executable!.
Пытаемся запустить по имени файл executable и получаем ошибку.
Пробуем запустить через точку и получаем успешный запуск.

Изменение переменной PATH

не рекомендуем менять переменную PATH самостоятельно. При правильной установке большинство программ самостоятельно добавляют свои исполняемые файлы в нужные места. В некоторых случаях они просят об этом пользователя — дают подсказки, какие файлы и куда нужно добавить после установки.

вручную изменить переменную PATH, нужно поправить один из конфигурационных файлов Bash. Эти файлы лежат в домашней директории пользователя и могут называться так:

.bashrc.
.bash_profile.
.profile.
В зависимости от настроек терминала, Bash загружает либо одни файлы, либо другие. Если в вашей домашней директории есть файл .bashrc, то попробуйте использовать его. Если нет, пробуйте остальные файлы в том порядке, в котором они приведены выше. Добавьте в этот файл следующую строку:

export PATH=$PATH:/path/to/directory
В этой строке вам нужно заменить /path/to/directory на путь до директории с исполняемыми файлами. После этих манипуляций не забудьте перезапустить терминал.

Если вы используете оболочку Zsh (например, на MacOS), то вместо .bashrc используется файл .zshrc. Чтобы изменить значение переменной PATH в Zsh, откройте файл ~/.zshrc и добавьте ту же самую строку


Как использовать коды завершения в Bash-скриптах

Инструменты автоматизации и мониторинга удобны тем, что разработчик может взять готовые скрипты, при необходимости адаптировать и использовать в своём проекте. Можно заметить, что в некоторых скриптах используются коды завершения (exit codes), а в других нет. О коде завершения легко забыть, но это очень полезный инструмент. Особенно важно использовать его в скриптах командной строки.

В Linux и других Unix-подобных операционных системах программы во время завершения могут передавать значение родительскому процессу. Это значение называется кодом завершения или состоянием завершения. В POSIX по соглашению действует стандарт: программа передаёт 0 при успешном исполнении и 1 или большее число при неудачном исполнении.

Если смотреть на коды завершения в контексте скриптов для командной строки, ответ очевиден. Любой полезный Bash-скрипт неизбежно будет использоваться в других скриптах или его обернут в однострочник Bash. Это особенно актуально при использовании инструментов автоматизации типа SaltStack или инструментов мониторинга типа Nagios. Эти программы исполняют скрипт и проверяют статус завершения, чтобы определить, было ли исполнение успешным.

Кроме того, даже если вы не определяете коды завершения, они всё равно есть в ваших скриптах. Но без корректного определения кодов выхода можно столкнуться с проблемами: ложными сообщениями об успешном исполнении, которые могут повлиять на работу скрипта.

Что происходит, когда коды завершения не определены
В Linux любой код, запущенный в командной строке, имеет код завершения. Если код завершения не определён, Bash-скрипты используют код выхода последней запущенной команды. Чтобы лучше понять суть, обратите внимание на пример.

#!/bin/bash
touch /root/test
echo created file
Этот скрипт запускает команды touch и echo. Если запустить этот скрипт без прав суперпользователя, команда touch не выполнится. В этот момент мы хотели бы получить информацию об ошибке с помощью соответствующего кода завершения. Чтобы проверить код выхода, достаточно ввести в командную строку специальную переменную $?. Она печатает код возврата последней запущенной команды.

$ ./tmp.sh
touch: cannot touch '/root/test': Permission denied
created file
$ echo $?
0
Как видно, после запуска команды ./tmp.sh получаем код завершения 0. Этот код говорит об успешном выполнении команды, хотя на самом деле команда не выполнилась. Скрипт из примера выше исполняет две команды: touch и echo. Поскольку код завершения не определён, получаем код выхода последней запущенной команды. Это команда echo, которая успешно выполнилась.

Скрипт:

#!/bin/bash
touch /root/test
Если убрать из скрипта команду echo, можно получить код завершения команды touch.

$ ./tmp.sh
touch: cannot touch '/root/test': Permission denied
$ echo $?
1
Поскольку touch в данном случае — последняя запущенная команда, и она не выполнилась, получаем код возврата 1.

Как использовать коды завершения в Bash-скриптах
Удаление из скрипта команды echo позволило нам получить код завершения. Что делать, если нужно сделать разные действия в случае успешного и неуспешного выполнения команды touch? Речь идёт о печати stdout в случае успеха и stderr в случае неуспеха.

Проверяем коды завершения
Выше мы пользовались специальной переменной $?, чтобы получить код завершения скрипта. Также с помощью этой переменной можно проверить, выполнилась ли команда touch успешно.

#!/bin/bash
touch /root/test 2> /dev/null
if [ $? -eq 0 ]
then
  echo "Successfully created file"
else
  echo "Could not create file" >&2
fi
После рефакторинга скрипта получаем такое поведение:

Если команда touch выполняется с кодом 0, скрипт с помощью echo сообщает об успешно созданном файле.
Если команда touch выполняется с другим кодом, скрипт сообщает, что не смог создать файл.
Любой код завершения кроме 0 значит неудачную попытку создать файл. Скрипт с помощью echo отправляет сообщение о неудаче в stderr.

Выполнение:

$ ./tmp.sh
Could not create file
Создаём собственный код завершения
Наш скрипт уже сообщает об ошибке, если команда touch выполняется с ошибкой. Но в случае успешного выполнения команды мы всё также получаем код 0.

$ ./tmp.sh
Could not create file
$ echo $?
0
Поскольку скрипт завершился с ошибкой, было бы не очень хорошей идеей передавать код успешного завершения в другую программу, которая использует этот скрипт. Чтобы добавить собственный код завершения, можно воспользоваться командой exit.

#!/bin/bash
touch /root/test 2> /dev/null
if [ $? -eq 0 ]
then
  echo "Successfully created file"
  exit 0
else
  echo "Could not create file" >&2
  exit 1
fi
Теперь в случае успешного выполнения команды touch скрипт с помощью echo сообщает об успехе и завершается с кодом 0. В противном случае скрипт печатает сообщение об ошибке при попытке создать файл и завершается с кодом 1.

Выполнение:

$ ./tmp.sh
Could not create file
$ echo $?
1
Как использовать коды завершения в командной строке
Скрипт уже умеет сообщать пользователям и программам об успешном или неуспешном выполнении. Теперь его можно использовать с другими инструментами администрирования или однострочниками командной строки.

Bash-однострочник:

$ ./tmp.sh && echo "bam" || (sudo ./tmp.sh && echo "bam" || echo "fail")
Could not create file
Successfully created file
bam
В примере выше && используется для обозначения «и», а || для обозначения «или». В данном случае команда выполняет скрипт ./tmp.sh, а затем выполняет echo "bam", если код завершения 0. Если код завершения 1, выполняется следующая команда в круглых скобках. Как видно, в скобках для группировки команд снова используются && и ||.

Скрипт использует коды завершения, чтобы понять, была ли команда успешно выполнена. Если коды завершения используются некорректно, пользователь скрипта может получить неожиданные результаты при неудачном выполнении команды.

Команда exit принимает числа от 0 до 255. В большинстве случаев можно обойтись кодами 0 и 1


создавать собственные псевдонимы команд bash, а также как одновременно запускать несколько команд с помощью одной команды bash.

TL;DR В первой части описывается, почему псевдонимы — это так важно, сколько времени они экономят и т.д., но, если вы просто хотите узнать, как создать собственные псевдонимы, то перейдите к шагу 1.

Чем старше мы становимся (знаю, время бежит), тем больше на наши плечи ложится ответственности: мы содержим семью, контролируем личный бюджет, проводим время с родными, отводим детей в детский сад и занимаемся прочими взрослыми делами.

Время — это очень важный фактор, который влияет на производительность специалистов, особенно программистов. Обязанностей становится больше, времени на обучение — меньше, а это значит, что работать нужно эффективно.

Каждую неделю я планирую публиковать рекомендации и советы по современным языкам веб-разработки для всех тех, кто хочет открыть свое дело, обучать других или просто усовершенствовать собственные навыки.

Мир программиста

Нам программистам часто приходится в рамках одного проекта много раз запускать одни и те же команды bash, например  cd .., ls -l или  pwd. От того, что мы раз в неделю запускаем эти команды производительность не снизится, а вот если запускать их приходится по два раза в день, в конце концов эффективность упадет.

Некоторые команды bash короткие, другие — длинные. Некоторые запомнить сложно, другие — легко. Главное — ускорить рабочий процесс (повысить эффективность), а для этого можно создать декларативные команды (читаемый код), которые легко запомнить и написать.

Не забывайте, что создавать псевдонимы для каждой терминальной команды не нужно, только для тех, которые вы многократно используете. Также учтите, что некоторые псевдонимы могут оказаться зарезервированными словами, так что сначала протестируйте их, иначе можете случайно заменить другую важную команду.

Сделайте команды git короче

Я провел простое испытание, чтобы продемонстрировать, сколько времени уходит на внесение изменений на Github. У среднестатистического программиста как правило уходит около 20–25 секунд на то, чтобы сделать push изменений на github.com.

# Test

git add .

git commit - m "minor changes"

git push -u origin master

Допустим, каждую неделю вы выполняете git push 15 раз, а на пуш в целом уходит 20 секунд.

В неделю уходит 5 минут
В месяц уходит 20 минут
В год — 4 часа

Эти 3 команды можно заменить одним псевдонимом lazyman "minor changes", и вместо 20 секунд мы получим 5.

В неделю уйдет 1,25 минут
В месяц уйдет 5 минут
В год —1 час

В целом производительность увеличится на 75% (в четыре раза). Речь шла о простом примере. Теперь представьте сколько времени можно сэкономить на таких командах как run apache server && run tests && report data && close или gcc project-source-code.c -o executable-file-name, которые мы запускаем 15–30 раз в день.

Как я рассчитал повышение производительности? (для зануд)

# Formula

((old - new) / old) * 100%



= ((20 sec - 5 sec) / 20 sec) * 100%

= 75 % (performance increase)

Перед тем, как приступать к созданию псевдонимов

При создании псевдонимов их обычно размещают в файле ~/.bashrc. Это скрытый файл в домашнем каталоге, доступный отовсюду. Однако, хорошим тоном считается хранить системные файлы отдельно от личных. Для этого создаем новый файл под названием  ~/.custom_aliases и добавляем все псевдонимы туда. Также не забывайте после этого выполнять source ~/.custom_aliases, иначе они не будут работать.

Шаг 1 —  Создать файл custom_aliases

Все создаваемые псевдонимы следует хранить в этом файле.

# create file

touch ~/.custom_aliases

Шаг 2 — Открыть файл custom_aliases

Откройте файл в текстовом редакторе, либо через gedit или code (Visual Studio Code), либо как считаете нужным.

Visual Studio Code (если установлен)
# opens file

code ~/.custom_aliases
Gedit
# opens file

code ~/.custom_aliases

Шаг 3 — Создать псевдонимы (aliases)

Давайте сделаем простой псевдоним: когда мы вводим «welcome»в bash терминал на экране появится «Welcome John Doe.».

alias welcome='echo "Welcome $USER."'

Шаг 4 — Обновить изменения

Перед запуском недавно созданной команды bash необходимо обновить файл custom_aliases.

# update file

source ~/.custom_aliases

Шаг 5 — Выполнить новую команду bash

Напечатайте следующее в вашей любимой командной оболочке.

# command line

welcome

> Welcome John Doe.

Молодцы! Вы только что создали собственный файл для хранения псевдонимов. А теперь давайте рассмотрим, какие виды команд можно создавать.

Собственные псевдонимы команд bash (персональные)

Ниже перечислено несколько команд bash, которые я использую для ускорения рабочего процесса.

Рекомендация: Для сохранения структуры при добавлении большого количества псевдонимов разделите их на группы — как в примере ниже — при помощи комментариев.

# Version Control

alias gs="git status"

alias gd="git add ."

alias gp="git push -u origin master"



# Directory

alias diskusage="df -h"

alias folderusage="du -ch"

alias totalfolderusage="du -sh"



# Various

alias opencustomaliases="code ~/.custom_aliases"

alias updatecustomaliases="source ~/.custom_aliases"

alias updatethenupgrade="sudo apt-get update && sudo apt-get upgrade"

Учтите, что операционные системы имеют различия, поэтому эти команды нужно сначала запустить в терминале и проверить их работоспособность перед тем, как добавлять их в файл custom_aliases.

Запуск нескольких команд

Можно создать одну команду bash, благодаря которой можно выполнять несколько команд. Есть два способа: можно написать функцию или создать псевдоним.

Пример 1  —  Создание функции

# Multiple commands



function lazyman() {

 git add .

 git commit -a -m "$1"

 git push -u origin master

}

Пример 2 —  Создание псевдонима

# Multiple commands



alias lazyman="git add . && git commit -a -m '$i' && git push -u origin master"

Не забудьте обновить файл custom_aliases, для чего нужно запустить source ~/.custom_aliases и ввести lazyman "First commit".
