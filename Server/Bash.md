https://white55.ru/cmdmain.html

### База

Терминалом программу, эмулирует поведение железного терминала из клавиатуры и монитора. окошко с командной строкой внутри
Командная оболочка — программа, через которую пользователь управляет ОС и установленными программами, используя командную строку. (shell, командный интерпретатор).
Оболочка — средство для выполнения определенных задач, а не сама задача.
Внутри терминала пользователь передает системе строки:

<img width="2048" height="1536" alt="image" src="https://github.com/user-attachments/assets/cad30575-fd03-4959-9959-1ccf13f5f092" />

Оболочка запускается внутри терминала и приглашает ко вводу команд. Командная оболочка позволяет запускать на выполнение установленные программы.
Терминал — программа, запускает командную оболочку внутри себя:

<img width="2707" height="965" alt="image" src="https://github.com/user-attachments/assets/961b5c1a-5627-435e-9d08-3d443dbb453a" />

В *nix-системах единственное дерево с корнем в /. устройства, физические и логические диски внутри дерева в виде директорий и файлов.

Информация о файле или директории stat (file system status)

Директория — специальный файл, содержит список файлов. подключаемое устройство становится файлом или директорией, если это накопитель.
печать на принтер и вывод на экран не отличаются с точки зрения кода - запись в файл.

Hard Link — доп имя для уже сущ файла
Symbolic link — символическая ссылка. файл похож на ярлык в Windows. Если удалить основной файл, символическая ссылка вести в никуда
Socket — специальный файл, через который взаимодействие между разными процессами ОС.

в каталоге /var/log файл логов Linux syslog.

В WSL syslog установите:
sudo add-apt-repository ppa:adiscon/v8-stable
sudo apt-get install rsyslog
sudo service rsyslog start.

tail -f path/to/file последние строчки файла, и ждет появления новых.

программ для просмотра содержимого файла и поиска по нему, только в режиме чтения — пейджеры.
sudo less syslog


### Потоки

Для работы с потоком ввода создать объект класса Scanner, при создании указав, с каким потоком ввода связан. 
Стандартный поток ввода (клавиатура) объектом — System.in.
стандартный поток вывода (дисплей) — объектом System.out. 
стандартный поток для вывода ошибок — System.err.

```java
// считать значение без предварительной проверки, во время исполнения программы ошибку (отладчик заранее ошибку не обнаружит)
if (sc.hasNextInt()) { // можно ли с потока ввода считать целое число
  i = sc.nextInt(); // считывает число с потока ввода
}
```

hasNext(), остались ли в потоке ввода символы.


Функция печати записывает данные в поток STDOUT (1) функцией write
ОС решает, куда вывести результат. По умолчанию на экран терминала

ЯП не взаимодействуют с железом, уметь писать в STDOUT, а дальше все сделает ОС. Программы могут только попросить ОС выполнить задачу.

перенаправление потоков. вывод команды не выводить на экран, а записать в файл:
ls -la > output

взять вывод из команды и отправить его в файл.

Кроме стандартного вывода, с каждым процессом ассоциируются два потока:
STDERR — вывод ошибок
STDIN (0) — стандартный ввод, через него программа может получать данные на вход.

wc (word count). считать количество слов, строк или символов в файле. о файле, в *nix-системах, данные можно передать и в стандартный поток ввода:

# l считать количество строк
wc -l < result # Содержимое result в стандартный ввод команды wc

стрелка меняет направление и содержимое файла отправляется в поток STDIN запускаемой программы wc.

объединим перенаправление ввода и вывода:
wc -l < result > output # Содержимое result в стандартный ввод команды wc, а вывод в файл output

отправить вывод на печать.

<img width="2048" height="1336" alt="image" src="https://github.com/user-attachments/assets/6651a098-da0e-4356-a5dc-38282b14d051" />

Поток STDERR (2) отделить вывод программы от ошибок.

выводит информацию на экран.

перенаправление вывода в файл перенаправляет только STDOUT.
отобразить содержимое несущ директории, ls ошибку:

ls lala > output # Направляем вывод ls в output

ls: cannot access 'lala': No such file or directory # Вывод на экран
Перенаправление есть, сообщение вывелось на экран. STDERR привязан к экрану, внутри output — пустота.

Перенаправление STDERR в STDOUT
за потоком закреплен файловым дескриптором. доступ к потокам ввода и вывода.

перенаправить STDERR в STDOUT или отправить оба потока в файл.

стандартный поток ошибок объединяют со стандартным потоком вывода, обрабатывать ошибки и результат выполнения вместе:

# STDOUT перенаправляется в output, затем STDERR перенаправляется в STDOUT, запись в файл продолжается
ls lala > output 2>&1

ls: cannot access 'lala': No such file or directory # Содержимое output в окне терминала

& указать поток, в который осуществляется перенаправление.

2>&1 перед > output. не работать, интерпретатор прочитает 2>&1, еще не знать, куда перенаправлен стандартный поток вывода. потоки ошибок и вывода не объединены:

ls lala 2>&1 > output

ls: cannot access 'lala': No such file or directory # Вывод в окне терминала
Перенаправление потока STDERR без вывода в файл:

#  STDERR перенаправляется в другой поток (STDOUT)
cd lala 2>&1

-bash: cd: lala: No such file or directory

Перенаправление потока в файл - указать номер перед >:

#  перенаправить STDERR в файл
cd lala 2> output

-bash: cd: lala: No such file or directory

Перенаправление обоих потоков в файл

# Оба потока (STDERR и STDOUT) перенаправляются в файл
cd lala &> output

-bash: cd: lala: No such file or directory


### Пайплайн

у процесса есть вход, а у другого — выход. их подменять, соединить.
соединять программы и протаскивать данные сквозь них. цепочка функций, звено выступает в роли преобразователя или фильтра.

погрепать по нескольким словам. неважно как расположены внутри строки, главное что они встречаются там вместе.

grep PATH .profile | grep local

PATH="$HOME/.local/bin:$PATH"
| — пайп. командная оболочка взять поток STDOUT процесса и соединить его с потоком STDIN другого.

Все утилиты, которые читают файлы, принимать данные через поток STDIN. утилита grep принимает на вход и возвращает текст, комбинировать бесконечно:

<img width="1975" height="1059" alt="image" src="https://github.com/user-attachments/assets/65fbbe99-e801-4646-91c3-6b65e6400448" />

grep PATH .profile | grep local изменить, используя перенаправление. станет проще для модификации:

cat .profile | grep PATH | grep local
файл читается катом и отправляется в поток STDIN грепа.

cat source | grep Dog | uniq | sort

Читается файл source
Грепаются входные данные по подстроке Dog
Убираются дубли (в исходном файле две одинаковых строки Dog)
Сортируются входные данные и выводятся на экран

Пайплайн основой философии Unix:
Пишите программы, которые делают что-то одно и делают это хорошо
Пишите программы, которые бы работали вместе
Пишите программы, которые бы поддерживали текстовые потоки - универсальный интерфейс

сложное поведение из простых составных блоков. концепция стандартные интерфейсы, конструкторах Lego.

### Переменные окружения

cd без аргументов делает домашнюю директорию пользователя (~) рабочей - ориентируется на переменную окружения - домашняя директория доступна в переменной окружения HOME.
сущ в рамках запущенной сессии командной оболочки, переменные пропадут, когда терминал закроется. подгружаются во время инициализации.

предназначение переменных окружения — конфигурирование системы и программ.

При вызове cd каждый раз указывать, где находится домашняя директория. Например, так: cd --home-dir /home/kirill.m.
Договариваться, что где-то будет храниться специальный файл с настройками, в том числе домашней директории. Настройки из этого файла будут читаться командой cd при каждом запуске
набор переменных, которые всегда устанавливаются bash при старте. используются большим количеством утилит и нужны для функционирования системы.

echo $HOME

/home/kirill.m

HOME=/tmp
echo $HOME

/tmp

# Возвращаем обратно
HOME=/home/kirill.m
echo $HOME

/home/kirill.m

установить HOME и выполнить переход в эту директорию с cd, отправить в домашнюю директорию:

# присваивание слева от запускаемой команды
HOME=/tmp cd

/tmp

pwd

/tmp

cd выполнила переход по пути, указанном в переменной HOME. cd, но не добавляя определение переменной слева:

cd
pwd

/home/kirill.m

echo $HOME

/home/kirill.m

переход в настоящую домашнюю директорию. вызов HOME=/tmp cd изменил переменную для конкретного запуска. 
значение переменной окружения: локальный и глобальный.

HOME=/tmp перед cd, переменная не была изменена для текущей сессии — она была изменена для запущенной команды, в данном случае cd.

установки изменяет значение глобально, для всей сессии:

echo $HOME

/home/kirill.m

export HOME=/tmp
cd
pwd

/tmp

echo $HOME

/tmp

изменение в текущей сессии. две вкладки терминала, изменение только в той вкладке, в которой написали команду.


### export

Определение переменной в Bash: с командой export и без

Bash-переменные Linux два способа определения переменной оболочки — с командой export и без нее. добавление команды меняет область действия переменной.

Bash — командный интерпретатор в юниксоподобных системах, особенно в GNU/Linux. С другой — скриптовый язык программирования со своим синтаксисом и особенностями.

Определение переменной с export и без
Переменные Bash не нуждаются в объявлении. Переменную создает присвоение ее имени значения.

MYVAR=1729
export MYVAR=1729
В первом случае создается переменная оболочки с именем MYVAR, присваивается значение 1729. 
Во втором определение переменной с export. команда отмечает переменную для экспорта во все дочерние процессы, которые созданы внутри оболочки и делают ее переменной окружения.

export делает переменную доступной для всех след команд, которые выполняются в этой оболочке. Команда export помечает MYVAR для автоматического экспорта в среду дочерних процессов, которые создаются командами:

export MYVAR=1729
echo $MYVAR
1729
bash    # Open a new child shell
echo $MYVAR
1729

Если переменная задана без использования export, доступна только внутри оболочки. дочерние оболочки, процесс или команды вне ее не получат доступа к ней:

MYVAR=1729
echo $MYVAR
1729
bash    # Open a new child shell
echo $MYVAR
$

Переменные оболочки (определенные без экспорта) локальным переменным. Доступ к ним только внутри этой оболочки.
Переменные окружения (определенные с экспорта) глобальным переменным. Доступ к ним как в родительской оболочке, во всех дочерних оболочках, процессах и командах.
Родительская оболочка может экспортировать свои переменные в среду дочерней оболочки, но дочерняя оболочка не может экспортировать переменные обратно в родительскую.

Переменные окружения использовать когда экспортировать переменные и сделать их доступными для следующих команд и процессов. среду использовать вместе с дочерними процессами:
При настройке среды дочернего процесса или оболочки
При определении переменной, которую будет использовать сценарий bash, выполняемый из родительской оболочки
При настройке переменных окружения для терминальных мультиплексоров (screen или tmux)
При настройке среды сборки для сценариев и инструментов сборки
Переменные оболочки использовать, когда они должны сущ только в родительской оболочке.

export экспортировать не только переменные, но и функции. опцию командной строки export -f. функции доступны и в дочерних оболочках и процессах:

func(){
> echo hi
> }
func
hi
bash    # Open a new child shell
func
bash: func: command not found
exit   # Back to parent shell
export -f func
bash    # Open a new child shell
func
hi

Переменные окружения автоматически экспортируются во все дочерние оболочки, в их дочерние оболочки. Для удаления автоматически унаследованной переменной export -n:

echo $USER
ubuntu
bash    # Open a new child shell
echo $USER
ubuntu
exit   # Back to parent shell
export -n USER
bash    # Open a new child shell again
echo $USER
$

Для получения списка всех переменных и функций, экспортированных в текущую оболочку export -p:

export -p
declare -x COLORTERM="truecolor"
declare -x DESKTOP_SESSION="ubuntu"
declare -x DISPLAY=":0"
declare -x GDMSESSION="ubuntu"
declare -x LESSCHARSET="latin1"
declare -x LESSCLOSE="/usr/bin/lesspipe %s %s"
declare -x LESSOPEN="|/usr/bin/lesspipe.sh %s 2>&-"
.
declare -x XDG_SESSION_DESKTOP="ubuntu"
declare -x XDG_SESSION_ID="2"
declare -x XDG_SESSION_TYPE="x11"
declare -x XDG_VTNR="1"

все переменные оболочки экспортированы правильно.

Для автоматического экспорта всех переменных, определенных в текущей оболочке, опция all export. включать или отключать set:

set -a # Enable allexport using single letter syntax
set -o allexport # Enable using full option name syntax
set +a # Disable allexport using single letter syntax
set +o allexport # Disable using full option name syntax
set -a
MYVAR=1729    # no export
bash    # Open a new child shell
echo $MYVAR
1729

команду включать перед вызовом сценария Bash, который определяет множество переменных без команды экспорта.

У передачи переменной окружения между родительской и дочерними оболочками иерархия:

<img width="3042" height="1119" alt="image" src="https://github.com/user-attachments/assets/828d5dc6-1e40-4726-ac00-8ab6bf368431" />

При создании сценария, вызываемого из командной оболочки и содержащего команду export, проверить соответствие результата экспорта ожидаемому.

Export во время выполнения скрипта
Выполнение сценария с командой export из командной оболочки происходит в дочерней оболочке. переменные, экспортируемые сценарием, доступны только его дочерним оболочкам, но не родительской. Когда выполнение сценария завершится, экспортированные переменные исчезнут из среды:

echo "export MYVAR=1729" > myscript.sh
chmod +x myscript.sh
./myscript.sh
echo $MYVAR
$

Экспорт переменной в родительскую оболочку
при выполнении сценария необходимо экспортировать переменную окружения в родительскую оболочку, команду source. выполнить сценарий в текущей среде без создания дочерней оболочки.

echo "MYVAR=1729" > myscript.sh
source myscript.sh
echo $MYVAR
1729

Команда export помогает экспортировать переменные окружения, чтобы доступны во всех дочерних процессах, оболочках и командах. различные параметры командной строки export и других связанных команд предоставляют различные способы определения, экспорта и использования переменных в разных оболочках и сценариях.

### История

```bash
history
 1  docke rps
 2  free -m
 3  docker ps

!2
free -m

history | grep export
 174  export HOME=/tmp
 183  history | grep export
```

реверсивный поиск Ctrl + r. повторное Ctrl + r выберет следующее соответствие из истории

### Пользователи

Взаимодействие с ос ведется от пользователя, созданного в системе.
Тема пользователей и их прав в системе относится к функционированию ос. Оболочка лишь предоставляет утилиты, позволяющие анализировать доступы и изменять их.

процесс, запускаемый в ос, стартует от имени пользователя.

«процесс запускается от имени пользователя». присутствие пользователя для запуска необязательно. когда система загружается, она запускает множество процессов автоматически.

Для процессов в системе создаются собственные пользователи с ограниченным набором прав.
ps (process status) работающих процессах. какой процесс и под каким пользователем запущен:

ps aux

root      7717  0.0  0.0   4244  1504 ?        S    10:52   0:00 mpstat 1 3
kirill.m  7718  0.0  0.1  36084  3236 pts/0    R+   10:52   0:00 ps aux
alexand+ 10542  0.0  0.1  21500  2892 pts/1    Ss+  10:10   0:00 -bash
root     11113  0.0  0.1  92796  2596 ?        Ss   08:50   0:00 sshd: kirill.m [priv]
kirill.m 11116  0.0  0.0  45276  1408 ?        Ss   08:50   0:00 /lib/systemd/systemd --user
kirill.m 11119  0.0  0.0  61148  1860 ?        S    08:50   0:00 (sd-pam)
kirill.m 11194  0.0  0.0  92796  1800 ?        S    08:50   0:00 sshd: kirill.m@pts/0
kirill.m 11195  0.0  0.2  21388  4448 pts/0    Ss   08:50   0:00 -bash
root     12195  0.0  0.0      0     0 ?        S    10:13   0:00 [kworker/u30:1]
root     12880  0.0  0.1  92796  2748 ?        Ss   08:55   0:00 sshd: alexander.v [priv]
alexand+ 12883  0.0  0.0  45276  1924 ?        Ss   08:55   0:00 /lib/systemd/systemd --user
alexand+ 12884  0.0  0.0  61148  1860 ?        S    08:55   0:00 (sd-pam)
alexand+ 12920  0.0  0.1  92796  2420 ?        S    08:55   0:00 sshd: alexander.v@pts/1,pts/2



запускаем утилиту touch. от своего имени стартуем процесс, внутри которого запускается программа touch. программа создает файл и делает вас владельцем нового файла.

сменится идентификатор UID - сменится и пользователь, новый пользователь потеряет доступы к старому аккаунту.

хранилищем пользователей в *nix-системах.

cat /etc/passwd

root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
proxy:x:13:13:proxy:/bin:/usr/sbin/nologin
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
kirill.m:x:1002:1002::/home/kirill.m:/bin/bash

<img width="993" height="536" alt="image" src="https://github.com/user-attachments/assets/19533b31-0224-4a45-bb2a-efa746fb74fa" />

Кроме имени и идентификатора, указана командная оболочка по умолчанию и домашняя директория пользователя, которую можно поменять. 
/usr/sbin/nologin, пользователь не может входить в систему. пользователи для запуска программ, у которых ограниченные права — входить в систему им не нужно.


группа для группового доступа к общему ресурсу — файлу. создать группу и привязать ее к пользователю.

группа kirill.m считается основной — такая группа может быть только одна, и именно в нее входят любые создаваемые файлы от имени текущего пользователя. Кроме основной, пользователь может входить в произвольное число дополнительных групп.

пользователя root выполнять любые действия в системе. в файле /etc/passwd:

<img width="993" height="536" alt="image" src="https://github.com/user-attachments/assets/8519ef19-82b1-4ad8-8cc0-e219509a5d95" />

Использовать root только для выполнения некоторых привилегированных действий.

# владелец файла — суперпользователь `root`
stat /etc/myfile

sudo -u nobody mkdir /tmp/test
# Директория создана от имени nobody
stat /tmp/test

  File: '/tmp/test'
  Size: 4096        Blocks: 8          IO Block: 4096   directory
Device: ca01h/51713d    Inode: 4577        Links: 2
Access: (0755/drwxr-xr-x)  Uid: (65534/  nobody)   Gid: (65534/ nogroup)

произвести пачку действий от имени другого пользователя, запустить новую оболочку внутри текущей. стартуем новую сессию:
sudo -i

не забыть переключиться обратно после завершения манипуляций.
exit.

из-под sudo команду, создает файлы и директории. владельцем файлов суперпользователь. обращения к файлу без sudo ошибку. Множество программ обращаются к файловой системе для чтения конфигурационных файлов.

-rw-r--r-- 1 kirill.m kirill.m 3771 Aug 31  2015 .profile
r-- — права второго типа (для группы владельца). такие права есть у тех, кто входит в группу kirill.m.
r-- — права третьей группы (все остальные).

файл не может обозначить прав на свое удаление, права всегда берутся из директории, в которой файл находится. Удалить файл, если есть возможность писать в директорию

ls -la /home/ | grep kirill

drwxr-xr-x  5 kirill.m          kirill.m          4096 Aug 29 11:34 kirill.m

x в отношении директорий - перемещаться в директорию и обращаться к расположенным в ней файлам и каталогам, при условии, что эти файлы доступны на чтение, запись или выполнение. 
положить доступный на чтение файл в директорию с правом x, прочитать этот файл. Если убрать с этой директории право x, лишитесь доступа к файлу.

директория — список файлов, право на чтение прочитать этот список, вывести список имен файлов в директории.

посмотреть список имен файлов с дополнительной информацией — право x, обращаться к файлам за их метаданными (владелец, группа, дата изменения, права и др.). 
без права r не сможете посмотреть содержимое директории.

### пакетные менеджеры

Пакетный менеджер состоит из нескольких частей. взаимодействует с пользователем — консольная утилита apt.
пакетные менеджеры требуют запуска от суперпользователя, установка программ в системные директории, недоступные для записи обычному пользователю:

sudo apt install php

apt remove php

На другом конце каталог пакетов. установить программу утилита apt запрос в каталог.


Для экономии ресурсов и ускорения работы пакетный менеджер apt сохраняет индекс — список пакетов в каталоге. Индекс хранится на локальном диске и используется для работы пакетного менеджера.

пакет существует, но apt утверждает обратное. запустите ручное обновление локального индекса:

sudo apt update
sudo apt install php

установить программу — найти сайт программы и выполнить действия, указанные на странице «Скачать» (Download). на этой странице инструкции по пакетному менеджеру и примеры команд.

пакет — упаковка для программы. программа не знает о существовании пакета и пакетного менеджера. пользователи могли установить программу через менеджер пакетов, ее разработчик заранее упаковывает программу в пакет.

В Ubuntu формат пакетов deb. У этого формата документация как производить упаковку.

Как программы попадают в каталог?

пройти некую процедуру, чтобы добавить программу в каталог. аспектов, по которому дистрибутивы Linux отличаются друг от друга.

Пакетные менеджеры есть не только в ОС. экосистема, внутри которой возможно распространение библиотек или программ, имеет пакетный менеджер.
В Node.js — пакетный менеджер npm



Запуск программ в командной строке активирует механизм по поиску и выполнению этой программы.

Программа — лишь файл или набор файлов на диске. Один из этих файлов обязательно должен быть исполняемым. выполнить программу можно, только если она исполняемая, иначе попытка запустить ее приведет к ошибке.

механизм по запуску программ в *nix-системах основан на соглашениях. вводим некоторую команду, ls, командная оболочка начинает поиск исполняемого файла с именем ls в списке директорий, указанном в переменной окружения PATH:

echo $PATH

/home/hex/.local/bin:/home/hex/bin/:/home/hex/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

Директории друг от друга отделяются двоеточием. В этом списке присутствуют как общесистемные пути, так и специфичные пути для конкретного пользователя. В вашем случае PATH будет другой.

Поиск программы выглядит следующим образом: командная оболочка перебирает директории слева направо и ищет директорию с файлом ls, доступным для исполнения. Если такого файла не оказалось, то выводится ошибка:

wrongname

bash: wrongname: command not found

Если файл с одним и тем же именем находится одновременно в нескольких директориях, то в первую очередь мы найдем файл в директории, расположенной левее.

Если вам интересно узнать, а где лежит исполняемый файл конкретной программы, то можно воспользоваться командой type (а еще which и whereis):

type cp

cp is /bin/cp

whereis cp

cp: /bin/cp /usr/share/man/man1/cp.1

which cp

/bin/cp

ls -al /bin | grep cp

-rwxr-xr-x 1 root root  141528 Jan 18  2018 cp

файл cp принадлежит суперпользователю, но исполнять его могут все.

Скорее всего, вы заметили, что почти все пути к исполняемым файлам программ оканчиваются на директории bin. По общему соглашению исполняемые файлы в таких директориях называют бинарниками. Пакетные менеджеры знают о бинарниках и во время установки программ переносят их в одну из директорий, входящих в переменную PATH. Для вновь устанавливаемых программ это обычно /usr/local/bin.

Иногда возникает необходимость расширить PATH. Особенно часто так происходит, когда мы устанавливаем программу через пакетные менеджеры языков программирования. Делать это надо осторожно — убедившись в том, что по-другому нельзя.

В некоторых ситуациях программа, которую вы хотите запустить, не лежит по путям поиска, прописанным в PATH. Более того, она и не должна там оказаться. Представим, что исполняемый файл программы находится прямо в текущей директории. Логично предположить, что мы можем набрать имя файла и запустить его, и программа выполнится. На самом деле этого не произойдет.

Такое поведение сделано в целях безопасности: возможно, вы хотели запустить какую-то стандартную программу, а злоумышленник положил в текущую директорию вредоносную программу с таким же именем. По этой причине, прямой запуск программ всегда должен быть путем до файла — например, path/to/executable/file. А если файл лежит в текущей директории? Здесь нам поможет обращение через точку ./:

pwd

/home/hex

cd test/
ls -al

total 16
drwxr-xr-x 2 hex hex 4096 Sep 10 15:24 .
drwxr-xr-x 1 hex hex 4096 Sep 10 15:24 ..
-rwxr-xr-x 1 hex hex   60 Sep 10 15:24 executable

executable

bash: executable: command not found

./executable

Hello from executable!

Из домашней директории переходим в директорию test.
Находим в директории test исполняемый файл executable, который при запуске выводит сообщение Hello from executable!.
Пытаемся запустить по имени файл executable и получаем ошибку.
Пробуем запустить через точку и получаем успешный запуск.

Изменение переменной PATH

не рекомендуем менять переменную PATH самостоятельно. При правильной установке большинство программ самостоятельно добавляют свои исполняемые файлы в нужные места. В некоторых случаях они просят об этом пользователя — дают подсказки, какие файлы и куда нужно добавить после установки.

вручную изменить переменную PATH, нужно поправить один из конфигурационных файлов Bash. Эти файлы лежат в домашней директории пользователя и могут называться так:

.bashrc.
.bash_profile.
.profile.
В зависимости от настроек терминала, Bash загружает либо одни файлы, либо другие. Если в вашей домашней директории есть файл .bashrc, то попробуйте использовать его. Если нет, пробуйте остальные файлы в том порядке, в котором они приведены выше. Добавьте в этот файл следующую строку:

export PATH=$PATH:/path/to/directory
В этой строке вам нужно заменить /path/to/directory на путь до директории с исполняемыми файлами. После этих манипуляций не забудьте перезапустить терминал.

Если вы используете оболочку Zsh (например, на MacOS), то вместо .bashrc используется файл .zshrc. Чтобы изменить значение переменной PATH в Zsh, откройте файл ~/.zshrc и добавьте ту же самую строку


Как использовать коды завершения в Bash-скриптах

Инструменты автоматизации и мониторинга удобны тем, что разработчик может взять готовые скрипты, при необходимости адаптировать и использовать в своём проекте. Можно заметить, что в некоторых скриптах используются коды завершения (exit codes), а в других нет. О коде завершения легко забыть, но это очень полезный инструмент. Особенно важно использовать его в скриптах командной строки.

В Linux и других Unix-подобных операционных системах программы во время завершения могут передавать значение родительскому процессу. Это значение называется кодом завершения или состоянием завершения. В POSIX по соглашению действует стандарт: программа передаёт 0 при успешном исполнении и 1 или большее число при неудачном исполнении.

Если смотреть на коды завершения в контексте скриптов для командной строки, ответ очевиден. Любой полезный Bash-скрипт неизбежно будет использоваться в других скриптах или его обернут в однострочник Bash. Это особенно актуально при использовании инструментов автоматизации типа SaltStack или инструментов мониторинга типа Nagios. Эти программы исполняют скрипт и проверяют статус завершения, чтобы определить, было ли исполнение успешным.

Кроме того, даже если вы не определяете коды завершения, они всё равно есть в ваших скриптах. Но без корректного определения кодов выхода можно столкнуться с проблемами: ложными сообщениями об успешном исполнении, которые могут повлиять на работу скрипта.

Что происходит, когда коды завершения не определены
В Linux любой код, запущенный в командной строке, имеет код завершения. Если код завершения не определён, Bash-скрипты используют код выхода последней запущенной команды. Чтобы лучше понять суть, обратите внимание на пример.

#!/bin/bash
touch /root/test
echo created file
Этот скрипт запускает команды touch и echo. Если запустить этот скрипт без прав суперпользователя, команда touch не выполнится. В этот момент мы хотели бы получить информацию об ошибке с помощью соответствующего кода завершения. Чтобы проверить код выхода, достаточно ввести в командную строку специальную переменную $?. Она печатает код возврата последней запущенной команды.

$ ./tmp.sh
touch: cannot touch '/root/test': Permission denied
created file
$ echo $?
0
Как видно, после запуска команды ./tmp.sh получаем код завершения 0. Этот код говорит об успешном выполнении команды, хотя на самом деле команда не выполнилась. Скрипт из примера выше исполняет две команды: touch и echo. Поскольку код завершения не определён, получаем код выхода последней запущенной команды. Это команда echo, которая успешно выполнилась.

Скрипт:

#!/bin/bash
touch /root/test
Если убрать из скрипта команду echo, можно получить код завершения команды touch.

$ ./tmp.sh
touch: cannot touch '/root/test': Permission denied
$ echo $?
1
Поскольку touch в данном случае — последняя запущенная команда, и она не выполнилась, получаем код возврата 1.

Как использовать коды завершения в Bash-скриптах
Удаление из скрипта команды echo позволило нам получить код завершения. Что делать, если нужно сделать разные действия в случае успешного и неуспешного выполнения команды touch? Речь идёт о печати stdout в случае успеха и stderr в случае неуспеха.

Проверяем коды завершения
Выше мы пользовались специальной переменной $?, чтобы получить код завершения скрипта. Также с помощью этой переменной можно проверить, выполнилась ли команда touch успешно.

#!/bin/bash
touch /root/test 2> /dev/null
if [ $? -eq 0 ]
then
  echo "Successfully created file"
else
  echo "Could not create file" >&2
fi
После рефакторинга скрипта получаем такое поведение:

Если команда touch выполняется с кодом 0, скрипт с помощью echo сообщает об успешно созданном файле.
Если команда touch выполняется с другим кодом, скрипт сообщает, что не смог создать файл.
Любой код завершения кроме 0 значит неудачную попытку создать файл. Скрипт с помощью echo отправляет сообщение о неудаче в stderr.

Выполнение:

$ ./tmp.sh
Could not create file
Создаём собственный код завершения
Наш скрипт уже сообщает об ошибке, если команда touch выполняется с ошибкой. Но в случае успешного выполнения команды мы всё также получаем код 0.

$ ./tmp.sh
Could not create file
$ echo $?
0
Поскольку скрипт завершился с ошибкой, было бы не очень хорошей идеей передавать код успешного завершения в другую программу, которая использует этот скрипт. Чтобы добавить собственный код завершения, можно воспользоваться командой exit.

#!/bin/bash
touch /root/test 2> /dev/null
if [ $? -eq 0 ]
then
  echo "Successfully created file"
  exit 0
else
  echo "Could not create file" >&2
  exit 1
fi
Теперь в случае успешного выполнения команды touch скрипт с помощью echo сообщает об успехе и завершается с кодом 0. В противном случае скрипт печатает сообщение об ошибке при попытке создать файл и завершается с кодом 1.

Выполнение:

$ ./tmp.sh
Could not create file
$ echo $?
1
Как использовать коды завершения в командной строке
Скрипт уже умеет сообщать пользователям и программам об успешном или неуспешном выполнении. Теперь его можно использовать с другими инструментами администрирования или однострочниками командной строки.

Bash-однострочник:

$ ./tmp.sh && echo "bam" || (sudo ./tmp.sh && echo "bam" || echo "fail")
Could not create file
Successfully created file
bam
В примере выше && используется для обозначения «и», а || для обозначения «или». В данном случае команда выполняет скрипт ./tmp.sh, а затем выполняет echo "bam", если код завершения 0. Если код завершения 1, выполняется следующая команда в круглых скобках. Как видно, в скобках для группировки команд снова используются && и ||.

Скрипт использует коды завершения, чтобы понять, была ли команда успешно выполнена. Если коды завершения используются некорректно, пользователь скрипта может получить неожиданные результаты при неудачном выполнении команды.

Команда exit принимает числа от 0 до 255. В большинстве случаев можно обойтись кодами 0 и 1


создавать собственные псевдонимы команд bash, а также как одновременно запускать несколько команд с помощью одной команды bash.

TL;DR В первой части описывается, почему псевдонимы — это так важно, сколько времени они экономят и т.д., но, если вы просто хотите узнать, как создать собственные псевдонимы, то перейдите к шагу 1.

Чем старше мы становимся (знаю, время бежит), тем больше на наши плечи ложится ответственности: мы содержим семью, контролируем личный бюджет, проводим время с родными, отводим детей в детский сад и занимаемся прочими взрослыми делами.

Время — это очень важный фактор, который влияет на производительность специалистов, особенно программистов. Обязанностей становится больше, времени на обучение — меньше, а это значит, что работать нужно эффективно.

Каждую неделю я планирую публиковать рекомендации и советы по современным языкам веб-разработки для всех тех, кто хочет открыть свое дело, обучать других или просто усовершенствовать собственные навыки.

Мир программиста

Нам программистам часто приходится в рамках одного проекта много раз запускать одни и те же команды bash, например  cd .., ls -l или  pwd. От того, что мы раз в неделю запускаем эти команды производительность не снизится, а вот если запускать их приходится по два раза в день, в конце концов эффективность упадет.

Некоторые команды bash короткие, другие — длинные. Некоторые запомнить сложно, другие — легко. Главное — ускорить рабочий процесс (повысить эффективность), а для этого можно создать декларативные команды (читаемый код), которые легко запомнить и написать.

Не забывайте, что создавать псевдонимы для каждой терминальной команды не нужно, только для тех, которые вы многократно используете. Также учтите, что некоторые псевдонимы могут оказаться зарезервированными словами, так что сначала протестируйте их, иначе можете случайно заменить другую важную команду.

Сделайте команды git короче

Я провел простое испытание, чтобы продемонстрировать, сколько времени уходит на внесение изменений на Github. У среднестатистического программиста как правило уходит около 20–25 секунд на то, чтобы сделать push изменений на github.com.

# Test

git add .

git commit - m "minor changes"

git push -u origin master

Допустим, каждую неделю вы выполняете git push 15 раз, а на пуш в целом уходит 20 секунд.

В неделю уходит 5 минут
В месяц уходит 20 минут
В год — 4 часа

Эти 3 команды можно заменить одним псевдонимом lazyman "minor changes", и вместо 20 секунд мы получим 5.

В неделю уйдет 1,25 минут
В месяц уйдет 5 минут
В год —1 час

В целом производительность увеличится на 75% (в четыре раза). Речь шла о простом примере. Теперь представьте сколько времени можно сэкономить на таких командах как run apache server && run tests && report data && close или gcc project-source-code.c -o executable-file-name, которые мы запускаем 15–30 раз в день.

Как я рассчитал повышение производительности? (для зануд)

# Formula

((old - new) / old) * 100%



= ((20 sec - 5 sec) / 20 sec) * 100%

= 75 % (performance increase)

Перед тем, как приступать к созданию псевдонимов

При создании псевдонимов их обычно размещают в файле ~/.bashrc. Это скрытый файл в домашнем каталоге, доступный отовсюду. Однако, хорошим тоном считается хранить системные файлы отдельно от личных. Для этого создаем новый файл под названием  ~/.custom_aliases и добавляем все псевдонимы туда. Также не забывайте после этого выполнять source ~/.custom_aliases, иначе они не будут работать.

Шаг 1 —  Создать файл custom_aliases

Все создаваемые псевдонимы следует хранить в этом файле.

# create file

touch ~/.custom_aliases

Шаг 2 — Открыть файл custom_aliases

Откройте файл в текстовом редакторе, либо через gedit или code (Visual Studio Code), либо как считаете нужным.

Visual Studio Code (если установлен)
# opens file

code ~/.custom_aliases
Gedit
# opens file

code ~/.custom_aliases

Шаг 3 — Создать псевдонимы (aliases)

Давайте сделаем простой псевдоним: когда мы вводим «welcome»в bash терминал на экране появится «Welcome John Doe.».

alias welcome='echo "Welcome $USER."'

Шаг 4 — Обновить изменения

Перед запуском недавно созданной команды bash необходимо обновить файл custom_aliases.

# update file

source ~/.custom_aliases

Шаг 5 — Выполнить новую команду bash

Напечатайте следующее в вашей любимой командной оболочке.

# command line

welcome

> Welcome John Doe.

Молодцы! Вы только что создали собственный файл для хранения псевдонимов. А теперь давайте рассмотрим, какие виды команд можно создавать.

Собственные псевдонимы команд bash (персональные)

Ниже перечислено несколько команд bash, которые я использую для ускорения рабочего процесса.

Рекомендация: Для сохранения структуры при добавлении большого количества псевдонимов разделите их на группы — как в примере ниже — при помощи комментариев.

# Version Control

alias gs="git status"

alias gd="git add ."

alias gp="git push -u origin master"



# Directory

alias diskusage="df -h"

alias folderusage="du -ch"

alias totalfolderusage="du -sh"



# Various

alias opencustomaliases="code ~/.custom_aliases"

alias updatecustomaliases="source ~/.custom_aliases"

alias updatethenupgrade="sudo apt-get update && sudo apt-get upgrade"

Учтите, что операционные системы имеют различия, поэтому эти команды нужно сначала запустить в терминале и проверить их работоспособность перед тем, как добавлять их в файл custom_aliases.

Запуск нескольких команд

Можно создать одну команду bash, благодаря которой можно выполнять несколько команд. Есть два способа: можно написать функцию или создать псевдоним.

Пример 1  —  Создание функции

# Multiple commands



function lazyman() {

 git add .

 git commit -a -m "$1"

 git push -u origin master

}

Пример 2 —  Создание псевдонима

# Multiple commands



alias lazyman="git add . && git commit -a -m '$i' && git push -u origin master"

Не забудьте обновить файл custom_aliases, для чего нужно запустить source ~/.custom_aliases и ввести lazyman "First commit".
