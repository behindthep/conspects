Для изменения строк без создания новых объектов StringBuilder и StringBuffer.

StringBuild sb = new StringBuilder("Hello");
sb.append(", world!");


Изолируйте побочные эффекты от чистого кода. в начале работы чтение данных на верхнем уровне, внутри блок чистой логики - поведение зависит только от входных аргументов, нет внешней среды и на выходе запись в файл.

Ответственность функции парсинга HTML. поведение от того, каким образо получен HTML? принимает объект response, имеет прямое отношение к сети и специфичен для библиотеки.


только сверху вниз, подстраивать модули и функции нижних уровней под верхние уровни, под имеющиеся данные и их структуру. Но внутренний код, независимый от приложения. Функция чтения файла — сама по себе, ей не важно, сколько у нас файлов.

структуры внешнего кода должны быть подстроены под аргументы функции.

Проектируем функцию compareCourses сверху-вниз. определили её внешний интерфейс и затем вглубь. Фокус на клиентах библиотеки, а не на её внутренностях.

Модули нижнего уровня не знать про модули верхнего. Верхний подстраиваться под нижний.
Разбиение на уровни код менее связанным. другую библиотеку для запросов код, отвечающий за парсинг, затронут не будет. Не сказать о реализациях, где парсинг смешан с получением данных.

- сверху-вниз — нисходящее - сначала реализуется высокоуровневая логика, а затем идет погружение в детали.
фокус не на устройстве кода, а на том, как он будет использоваться. способы использования влияют на интерфейсную часть кода — классы, методы, функции, с чем взаимодействуют клиенты кода.
TDD, встает на место пользователей, как лучше его спроектировать.

- снизу-вверх — восходящее - сначала реализуются детали, затем общая логика.
При проектировании в обратном направлении - делали-делали, а когда начали использовать — поняли, что неудобно.

понять, что от кода требуется и как он будет использоваться.

библиотека для построения различий между двумя файлами. интерфейс библиотеки — функция, принимает два пути до файлов (yml, json) и возвращает описание различий между структурами файлов.
описали, как она использоваться, но ещё не знаем как написана.

на уровень ниже, внутрь функции. прочитать файлы. пути до файлов относительными, предварительно их нормализовать, получить полный путь до файла (абсолютный).


Сравнение со строкой – худший из возможных подходов.
Адрес строится как строка. поменяется?
замена строк на вызовы функций. строить ссылки на базе сущ роутинга. несоответствия порождать исключения. менять готовую ссылку без переписывать код везде, где она используется.

Обработку через функции. Вместо ручной сборки - функции, защитить от опечаток

проверок на соответствие создание перечисления (enum). замена строк на обращение к значениям из специального описания, где есть все возможные значения. описание использоваться всеми частями программы, которые на него завязаны. изменение структуры к ошибкам, где есть неверные обращения с точки зрения нового кода.

Примеры: https://ru.hexlet.io/blog/posts/izbavlyaytes-ot-strok


разделять получение данных и их использование
// Неправильно
const { output } = state.fileTabsInfo.tabs.find(tab => tab.id === 'output').result;
// Правильно
const outputTab = state.fileTabsInfo.tabs.find(tab => tab.id === 'output');
const { output } = outputTab.result;



Кроме методов, класс System содержит поля, которые хранят ссылки и на другие сущности:
out — ссылка на сущность потока вывода информации на консоль;
in — ссылка на сущность, чтение вводимой информации с консоли.
err — похожа out, для вывода ошибок.
сущностях внутри класса System. для обращения к элементу, внутри другого элемента, оператор “.”. доступ к сущности потока вывода информации на консоль

out — поле, хранит ссылку на объект класса PrintStream. объект настроен так, что информация, которая записывается в него, попадала на консоль. объект out экземпляром класса PrintStream, у него вызвать соответствующие методы:

вывод информации на консоль в Java запускает цепочку обращения к объектам и методам:
Обратиться к сущности, которая способна соединить приложение и консоль — System;
Обратиться к потоку вывода на консоль — System.out;
Вызвать метод, записывает информацию на консоль — System.out.println();


Класс java.util.Scanner считывать данные из консоль, файлы, интернет. считывал данные с клавиатуры - передать ему объект System.in – источник данных.

переменная console типа Scanner хранила ссылку на объект типа Scanner. вызвать методы объекта, на который ссылается переменная.

ввести несколько чисел в одной строке, разделив их пробелами

console.nextLine(); // Поглощаем оставшийся символ новой строки 
"съесть" (проглотить) символ новой строки (\n), оставшийся в буфере после вызова console.nextInt().

console.nextInt() читает целое число из входных данных, но не считывает символ новой строки, который вводится после числа нажатием Enter. символ остаётся во входном буфере.
След вызов console.nextLine() считывает весь оставшийся в буфере текст до символа новой строки, в данном случае — только сам символ новой строки. 
очистить буфер, иначе след вызов console.nextLine() сразу же прочитает пустую строку (оставшийся после числа символ новой строки), и пользовательский ввод не корректным.


Сеттер поля для иммутабельного объекта отличается от обычного сеттера. не изменяет объект, а создает новый с измененым параметром класса. причина для изменения нейминга методов.

withX(…)
шаблон для сеттеров. наименование используется по умолчанию для генерируемых сеттеров в фреймворке Immutables.

Foo newFoo = foo.withX(1047);

В Immutables возможно изменить шаблон наименования через аннотацию @Value.Style, опция with="...", подчеркивает with как соглашение по-умолчанию.

Соглашение использовать with, примеры сеттеров найти в библиотеках Guavа и Java Time.

Just x(…)
в отсутствии префикса. Пример использования в Immutables при сборке объекта, используя паттерн Builder.

Foo foo = ImmutableFoo.builder()
                      .x(1047)
                      .y("Hello World")
                      .build();

перегруженный метод без аргументов, даже если не используется паттер Builder в классе. 

Foo newFoo = foo.x(5);  // setter - один аргумент
int x = newFoo.x();     // getter - без аргументов

setX(…)
Некоторые API используют стандартные наименования сеттеров для иммутабельных классов. обращаясь к объекту мы не может сразу отличить иммутабельность, а для нового участника проекта это будет каждый раз сюрприз. в стандартном JDK такое подход также использутся.

bigInt.setBit(2);

пример ошибки, метод не изменяет состояние объекта, а создает новый. При использовании сеттера в таком виде возвращаемый объект не используется, хотя и создается. Правильно использовать сеттер:

BigInteger newBigInt = bigInt.setBit(2);

deriveX(…)
Для подчеркивания факта создания нового объекта (derived - производный), шаблон deriveX(…). Иммутабельный класс Font в Java API следует этому правилу. создать новый шрифт, с указанием размера:

Font newFont = font.deriveFont(newSize);

Класс Font, а метод deriveFont(...) c JDK 1.2. В настоящее время данный формат нейминга не рапространен.

Иммутабельный объект, как аргумент
Когда иммутабельный объект является аргументом метода и влияет на вызываемый объект, то сеттер не является сеттером по сути. не требуется префикса вовсе. умножение чисел:

BigDecimal newBigDec = bigDec.multiply(BigDecimal.TEN);

…сигнатура похожа не сеттер, имя метода multiply точно описывает действие и данный нейминг в этом случае подходит лучше других альтернатив.

Аналогично String.substring, Path.resolve и не только.

Person vasya = new Person();, в памяти выделяется область под поля объекта (например, имя и возраст), а переменная vasya содержит адрес этой области — ссылку.

Переменная типа класса в Java — ссылка на объект в памяти, а не сам объект.
Person vasya = new Person("Вася", 30);
Person anotherVasya = vasya;
vasya, и anotherVasya указывают на один и тот же объект в памяти. Если изменить поле через одну переменную — оно изменится и для другой:

anotherVasya.age = 31;
System.out.println(vasya.age); // 31
