Для изменения строк без создания новых объектов StringBuilder и StringBuffer.

```java
StringBuild sb = new StringBuilder("Hello");
sb.append(", world!");
```

Вызов нестатических методов у объектов (строка) - логика относительно данных объекта.
```java
var random = new Random();
random.nextInt(10); // 0-10

import java.time.LocalDate;

var currentDate = LocalDate.now(); // дата
currentDate.getDayOfMonth(); // текущий день
```

Вызов статических методов из класса - Отношение ко всем объектам данного типа, не связаны с конкретным объектом.
```java
Math.random();
Files.readString(path); // Чтение данных по пути. Без объекта, статический метод
path.read(); // через объект файла
```

Изолируйте побочные эффекты от чистого кода. в начале работы чтение данных на самом верхнем уровне, потом внутри блок чистой логики - поведение зависит только от входных аргументов, нет внешней среды и на выходе запись в файл.

Ответственность функции парсинга HTML. поведение от того, каким образо получен HTML? принимает объект response, имеет прямое отношение к сети и специфичен для библиотеки.

функция специфична. завязана на два файла, в её коде нет, что связывало эти файлы. файлов три, переписать, обработка файла не поменялась. количество файлов любым?
снижает модульность программы.
Одни части приложения опираться на другие, где этого можно избежать. изменение в одном месте к код ломаться в другом.
только сверху вниз, подстраивать модули и функции нижних уровней под верхние уровни, под имеющиеся данные и их структуру. Но внутренний код, независимый от приложения. Функция чтения файла — сама по себе, ей не важно, сколько у нас файлов.

структуры внешнего кода должны быть подстроены под аргументы функции.

Проектируем функцию compareCourses сверху-вниз. определили её внешний интерфейс и затем вглубь. Фокус на клиентах библиотеки, а не на её внутренностях.

Механизм определения чётности и проверка ввода пользователя, угадал ли он.
Модули нижнего уровня не знать про модули верхнего. Верхний подстраиваться под нижний.

Разбиение на уровни код менее связанным. другую библиотеку для запросов код, отвечающий за парсинг, затронут не будет. Не сказать о реализациях, где парсинг смешан с получением данных.

- сверху-вниз — нисходящее - сначала реализуется высокоуровневая логика, а затем идет погружение в детали.
фокус не на устройстве кода, а на том, как он будет использоваться. способы использования влияют на интерфейсную часть кода — классы, методы, функции, с чем взаимодействуют клиенты кода.
TDD, встает на место пользователей, как лучше его спроектировать.

- снизу-вверх — восходящее - сначала реализуются детали, затем общая логика.
При проектировании в обратном направлении - делали-делали, а когда начали использовать — поняли, что неудобно.

понять, что от кода требуется и как он будет использоваться.

библиотека для построения различий между двумя файлами. интерфейс библиотеки — функция, принимает два пути до файлов (yml, json) и возвращает описание различий между структурами файлов.
описали, как она использоваться, но ещё не знаем как написана.

на уровень ниже, внутрь функции. прочитать файлы. пути до файлов относительными, предварительно их нормализовать, получить полный путь до файла (абсолютный).

**Нормализация данных** - приведении данных к общему виду перед основным алгоритмом обработки этих данных.

Сравнение со строкой – худший из возможных подходов.
Адрес строится как строка. поменяется?
замена строк на вызовы функций. строить ссылки на базе сущ роутинга. несоответствия порождать исключения. менять готовую ссылку без переписывать код везде, где она используется.

Обработку через функции. Вместо ручной сборки - функции, защитить от опечаток

проверок на соответствие создание перечисления (enum). замена строк на обращение к значениям из специального описания, где есть все возможные значения. описание использоваться всеми частями программы, которые на него завязаны. изменение структуры к ошибкам, где есть неверные обращения с точки зрения нового кода.

Примеры: https://ru.hexlet.io/blog/posts/izbavlyaytes-ot-strok


разделять получение данных и их использование
// Неправильно
const { output } = state.fileTabsInfo.tabs.find(tab => tab.id === 'output').result;
// Правильно
const outputTab = state.fileTabsInfo.tabs.find(tab => tab.id === 'output');
const { output } = outputTab.result;


### Перегрузка методов
В Java нельзя задать значение по умолчанию. Выбирается метод по типу и количеству параметров.
Для снижения дублирования метод с большим числов параметров, затем вызывать его из методов из других, где есть значения по умолчанию.

```java
public static int sum(int x, int y) {
    return x + y;
}

public static int sum(int x) {
    return sum(x, 10);
}
```

System — класс, “мост” соединяющего программу со средой, в которой она запущена. общения с окружающей средой: ОС, под которой запущена программа. консоль — приложение, установленное внутри ос.
out — статическое поле внутри System. ссылается на поток вывода на консоль.
```java
System.getenv("JAVA_HOME");
System.exit(0); // Прерывает выполнение программы - остановки JVM;
System.lineSeparator(); // Получение разделителя строк, который используется в этой ОС
System.currentTimeMillis(); // текущего времени системы в миллисекундах
```

останавливают работу программы или возвращают запрашиваемое значение.
Кроме методов, класс System содержит поля, которые хранят ссылки и на другие сущности:
out — ссылка на сущность потока вывода информации на консоль;
in — ссылка на сущность, чтение вводимой информации с консоли.
err — похожа out, для вывода ошибок.
сущностях внутри класса System. для обращения к элементу, внутри другого элемента, оператор “.”. доступ к сущности потока вывода информации на консоль

out — поле, хранит ссылку на объект класса PrintStream. объект настроен так, что информация, которая записывается в него, попадала на консоль. объект out экземпляром класса PrintStream, у него вызвать соответствующие методы:
printf() — форматированный вывод. Форматирует переданный текст, используя спец строки и аргументы;


println() — блок команд, направляет текст в поток вывода и в конце добавляет перевод строки.

вывод информации на консоль в Java запускает цепочку обращения к объектам и методам:
Обратиться к сущности, которая способна соединить приложение и консоль — System;
Обратиться к потоку вывода на консоль — System.out;
Вызвать метод, записывает информацию на консоль — System.out.println();

### Чтение с консоли

Как и для вывода (System.out), для ввода данных объект — System.in. считывать данные с клавиатуры, по одному символу за раз.

Класс java.util.Scanner считывать данные из консоль, файлы, интернет. считывал данные с клавиатуры - передать ему объект System.in – источник данных.

переменная console типа Scanner хранила ссылку на объект типа Scanner. вызвать методы объекта, на который ссылается переменная.

ввести несколько чисел в одной строке, разделив их пробелами

console.nextLine(); // Поглощаем оставшийся символ новой строки 
"съесть" (проглотить) символ новой строки (\n), оставшийся в буфере после вызова console.nextInt().

console.nextInt() читает целое число из входных данных, но не считывает символ новой строки, который вводится после числа нажатием Enter. символ остаётся во входном буфере.
След вызов console.nextLine() считывает весь оставшийся в буфере текст до символа новой строки, в данном случае — только сам символ новой строки. 
очистить буфер, иначе след вызов console.nextLine() сразу же прочитает пустую строку (оставшийся после числа символ новой строки), и пользовательский ввод не корректным.

Иммутабельные классы Java - наименование сеттеров
наименования в иммутабельных классах? шаблонам сеттеров в иммутабельны классах.

Сеттер поля для иммутабельного объекта отличается от обычного сеттера. не изменяет объект, а создает новый с измененым параметром класса. причина для изменения нейминга методов.

список различных возможных соглашений для иммутабельных классов.

withX(…)
шаблон для сеттеров. наименование используется по умолчанию для генерируемых сеттеров в фреймворке Immutables.

Foo newFoo = foo.withX(1047);

В Immutables возможно изменить шаблон наименования через аннотацию @Value.Style, опция with="...", подчеркивает with как соглашение по-умолчанию.

Соглашение использовать with, примеры сеттеров найти в библиотеках Guavа и Java Time.

Just x(…)
в отсутствии префикса. Пример использования в Immutables при сборке объекта, используя паттерн Builder.

Foo foo = ImmutableFoo.builder()
                      .x(1047)
                      .y("Hello World")
                      .build();

наименования, геттера в таком же стиле. перегруженный метод без аргументов, даже если не используется паттер Builder в классе. 

Foo newFoo = foo.x(5);  // setter - один аргумент
int x = newFoo.x();     // getter - без аргументов

соглашение фреймворк Java Spark.

setX(…)
Некоторые API используют стандартные наименования сеттеров для иммутабельных классов. Такие имена методов неочевидны, так обращаясь к объекту мы не может сразу отличить иммутабельность, а для нового участника проекта это будет каждый раз сюрприз. При этом и в стандартном JDK такое подход также использутся.

Работает с объектом типа BigInteger и пишем код для установки значения:

bigInt.setBit(2);

пример ошибки, метод не изменяет состояние объекта, а создает новый. При использовании сеттера в таком виде возвращаемый объект не используется, хотя и создается. Правильно использовать сеттер:

BigInteger newBigInt = bigInt.setBit(2);

deriveX(…)
Для подчеркивания факта создания нового объекта (derived - производный), шаблон deriveX(…). Иммутабельный класс Font в Java API следует этому правилу. создать новый шрифт, с указанием размера:

Font newFont = font.deriveFont(newSize);

Класс Font, а метод deriveFont(...) c JDK 1.2. В настоящее время данный формат нейминга не рапространен.

Иммутабельный объект, как аргумент
Когда иммутабельный объект является аргументом метода и влияет на вызываемый объект, то сеттер не является сеттером по сути. не требуется префикса вовсе. умножение чисел:

BigDecimal newBigDec = bigDec.multiply(BigDecimal.TEN);

…сигнатура похожа не сеттер, имя метода multiply точно описывает действие и данный нейминг в этом случае подходит лучше других альтернатив.

Аналогично String.substring, Path.resolve и не только.

Person vasya = new Person();, в памяти выделяется область под поля объекта (например, имя и возраст), а переменная vasya содержит адрес этой области — ссылку.

Переменная типа класса в Java — это ссылка на объект в памяти, а не сам объект.
Person vasya = new Person("Вася", 30);
Person anotherVasya = vasya;
Теперь и vasya, и anotherVasya указывают на один и тот же объект в памяти. Если изменить поле через одну переменную — оно изменится и для другой:

anotherVasya.age = 31;
System.out.println(vasya.age); // 31



