Процессор — обрабатывает информацию, выполняет команды пользователя и следит за работой всех подключенных устройств. процессор может разобрать только машинный код — набор 0 и 1, записаны в определённом порядке.

В процессор поступают электрические сигналы. Сильный сигнал 1, а слабый — 0. Набор таких цифр обозначает какую-то команду. Процессор ее распознает и выполняет.

Программы для первых компьютеров выглядели как огромные наборы 0 и 1.

чтобы процессор понимал, какие команды записаны в программе, программисты создали компилятор — программу, которая преобразует программный код в машинный.

Преобразование программного кода в машинный= компиляцией. Компиляция только преобразует код. не запускает его на исполнение. он "статически" (без запуска) транслируется в машинный код. текст программы разбирается на части и анализируется, а затем генерируется код, понятный процессору.

Разбор -> Анализ -> Генерация

этапы компиляции на примере вычисления периметра прямоугольника:

#include <iostream>

int main()
{
    double a=2.5, b=5, P;
    P = 2 * (a + b);
    printf("Width of the rectangle - %4.1f", a);// => Width of the rectangle - 2.5
    printf("\nLength of the rectangle - %4.1f", b);// => Length of the rectangle - 5.0
    printf("\nPerimeter of the rectangle is %4.1f", P);// => Perimeter of the rectangle is 15.0
    return 0;
}

После запуска программы компилятору определить, какие команды в ней записаны. компилятор разделяет программу на слова и знаки — токены, и записывает их в список. процесс - лексическим анализом. задача — получить токены.
Затем компилятор читает список и ищет токен-операторы. оператор присваивания(=), арифметические операторы(+,-,*,/), оператор вывода(printf()) и другие. операторы работают с числами, текстом и переменными.
Компилятор понять, какие токены в списке связаны с токен-оператором. для каждого оператора строится структура — логическое дерево.

операция P = 2*(a + b) преобразована в логическое дерево:

<img width="673" height="770" alt="image" src="https://github.com/user-attachments/assets/92961687-7c69-4f5c-9dd4-8c2e24920661" />

каждое дерево разобрать на команды, и каждую команду преобразовать в машинный код. Компилятор читать дерево снизу вверх и составляет список команд:
Взять переменную a, взять переменную b, сложить их
Взять результат сложения, взять число 2 и найти их произведение
Результат произведения присвоить (записать) в переменную P
Компилятор еще раз проверяет команды, находит ошибки и старается улучшить код. компилятор переводит команду в набор 0 и 1. Наборы записываются в файл, который сможет прочитать и выполнить процессор.

10111011 00010001 00000001 10111001

программу с набором исполняемых команд, которая могла компилировать другие программы на Fortran, и улучшенную версию себя.

<img width="1103" height="932" alt="image" src="https://github.com/user-attachments/assets/583c5cc0-b92f-473e-a51a-eedb0cb49d82" />

Ни один компилируемый яп не обходится без компилятора. компиляторы работают с несколькими яп.

процессоры отличаются друг от друга устройством, машинный код для одного процессора понятен, а для другого нет. ос: одна и та же программа работать на Windows, но не запустится на Linux или MacOS. пользоваться компилятором, работает с нужным процессором и ос.

Если программа работать на нескольких оc, кросс-компилятор — преобразует универсальный машинный код. GNU Compiler Collection(GCC) поддерживает C++ Java, Go и разную архитектуру процессоров.

Когда компилятор анализирует текст программы, он проверяет, соответствует ли запись оператора стандартам языка. Если найдено несоответствие, то компилятор выводит об этом информацию пользователю в виде ошибки. вся программа разобрана, пользователь видит список ошибок, которые есть в коде, и может их исправить. Пока программист не исправит ошибки, компилятор не перейдет к след этапу — генерации машинного кода для процессора. компилятор показывает пользователю:
ошибки объявления переменных или отсутствие их начальных значений
ошибки несоответствия типов
ошибки неправильной записи операторов и функций

Иногда компилятор определяет код, который при выполнении дает неправильный результат. Но преобразовать такую программу в машинный код все-таки можно. компилятор показывает пользователю предупреждение.
Компилятор — переводчик между программистом и процессором. преобразует текст программы в машинный код, определяет ряд ошибок в программе и оптимизирует ее работу.
Компилятор - программа, выполняет преобразование текста программы в машинный код, без его запуска, статически. затем запускает программу на выполнение. Интерпретатор сразу запускает код и выполняет его в процессе чтения. Промежуточного этапа как в компиляции нет.


преимущество Java над другими языками — мультиплатформенность.
компьютер умеет исполнять только простейшие команды.
У компьютера роль таких команд выполняют числа: команда закодирована некоторым числом (машинным кодом).

Писать программу в виде чисел сложно, придумали яп и компиляторы. язык, понятен человеку, с другой — компилятору. Компилятор —  программа, переводит текст программы, на яп, в набор машинных кодов.
программист пишет программу на яп, а затем запускает компилятор, который на основе написанных программистом файлов с кодом программы делает один файл с машинным кодом — окончательную (скомпилированную) программу.

Программа на C++ -> Компилятор -> Программа, состоящая из машинных кодов
Этапы компиляции для языка C++

Получившаяся программа выполняться на компьютере. код полученной программы зависит от процессора и ос. Программа, скомпилированная под Windows, не работать на телефоне с Android.

Программа на Java -> Java‑компилятор -> Программа из специальных кодов (байт‑код) -> Java VM -> Программа из машинных кодов
Этапы компиляции для языка Java

Компилятор Java не компилирует все классы в одну программу из машинных кодов. Вместо этого он компилирует каждый класс по отдельности, и не в машинные коды, а в специальный промежуточный код (байт-код). Компиляция в машинный код выполняется при запуске программы.

компилирует программу в машинный код при ее запуске?

программа JVM - Сначала запускают ее, а затем — программу, состоящую из байт-кода. JVM перед выполнением нужной программы компилирует ее в машинный код.

Если у вас крутой процессор, поддерживает больший набор машинных команд, во время "второй компиляции" сгенерируется машинный код с учетом вашего процессора и ОС. Java иногда быстрее С++, который сразу компилируется в машинный код и может использовать только самые распространение команды процессора.



набор инструкций, язык который понимает процессор
x86 процессоры используют сложный набор инструкций CISC - Complex Instruction Set Computing.
ARM процессоры используют упрощенный набор инструкций — RISC - Reduced Instruction Set Computing.

на каком языке говорят процессоры, как они проектируются. как для выполнения каждой инструкции на процессоре расположить свой логический блок. разные инструкции — разный дизайн процессора. дизайн — микроархитектура.
программисты работали с машинным кодом, писали нолики и единички. потом Assembler Низкоуровневый яп, писать простые команды типа сложить, скопировать. “за ручку” поэтапно описывать процессору каждое его действие.

Эй процессор, посмотри в центр стола.
Видишь соль? Возьми её.
Теперь посмотри на меня.
Отдай мне соль. — Ага, спасибо!
А теперь снова возьми у меня соль.
Поставь её откуда взял
Спасибо большое! Продолжай свои дела.

не написать инструкцию «Передай мне соль»? Набор комплексных инструкций CISC.
часть мебели, а точнее исполнительных блоков, не использоваться. Но многие из них там остаются. появился RISC…
бонус сокращенного набора RISC: меньше места на чипе занимает блок по декодированию команд.
